# 架构层: 系统化思考

## State 架构: 不仅仅是 "把它放进 state"

新手在 React 开发早期最常见的习惯, 就是把所有 state 一视同仁. 对于小应用来说没什么问题, 但随着应用变大, 边界变得模糊, 复杂性开始蔓延.

资深开发者会以不同方式看待 state, 分层管理:

-   **Server state**: 应该交给 React Query、SWR 或 Apollo 管理. Server state 有独特特性: 可能会过期, 需要和后端同步, 通常要在多个组件间共享. 虽然用 `useState` 也能管理, 但显然不是合适的工具.
-   **全局 client state**: 应该放在 Context、Zustand 或 Redux 中, 但仅限于真的需要全局的场景. 避免把所有 state 都提升到全局 store.
-   **本地组件 state**: 应该放在 `useState` 或 `useReducer` 中, 适用于只在单个组件及其直接子组件范围内使用的场景. 比如: modal 的开关标志、表单当前的输入值、组件执行任务时的 loading 状态.
-   **URL state**: 最适合通过路由来管理, 特别是当 state 直接影响用户看到的界面时. 比如: 筛选条件、分页、选中的 tab. 如果刷新页面后还应该保留这些信息, 那它就属于 URL.

```jsx
// 初级写法 —— 把 server data 当成本地 state
const [users, setUsers] = useState([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);

// 资深写法 —— 识别 server state
const { data: users, isLoading, error } = useQuery("users", fetchUsers);
```

<br>

## 组件架构: 边界的艺术

我们常听到 "关注点分离" (separation of concerns), 但在 React 应用中, 这到底意味着什么? 资深开发者会从 "组件边界" 的角度思考: 不仅仅是把组件拆小, 而是拆得恰到好处.

"Container vs Presentational" 模式并没有过时. 知道业务逻辑的组件不应该负责样式和布局; 负责样式和交互的组件不需要理解 API 结构.

```jsx
// 职责混合 - 更难测试和复用
const UserProfile = ({ userId }) => {
    const [user, setUser] = useState(null);
    const [editing, setEditing] = useState(false);

    useEffect(() => {
        fetchUser(userId).then(setUser);
    }, [userId]);

    const handleSave = async (data) => {
        await updateUser(userId, data);
        setUser(data);
        setEditing(false);
    };

    return (
        <div className="user-profile bg-white shadow-lg rounded-lg p-6">
            {editing ? (
                <UserEditForm user={user} onSave={handleSave} />
            ) : (
                <UserDisplay user={user} onEdit={() => setEditing(true)} />
            )}
        </div>
    );
};

// 清晰分离 - 每个组件都有单一职责
const UserProfileContainer = ({ userId }) => {
    const { data: user } = useQuery(["user", userId], () => fetchUser(userId));
    const updateMutation = useMutation(updateUser);

    const handleSave = (data) => {
        updateMutation.mutate({ userId, data });
    };

    return <UserProfile user={user} onSave={handleSave} />;
};

const UserProfile = ({ user, onSave }) => {
    const [editing, setEditing] = useState(false);

    return (
        <Card>
            {editing ? (
                <UserEditForm user={user} onSave={onSave} />
            ) : (
                <UserDisplay user={user} onEdit={() => setEditing(true)} />
            )}
        </Card>
    );
};
```

<br>

## 自定义 Hook: 逻辑抽取与复用

当某种 state 或行为模式在多个地方反复出现时, 就是提取成自定义 Hook 的信号. 但仅仅抽取逻辑还不够, 一个优秀的自定义 Hook 还需要设计一个直观自然的 API, 使用时要像 `useState` 或 `useEffect` 一样流畅.

```jsx
// 不仅要提取逻辑, 还要设计一个简洁的 API
const useToggle = (initialValue = false) => {
    const [value, setValue] = useState(initialValue);

    const toggle = useCallback(() => setValue((v) => !v), []);
    const setTrue = useCallback(() => setValue(true), []);
    const setFalse = useCallback(() => setValue(false), []);

    return [value, { toggle, setTrue, setFalse, setValue }];
};

// 使用起来自然流畅, 富有表现力
const [isModalOpen, { toggle: toggleModal, setTrue: openModal }] = useToggle();
```

<br><br>

# 代码组织层: 用结构实现扩展性

## 基于功能的目录结构

小项目里, 按类型分文件夹 (components、hooks、utils 等) 没问题. 但当项目规模增长, 这种结构就会显得零散.

基于功能的目录结构, 会把某个功能相关的代码 (components、hooks、services、styles、tests 等) 放在一起. 这样能显著提升可导航性、可维护性和扩展性.

```
src/
    features/
        auth/
            components/
                LoginForm.jsx
                SignupForm.jsx
            hooks/
                useAuth.js
            services/
                authApi.js
            index.js
        userProfile/
            components/
                UserProfile.jsx
                UserEditForm.jsx
            hooks/
                useUserProfile.js
            services/
                userApi.js
            index.js
    shared/
        components/
            Button/
            Modal/
        hooks/
        utils/
```

每个功能本质上都变成了一个拥有各自关注点的微型应用程序, 而 `shared/` 目录则保留用于跨功能使用的真正可复用的代码块.

<br>

## 可扩展的导出策略

导出策略看似微不足道, 但它对包大小和开发者体验都有着切实的影响. 周到的导出策略有助于优化构建时间和运行时性能.

```jsx
// features/userProfile/index.js
// 使用 Barrel 导出并重新导出以实现干净的导入
export { UserProfile } from "./components/UserProfile";
export { UserEditForm } from "./components/UserEditForm";
export { useUserProfile } from "./hooks/useUserProfile";

// 这样, 其他模块就可以像这样导入:
import { UserProfile, useUserProfile } from "features/userProfile";

// 而不是
import { UserProfile } from "features/userProfile/components/UserProfile";

// 某些组件仅供内部使用, 不应从 Barrel 文件中导出:
import { UserProfileHeader } from "./components/UserProfileHeader";
// 故意不导出
```

理解摇树优化, 并构建了导出结构以使其有效运行. 导出多个实用函数时, 请避免将它们捆绑到默认对象中:

```jsx
// 不利于摇树优化
export default {
    formatCurrency,
    formatDate,
    formatPhone,
};

// 有利于摇树优化
export const formatCurrency = (amount) => {
    /* */
};
export const formatDate = (date) => {
    /* */
};
export const formatPhone = (phone) => {
    /* */
};
```

<br><br>

# 组件层: 可维护的 React

## JSX: 可读模板的艺术

写 JSX 的目标不是追求形式上的 "简洁", 而是让组件的结构和用途一眼可见. 好的 JSX 能让开发者快速理解组件在做什么, 而不用去理顺复杂的内联逻辑.

```jsx
// 混乱且难以调试
<Button
    onClick={(e) => {
        e.preventDefault();
        if (user.permissions.includes("delete")) {
            setConfirmDialogOpen(true);
        } else {
            showError("Insufficient permissions");
        }
    }}
>
    Delete
</Button>;

// 意图清晰, 易于调试
const handleDeleteClick = (e) => {
    e.preventDefault();
    if (user.permissions.includes("delete")) {
        setConfirmDialogOpen(true);
    } else {
        showError("Insufficient permissions");
    }
};

<Button onClick={handleDeleteClick}>Delete</Button>;
```

**片段**使用体现了对语义 HTML 结构的关注:

```jsx
// 创建不必要的 div 包装器
const UserInfo = ({ user }) => (
    <div>
        <h2>{user.name}</h2>
        <p>{user.email}</p>
    </div>
);

// 遵循 HTML 结构
const UserInfo = ({ user }) => (
    <>
        <h2>{user.name}</h2>
        <p>{user.email}</p>
    </>
);
```

<br>

## Props: 组件的 API

Props 本质上就是组件的公共 API. 它们值得我们像对待任何公共接口一样, 进行周到的设计和精心呵护.

将 Props 解构与默认值相结合, 可以使组件具有自文档化功能:

```jsx
// 难以理解的组件需求
const Button = (props) => {
    const size = props.size || "medium";
    const variant = props.variant || "primary";
    // ...
};

// 清晰的组件 API
const Button = ({ children, size = "medium", variant = "primary", disabled = false, onClick, ...rest }) => {
    // ...
};
```

**Prop 验证**不仅仅是为了发现错误, 还为了记录预期用途:

```jsx
Button.propTypes = {
    children: PropTypes.node.isRequired,
    size: PropTypes.oneOf(["small", "medium", "large"]),
    variant: PropTypes.oneOf(["primary", "secondary", "danger"]),
    disabled: PropTypes.bool,
    onClick: PropTypes.func,
};
```

**复合组件**适用于需要协同工作的复杂 UI 模式:

```jsx
// 无需使用包含大量 props 的单体 Modal
<Modal
    title="Confirm Delete"
    content="Are you sure?"
    primaryButton="Delete"
    secondaryButton="Cancel"
    onPrimaryClick={handleDelete}
    onSecondaryClick={handleCancel}
/>

// 复合组件提供灵活性和清晰度
<Modal isOpen={isModalOpen} onClose={handleClose}>
    <Modal.Header>
        <Modal.Title>Confirm Delete</Modal.Title>
    </Modal.Header>
    <Modal.Body>
        <p>Are you sure you want to delete this item?</p>
    </Modal.Body>
    <Modal.Footer>
        <Button variant="danger" onClick={handleDelete}>Delete</Button>
        <Button variant="secondary" onClick={handleCancel}>Cancel</Button>
    </Modal.Footer>
</Modal>
```

<br><br>

# 性能层: 有目的的优化

性能并非为了优化而优化. 每种优化都有其自身的权衡. 最有经验的前端开发者会从测量开始, 在进行任何更改之前, 确保改进确实有效.

<br>

## 渲染性能优化

`React DevTools Profiler` 是首选工具. 它可以帮助发现那些重新渲染频率过高的组件、阻塞主线程的昂贵渲染, 以及子组件中发生的不必要的工作.

对于 `useMemo` 和 `useCallback` 来说, 它们是 "可选的", 而不是 "必须的". 我们的目标不是将它们散布到各个地方, 而是在性能分析显示确实有好处时使用它们.

```jsx
// 不要 memoize 任何东西
const ExpensiveComponent = ({ data, filter }) => {
    // 这样没问题 - 简单的字符串操作很便宜
    const title = data.name.toUpperCase();

    // 这需要记忆 - 计算成本高昂
    const processedData = useMemo(() => {
        return data.items
            .filter((item) => item.category === filter)
            .map((item) => ({
                ...item,
                score: calculateComplexScore(item),
            }))
            .sort((a, b) => b.score - a.score);
    }, [data.items, filter]);

    return (
        <div>
            <h1>{title}</h1>
            <DataList items={processedData} />
        </div>
    );
};
```

`React.memo` 用于频繁接收相同 props 的组件:

```jsx
// Memoize components that receive stable props but parent re-renders often
const UserListItem = React.memo(({ user, onSelect }) => (
    <div onClick={() => onSelect(user.id)}>
        <img src={user.avatar} alt={user.name} />
        <span>{user.name}</span>
    </div>
));

// But ensure handlers are stable too
const UserList = ({ users }) => {
    const handleUserSelect = useCallback((userId) => {
        // handle selection
    }, []);

    return (
        <div>
            {users.map((user) => (
                <UserListItem key={user.id} user={user} onSelect={handleUserSelect} />
            ))}
        </div>
    );
};
```

<br>

## Bundle 优化

我们将加载体验视为用户界面的一部分. 快速、渐进式的加载体验通常比缩短几毫秒的运行时性能更重要.

功能边界的**代码拆分**:

```jsx
// 路由级别拆分
const UserProfile = lazy(() => import("../features/userProfile"));
const AdminPanel = lazy(() => import("../features/admin"));

// 大型功能的组件级别拆分
const AdvancedCharts = lazy(() => import("./AdvancedCharts"));

const Dashboard = () => {
    const [showAdvanced, setShowAdvanced] = useState(false);

    return (
        <div>
            <BasicStats />
            {showAdvanced && (
                <Suspense fallback={<ChartSkeleton />}>
                    <AdvancedCharts />
                </Suspense>
            )}
        </div>
    );
};
```

**动态导入**可能不需要的库:

```jsx
// 仅在需要时加载重型日期操作库
const handleDateRangeSelect = async (startDate, endDate) => {
    const { formatDateRange } = await import("date-fns");
    return formatDateRange(startDate, endDate);
};
```

<br>
