# Vitest 测试实战技巧

## Mock 技巧详解

### 1. 模块 Mock

```javascript
// === 完全 mock 模块 ===
// vi.mock() 用于模拟整个模块的所有导出
// 第一个参数: 要 mock 的模块路径
// 第二个参数: 返回模拟实现的工厂函数
vi.mock("./api", () => ({
    // fetchUser: 创建一个 mock 函数, 返回固定的 Promise
    // vi.fn() 创建一个可以追踪调用情况的 mock 函数
    fetchUser: vi.fn(() => Promise.resolve({ id: 1, name: "John" })),
    // updateUser: 创建一个简单的 mock 函数 (无返回值)
    updateUser: vi.fn(),
}));

// === 部分 mock 模块 ===
// 当你只想 mock 模块中的部分函数时使用
vi.mock("./utils", async () => {
    // vi.importActual() 导入模块的真实实现
    // 这样可以保留其他函数的原始行为
    const actual = await vi.importActual("./utils");
    return {
        // 使用展开运算符保留所有原始导出
        ...actual,
        // 只 mock 特定函数 - 覆盖原始的 formatDate 函数
        formatDate: vi.fn(() => "2024-01-01"),
    };
});

// === 动态 mock ===
// 根据环境变量或其他条件动态创建 mock
vi.mock("./config", () => ({
    // 根据 NODE_ENV 环境变量返回不同的 API_URL
    // 测试环境使用本地地址, 其他环境使用生产地址
    API_URL: process.env.NODE_ENV === "test" ? "http://localhost" : "https://api.example.com",
}));
```

### 2. 全局对象 Mock

```javascript
// === Mock window.location 对象 ===
// Object.defineProperty() 用于重新定义对象的属性
// 在测试环境中模拟浏览器的 location 对象
Object.defineProperty(window, "location", {
    // value: 新的属性值 (模拟的 location 对象)
    value: {
        href: "http://localhost:3000", // 完整的 URL
        search: "?id=123", // URL 查询参数部分
        pathname: "/users", // URL 路径部分
    },
    // writable: 允许后续修改这个属性
    writable: true,
});

// === Mock localStorage ===
// 创建一个模拟的 localStorage 对象
const localStorageMock = {
    // 每个方法都是 mock 函数, 可以追踪调用情况
    getItem: vi.fn(), // 模拟获取存储项
    setItem: vi.fn(), // 模拟设置存储项
    removeItem: vi.fn(), // 模拟删除存储项
    clear: vi.fn(), // 模拟清空存储
};
// 将模拟对象赋值给 window.localStorage
Object.defineProperty(window, "localStorage", { value: localStorageMock });

// === Mock fetch API ===
// 将全局的 fetch 函数替换为 mock 函数
// 这样所有的网络请求都会被拦截
global.fetch = vi.fn();

// beforeEach() 在每个测试用例运行前执行
beforeEach(() => {
    // mockClear() 清除 mock 函数的调用历史
    // 确保每个测试都有干净的 mock 状态
    fetch.mockClear();
});
```

### 3. 时间 Mock

```javascript
// 导入 Vitest 的测试函数和时间控制函数
import { vi, beforeEach, afterEach } from "vitest";

// 创建时间相关的测试套件
describe("时间相关测试", () => {
    // 在每个测试用例运行前执行
    beforeEach(() => {
        // vi.useFakeTimers() 启用虚拟时间
        // 这会拦截所有时间相关的函数 (setTimeout, setInterval, Date 等)
        // 让你可以手动控制时间的流逝
        vi.useFakeTimers();
    });

    // 在每个测试用例运行后执行
    afterEach(() => {
        // vi.useRealTimers() 恢复真实时间
        // 清理虚拟时间设置, 避免影响其他测试
        vi.useRealTimers();
    });

    it("应该正确处理定时器", () => {
        // 创建一个 mock 回调函数
        const callback = vi.fn();

        // 设置一个 1000ms 的定时器
        // 在虚拟时间模式下, 这个定时器不会真的等待 1000ms
        setTimeout(callback, 1000);

        // vi.advanceTimersByTime() 手动推进虚拟时间
        // 参数: 要推进的毫秒数
        vi.advanceTimersByTime(1000);

        // 验证回调函数被调用了 1 次
        // 因为我们推进了 1000ms, 定时器应该被触发
        expect(callback).toHaveBeenCalledTimes(1);
    });

    it("应该模拟特定日期", () => {
        // 创建一个固定的日期对象
        const fixedDate = new Date("2024-01-01");

        // vi.setSystemTime() 设置系统时间为指定日期
        // 之后所有的 new Date() 调用都会返回这个固定时间
        vi.setSystemTime(fixedDate);

        // 验证 new Date() 返回我们设置的固定时间
        expect(new Date()).toEqual(fixedDate);
    });
});
```

### 4. 类和构造函数 Mock

```javascript
// === Mock 整个类 ===
// 模拟一个数据库类模块
vi.mock("./Database", () => {
    return {
        // Database: 模拟的构造函数
        // vi.fn().mockImplementation() 创建一个 mock 构造函数
        // 并指定当它被调用时应该返回什么
        Database: vi.fn().mockImplementation(() => ({
            // 返回一个包含 mock 方法的对象
            // 这些方法模拟数据库实例的行为
            connect: vi.fn(), // 模拟连接方法
            query: vi.fn(), // 模拟查询方法
            close: vi.fn(), // 模拟关闭连接方法
        })),
    };
});

// === 获取 Mock 构造函数的引用 ===
// vi.mocked() 用于获取已经被 mock 的构造函数
// 这样可以对构造函数本身进行断言 (比如检查调用次数)
const MockedDatabase = vi.mocked(Database);

it("应该创建数据库连接", () => {
    // 使用 new 操作符创建数据库实例
    // 实际上会调用我们的 mock 构造函数
    const db = new Database();

    // 验证构造函数被调用了 1 次
    expect(MockedDatabase).toHaveBeenCalledTimes(1);

    // 验证返回的实例包含 connect 方法
    // toBeDefined() 检查值不是 undefined
    expect(db.connect).toBeDefined();
});
```

## 异步测试最佳实践

### 1. Promise 测试

```javascript
// === 测试成功的 Promise ===
// async/await 是处理 Promise 的推荐方式
it("应该成功获取数据", async () => {
    // await 等待 Promise 完成并获取结果
    // 如果 Promise 被拒绝, 测试会自动失败
    const data = await fetchData();

    // 验证返回的数据结构
    expect(data).toEqual({ success: true });
});

// === 测试失败的 Promise ===
it("应该处理错误情况", async () => {
    // mockRejectedValueOnce() 让 fetch 在下一次调用时返回被拒绝的 Promise
    // 模拟网络错误情况
    fetch.mockRejectedValueOnce(new Error("Network error"));

    // expect().rejects.toThrow() 专门用于测试 Promise 拒绝
    // 验证 Promise 被拒绝并且错误消息正确
    await expect(fetchData()).rejects.toThrow("Network error");
});

// === 测试 Promise 状态 ===
it("应该返回 pending 状态的 Promise", () => {
    // 调用函数但不等待结果
    const promise = fetchData();

    // 验证返回值是 Promise 实例
    // toBeInstanceOf() 检查对象的类型
    expect(promise).toBeInstanceOf(Promise);
});
```

### 2. 回调函数测试

```javascript
// === 测试异步回调 (传统方式) ===
// 当测试函数接收 done 参数时, Vitest 会等待 done() 被调用
it("应该调用回调函数", (done) => {
    // 调用一个接受回调函数的异步函数
    asyncFunction((result) => {
        // 在回调函数中进行断言
        expect(result).toBe("success");

        // done() 告诉 Vitest 测试已完成
        // 如果不调用 done(), 测试会超时失败
        done();
    });
});

// === 使用 Promise 包装回调 (推荐方式) ===
it("应该处理回调结果", () => {
    // 返回一个 Promise, Vitest 会等待它完成
    return new Promise((resolve) => {
        // 调用异步函数
        asyncFunction((result) => {
            // 在回调中进行断言
            expect(result).toBe("success");

            // resolve() 表示 Promise 成功完成
            // 这会让测试通过
            resolve();
        });
    });
});
```

### 3. 并发异步测试

```javascript
it("应该并发处理多个请求", async () => {
    // 创建多个 Promise, 但不立即等待它们
    // 这些请求会并发执行, 而不是串行执行
    const promises = [fetchUser(1), fetchUser(2), fetchUser(3)];

    // Promise.all() 等待所有 Promise 完成
    // 如果任何一个 Promise 失败, 整个测试失败
    // 所有 Promise 成功时, 返回结果数组
    const results = await Promise.all(promises);

    // 验证返回了正确数量的结果
    expect(results).toHaveLength(3);

    // 使用 forEach 遍历每个结果
    // 验证每个用户对象都有 id 属性
    results.forEach((user) => {
        expect(user).toHaveProperty("id");
    });
});
```

## 组件测试技巧

### 1. React 组件测试

```javascript
// === 导入测试依赖 ===
// 从 @testing-library/react 导入核心测试工具
import { render, screen, waitFor } from "@testing-library/react";
// render: 将 React 组件渲染到测试环境的虚拟 DOM 中
// screen: 提供查询渲染结果的全局对象, 无需传递 container
// waitFor: 等待异步操作完成的工具, 用于异步断言

// 从 @testing-library/user-event 导入用户交互模拟工具
import userEvent from "@testing-library/user-event";
// userEvent: 更真实地模拟用户交互
// 支持复合交互: 如点击会先 focus, 再 mousedown, 再 mouseup 等

// === 测试用例 1: 基础渲染测试 ===
// it: 定义单个测试用例 (等同于 test 函数)
it("应该渲染用户信息", () => {
    // render(): 将 React 组件渲染到测试环境
    // 参数: JSX 元素, 会被渲染到一个临时的 DOM 容器中
    // 返回值: 包含各种查询方法的对象 (但通常使用全局 screen 对象)
    render(<UserProfile user={{ name: "John", email: "john@example.com" }} />);

    // screen.getByText(): 在渲染结果中查找包含指定文本的元素
    // 如果找不到元素会抛出错误, 适合用于断言元素必须存在的情况
    // toBeInTheDocument(): 来自 @testing-library/jest-dom, 验证元素在 DOM 中
    expect(screen.getByText("John")).toBeInTheDocument();
    expect(screen.getByText("john@example.com")).toBeInTheDocument();
});

// === 测试用例 2: 交互测试 ===
// async: 标记为异步测试, 因为 userEvent 的操作都是异步的
it("应该响应点击事件", async () => {
    // userEvent.setup(): 创建用户事件实例
    // 这是新版 @testing-library/user-event 的推荐用法
    // 返回一个包含各种用户交互方法的对象
    const user = userEvent.setup();

    // vi.fn(): Vitest 的 mock 函数创建工具 (等同于 Jest 的 jest.fn())
    // 创建一个可以追踪调用情况的模拟函数
    // 可以检查是否被调用、调用次数、调用参数等
    const onEdit = vi.fn();

    // 渲染组件, 传入 mock 函数作为 prop
    // mockUser: 假设这是在测试文件顶部定义的测试数据
    render(<UserProfile user={mockUser} onEdit={onEdit} />);

    // user.click(): 模拟用户点击操作
    // await: 等待点击操作完成 (userEvent 的所有操作都是异步的)
    // screen.getByRole(): 通过 ARIA 角色查找元素
    // role "button": 查找按钮元素 (button 标签或 role="button" 的元素)
    // name 选项: 通过可访问性名称进一步筛选 (通常是按钮文本或 aria-label)
    await user.click(screen.getByRole("button", { name: "编辑" }));

    // toHaveBeenCalledWith(): 验证 mock 函数被调用时的参数
    // 确认 onEdit 回调被调用, 且传入了正确的用户数据
    expect(onEdit).toHaveBeenCalledWith(mockUser);
});

// === 测试用例 3: 表单测试 ===
it("应该提交表单数据", async () => {
    // 设置用户事件实例
    const user = userEvent.setup();
    // 创建表单提交的 mock 函数
    const onSubmit = vi.fn();

    // 渲染表单组件
    render(<UserForm onSubmit={onSubmit} />);

    // user.type(): 模拟用户在输入框中输入文本
    // screen.getByLabelText(): 通过 label 文本查找关联的表单控件
    // 这种查找方式更符合用户的使用习惯和可访问性标准
    // 第二个参数是要输入的文本内容
    await user.type(screen.getByLabelText("姓名"), "John Doe");
    await user.type(screen.getByLabelText("邮箱"), "john@example.com");

    // 模拟点击提交按钮
    await user.click(screen.getByRole("button", { name: "提交" }));

    // 验证表单提交函数被调用, 且传入了正确的表单数据对象
    expect(onSubmit).toHaveBeenCalledWith({
        name: "John Doe",
        email: "john@example.com",
    });

    // 表单测试的其他常见验证:
    // - 验证表单验证错误信息的显示
    // - 验证必填字段的处理
    // - 验证表单重置功能
    // - 验证表单禁用状态
});

// === 测试用例 4: 异步状态测试 ===
it("应该显示加载状态", async () => {
    // fetch.mockImplementationOnce(): 模拟 fetch 请求的一次性实现
    // mockImplementationOnce: 只对下一次调用生效, 之后恢复原始行为
    // 返回一个 Promise, 模拟异步网络请求
    fetch.mockImplementationOnce(
        // 箭头函数返回一个 Promise
        () =>
            new Promise((resolve) =>
                // setTimeout: 模拟网络延迟 (100ms 后 resolve)
                setTimeout(
                    () =>
                        // resolve 一个模拟的 Response 对象
                        // json 方法返回模拟数据
                        resolve({ json: () => mockData }),
                    100
                )
            )
    );

    // 渲染会发起异步请求的组件
    render(<AsyncComponent />);

    // 立即验证加载状态的显示
    // 组件应该在请求开始时显示 "加载中..." 文本
    expect(screen.getByText("加载中...")).toBeInTheDocument();

    // waitFor(): 等待异步操作完成
    // 接收一个回调函数, 会重复执行直到回调不抛出错误或超时
    // 用于等待异步状态更新 (如 API 请求完成后的 DOM 更新)
    await waitFor(() => {
        // 验证数据加载完成后的状态
        // 当异步请求完成时, 组件应该显示 "数据加载完成" 文本
        expect(screen.getByText("数据加载完成")).toBeInTheDocument();
    });

    // waitFor 的配置选项:
    // await waitFor(() => { ... }, {
    //     timeout: 5000,     // 最大等待时间 (默认 1000ms)
    //     interval: 100,     // 重试间隔 (默认 50ms)
    // });

    // 异步测试的其他常用模式:
    // - 测试错误状态的显示
    // - 测试重试机制
    // - 测试加载状态的切换
    // - 测试数据更新后的 UI 变化
});
```

### 2. Vue 组件测试

```javascript
// === 导入 Vue 测试工具 ===
// 从 @vue/test-utils 导入 Vue 组件测试的核心工具
import { mount } from "@vue/test-utils";
// mount: Vue 组件的完整挂载工具
// 会渲染组件及其所有子组件, 创建完整的 DOM 树
// 与 shallowMount 不同, mount 会渲染整个组件树

// === 测试用例 1: 基础渲染测试 ===
it("应该渲染正确的内容", () => {
    // mount(): 挂载 Vue 组件到测试环境
    // 第一个参数: 要测试的 Vue 组件
    // 第二个参数: 挂载选项对象
    const wrapper = mount(UserCard, {
        // props: 传递给组件的 props 数据
        // 等同于在模板中写 <UserCard :user="{ name: 'John', age: 30 }" />
        props: {
            user: { name: "John", age: 30 },
        },
    });
    // 返回值 wrapper: 包装器对象, 提供各种查询和交互方法

    // wrapper.text(): 获取组件渲染后的所有文本内容
    // 会递归获取所有子元素的文本, 类似于 DOM 的 textContent
    // toContain(): 检查字符串是否包含指定的子字符串
    expect(wrapper.text()).toContain("John");
    expect(wrapper.text()).toContain("30");

    // 其他常用的内容验证方法:
    // wrapper.html(): 获取完整的 HTML 字符串
    // wrapper.find('selector'): 查找特定的子元素
    // wrapper.findComponent(Component): 查找子组件
    // wrapper.get('selector'): 查找元素 (找不到会抛错)
});

// === 测试用例 2: 事件测试 ===
// async: 异步测试, 因为事件触发和 DOM 更新是异步的
it("应该触发自定义事件", async () => {
    // 挂载 EditButton 组件
    const wrapper = mount(EditButton);

    // wrapper.find(): 在组件中查找匹配的元素
    // 参数可以是 CSS 选择器、组件引用等
    // .trigger(): 触发指定的 DOM 事件
    // await: 等待事件处理和可能的 DOM 更新完成
    await wrapper.find("button").trigger("click");

    // Vue 组件中的事件处理通常会触发自定义事件:
    // 例如: this.$emit('edit', data)

    // wrapper.emitted(): 获取组件发射的所有自定义事件
    // 返回一个对象, 键是事件名, 值是事件调用的数组
    // wrapper.emitted("edit"): 获取名为 "edit" 的事件调用记录
    // toBeTruthy(): 验证值为真值 (即事件确实被触发了)
    expect(wrapper.emitted("edit")).toBeTruthy();

    // toHaveLength(): 验证数组的长度
    // 这里验证 "edit" 事件被触发了 1 次
    expect(wrapper.emitted("edit")).toHaveLength(1);

    // 验证事件参数的其他方法:
    // expect(wrapper.emitted("edit")[0]).toEqual([expectedData]): 验证第一次调用的参数
    // expect(wrapper.emitted("edit")[0][0]).toBe(expectedValue): 验证第一个参数的值

    // 常见的事件测试模式:
    // - 验证表单提交事件
    // - 验证用户交互触发的自定义事件
    // - 验证组件间的通信事件
});

// === 测试用例 3: 插槽测试 ===
it("应该渲染插槽内容", () => {
    // 挂载 Modal 组件, 并提供插槽内容
    const wrapper = mount(Modal, {
        // slots: 定义插槽内容
        // 这是测试 Vue 插槽功能的关键配置
        slots: {
            // default: 默认插槽的内容
            // 等同于在模板中写 <Modal><p>插槽内容</p></Modal>
            default: "<p>插槽内容</p>",

            // footer: 具名插槽的内容
            // 等同于在模板中写 <template #footer><button>关闭</button></template>
            footer: "<button>关闭</button>",
        },
    });
    // 插槽内容可以是:
    // - HTML 字符串 (如上所示)
    // - 组件对象
    // - 渲染函数
    // - 组件数组

    // wrapper.html(): 获取组件渲染后的完整 HTML
    // 包含组件本身和所有插槽内容的 HTML 字符串
    // toContain(): 验证 HTML 中包含指定的字符串
    expect(wrapper.html()).toContain("<p>插槽内容</p>");
    expect(wrapper.html()).toContain("<button>关闭</button>");

    // 插槽测试的其他验证方法:
    // wrapper.find('p').text(): 查找特定元素并验证其文本
    // wrapper.findComponent(ChildComponent): 验证插槽中的子组件
    // wrapper.find('[data-testid="slot-content"]'): 通过测试 ID 查找

    // 高级插槽测试:
    // - 作用域插槽的测试
    // - 条件插槽的测试
    // - 动态插槽的测试
    // - 插槽回退内容的测试
});

// === Vue 测试的其他常用模式 ===
//
// Props 变化测试:
// await wrapper.setProps({ newProp: 'newValue' });
// expect(wrapper.text()).toContain('newValue');
//
// 数据变化测试:
// await wrapper.setData({ count: 5 });
// expect(wrapper.find('.count').text()).toBe('5');
//
// 组合式 API 测试:
// const wrapper = mount(Component, {
//     global: {
//         provide: { injectionKey: mockValue }
//     }
// });
//
// 路由测试:
// const wrapper = mount(Component, {
//     global: {
//         mocks: { $route: mockRoute, $router: mockRouter }
//     }
// });
//
// 状态管理测试 (Pinia/Vuex):
// const wrapper = mount(Component, {
//     global: {
//         plugins: [createTestingPinia()]
//     }
// });
```

## 测试数据管理

### 1. 测试夹具 (Fixtures)

```javascript
// fixtures/users.js
export const mockUsers = [
    { id: 1, name: "John", email: "john@example.com", role: "admin" },
    { id: 2, name: "Jane", email: "jane@example.com", role: "user" },
    { id: 3, name: "Bob", email: "bob@example.com", role: "user" },
];

export const createMockUser = (overrides = {}) => ({
    id: Math.random(),
    name: "Test User",
    email: "test@example.com",
    role: "user",
    createdAt: new Date().toISOString(),
    ...overrides,
});

// 使用夹具
import { mockUsers, createMockUser } from "./fixtures/users";

it("应该过滤管理员用户", () => {
    const admins = filterAdmins(mockUsers);
    expect(admins).toHaveLength(1);
    expect(admins[0].role).toBe("admin");
});

it("应该创建新用户", () => {
    const newUser = createMockUser({ name: "Custom User" });
    expect(newUser.name).toBe("Custom User");
    expect(newUser.email).toBe("test@example.com");
});
```

### 2. 工厂函数

```javascript
// factories/userFactory.js
class UserFactory {
    static create(overrides = {}) {
        return {
            id: this.generateId(),
            name: this.generateName(),
            email: this.generateEmail(),
            createdAt: new Date(),
            ...overrides,
        };
    }

    static createMany(count, overrides = {}) {
        return Array.from({ length: count }, () => this.create(overrides));
    }

    static generateId() {
        return Math.floor(Math.random() * 1000);
    }

    static generateName() {
        const names = ["John", "Jane", "Bob", "Alice", "Charlie"];
        return names[Math.floor(Math.random() * names.length)];
    }

    static generateEmail() {
        return `user${Math.random()}@example.com`;
    }
}

// 使用工厂
it("应该处理批量用户", () => {
    const users = UserFactory.createMany(5);
    expect(users).toHaveLength(5);

    const result = processBatchUsers(users);
    expect(result.success).toBe(true);
});
```

### 3. 测试构建器模式

```javascript
// builders/userBuilder.js
class UserBuilder {
    constructor() {
        this.user = {
            id: 1,
            name: "Default User",
            email: "default@example.com",
            role: "user",
            isActive: true,
        };
    }

    withId(id) {
        this.user.id = id;
        return this;
    }

    withName(name) {
        this.user.name = name;
        return this;
    }

    withRole(role) {
        this.user.role = role;
        return this;
    }

    inactive() {
        this.user.isActive = false;
        return this;
    }

    build() {
        return { ...this.user };
    }
}

// 使用构建器
it("应该处理非活跃的管理员", () => {
    const user = new UserBuilder().withRole("admin").inactive().build();

    const result = processUser(user);
    expect(result.shouldNotify).toBe(true);
});
```

## 错误和边界情况测试

### 1. 错误处理测试

```javascript
// 测试同步错误
it("应该抛出验证错误", () => {
    expect(() => {
        validateEmail("invalid-email");
    }).toThrow("无效的邮箱格式");
});

// 测试异步错误
it("应该处理网络错误", async () => {
    fetch.mockRejectedValueOnce(new Error("网络连接失败"));

    await expect(fetchUserData()).rejects.toThrow("网络连接失败");
});

// 测试错误类型
it("应该抛出特定类型的错误", () => {
    expect(() => {
        parseJSON("invalid json");
    }).toThrow(SyntaxError);
});
```

### 2. 边界值测试

```javascript
describe("数组处理函数", () => {
    it("应该处理空数组", () => {
        expect(processArray([])).toEqual([]);
    });

    it("应该处理单元素数组", () => {
        expect(processArray([1])).toEqual([1]);
    });

    it("应该处理大数组", () => {
        const largeArray = Array.from({ length: 1000 }, (_, i) => i);
        const result = processArray(largeArray);
        expect(result).toHaveLength(1000);
    });

    it("应该处理 null 和 undefined", () => {
        expect(() => processArray(null)).toThrow();
        expect(() => processArray(undefined)).toThrow();
    });
});
```

### 3. 输入验证测试

```javascript
describe("用户输入验证", () => {
    const testCases = [
        { input: "", expected: false, description: "空字符串" },
        { input: "a", expected: false, description: "太短" },
        { input: "valid@email.com", expected: true, description: "有效邮箱" },
        { input: "invalid-email", expected: false, description: "无效格式" },
        { input: "test@", expected: false, description: "不完整邮箱" },
        { input: "@example.com", expected: false, description: "缺少用户名" },
    ];

    testCases.forEach(({ input, expected, description }) => {
        it(`应该${expected ? "接受" : "拒绝"} ${description}`, () => {
            expect(validateEmail(input)).toBe(expected);
        });
    });
});
```

## 性能测试

### 1. 执行时间测试

```javascript
it("应该在合理时间内完成", async () => {
    const start = performance.now();

    await heavyComputation();

    const duration = performance.now() - start;
    expect(duration).toBeLessThan(1000); // 应该在 1 秒内完成
});
```

### 2. 内存使用测试

```javascript
it("应该不会造成内存泄漏", () => {
    const initialMemory = process.memoryUsage().heapUsed;

    // 执行可能造成内存泄漏的操作
    for (let i = 0; i < 1000; i++) {
        createLargeObject();
    }

    // 强制垃圾回收
    global.gc && global.gc();

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;

    // 内存增长应该在合理范围内
    expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // 10MB
});
```

## 测试组织和结构

### 1. 分组测试

```javascript
describe("用户管理系统", () => {
    describe("创建用户", () => {
        it("应该创建有效用户", () => {
            // 测试逻辑
        });

        it("应该拒绝无效数据", () => {
            // 测试逻辑
        });
    });

    describe("更新用户", () => {
        beforeEach(() => {
            // 每个更新测试前的设置
        });

        it("应该更新用户信息", () => {
            // 测试逻辑
        });
    });

    describe("删除用户", () => {
        it("应该软删除用户", () => {
            // 测试逻辑
        });
    });
});
```

### 2. 测试生命周期

```javascript
describe("数据库操作", () => {
    // 整个测试套件运行前执行一次
    beforeAll(async () => {
        await setupDatabase();
    });

    // 整个测试套件运行后执行一次
    afterAll(async () => {
        await cleanupDatabase();
    });

    // 每个测试前执行
    beforeEach(async () => {
        await clearTables();
        await seedTestData();
    });

    // 每个测试后执行
    afterEach(() => {
        vi.clearAllMocks();
    });

    it("应该插入新记录", () => {
        // 测试逻辑
    });
});
```

## 调试技巧

### 1. 调试输出

```javascript
it("调试复杂逻辑", () => {
    const input = { a: 1, b: 2 };

    // 使用 console.log 调试
    console.log("输入数据:", input);

    const result = complexFunction(input);

    // 输出中间结果
    console.log("处理结果:", result);

    expect(result).toEqual({ sum: 3 });
});
```

### 2. 快照调试

```javascript
it("应该生成正确的输出结构", () => {
    const result = generateComplexObject();

    // 生成快照用于调试
    expect(result).toMatchSnapshot();

    // 或者只检查特定部分
    expect(result.metadata).toMatchSnapshot("metadata");
});
```

### 3. 条件断点

```javascript
it("条件调试", () => {
    const items = generateTestItems();

    items.forEach((item, index) => {
        const result = processItem(item);

        // 只在特定条件下断点
        if (result.error && index > 10) {
            debugger; // 浏览器开发工具中会暂停
        }

        expect(result.success).toBe(true);
    });
});
```

## 最佳实践总结

### 1. 测试命名

```javascript
// ❌ 不好的命名
it("test user creation", () => {});

// ✅ 好的命名
it("应该在提供有效数据时创建新用户", () => {});
```

### 2. 测试独立性

```javascript
// ❌ 测试间有依赖
let userId;
it("创建用户", () => {
    userId = createUser().id;
});
it("删除用户", () => {
    deleteUser(userId); // 依赖上一个测试
});

// ✅ 测试独立
it("应该删除存在的用户", () => {
    const user = createUser();
    const result = deleteUser(user.id);
    expect(result.success).toBe(true);
});
```

### 3. 测试数据隔离

```javascript
// ❌ 共享可变数据
const sharedData = { count: 0 };

// ✅ 每个测试独立数据
it("应该增加计数", () => {
    const data = { count: 0 };
    increment(data);
    expect(data.count).toBe(1);
});
```

通过这些实战技巧, 你可以编写更加健壮、可维护的测试代码, 提升测试质量和开发效率.
