# Vitest 配置详解

## 配置文件类型

### 1. 独立配置文件

```typescript
// vitest.config.ts - 独立的 Vitest 配置文件
// 从 vitest/config 导入配置函数 (专门用于 Vitest)
import { defineConfig } from "vitest/config";

// 导出默认配置对象
export default defineConfig({
    // test 属性: 包含所有 Vitest 相关的配置选项
    // 这是 Vitest 配置的根节点, 所有测试相关设置都在这里
    test: {
        // 在这里添加各种 Vitest 配置选项
        // 例如: environment, include, exclude, coverage 等
    },
});
```

### 2. 与 Vite 集成

```typescript
// vite.config.ts - 将 Vitest 配置集成到 Vite 配置中
// 这行 TypeScript 指令引入 Vitest 的类型定义
// 让编辑器能够为 test 配置提供智能提示
/// <reference types="vitest/config" />

// 从 vite 导入配置函数 (不是从 vitest/config)
import { defineConfig } from "vite";

export default defineConfig({
    // Vite 相关配置: 构建工具、开发服务器、插件等
    plugins: [], // Vite 插件数组

    // Vitest 配置: 直接添加到 Vite 配置对象中
    // 好处: Vitest 可以继承 Vite 的插件和设置 (如路径别名、环境变量等)
    test: {
        // 所有 Vitest 配置选项都写在这里
        // 与独立配置文件的 test 部分完全相同
    },
});
```

### 3. 配置合并

```typescript
// vitest.config.ts - 合并现有 Vite 配置和 Vitest 配置
// 从 vitest/config 导入配置函数和合并函数
import { defineConfig, mergeConfig } from "vitest/config";
// 导入现有的 Vite 配置
import viteConfig from "./vite.config";

// mergeConfig() 用于合并两个配置对象
// 第一个参数: 基础配置 (现有的 Vite 配置)
// 第二个参数: 要合并的配置 (Vitest 特定配置)
export default mergeConfig(
    viteConfig, // 现有的 Vite 配置作为基础
    defineConfig({
        test: {
            // Vitest 特定配置
            // 这些配置会与 viteConfig 中的设置合并
            // 如果有冲突, 这里的配置会覆盖 viteConfig 中的相同配置
        },
    })
);
```

## 核心配置选项详解

### include - 测试文件匹配

```typescript
test: {
    // include: 定义哪些文件会被识别为测试文件
    // 使用 glob 模式 (通配符模式) 来匹配文件路径

    // 默认匹配模式 - 覆盖大多数常见的测试文件命名
    include: ["**/*.{test,spec}.?(c|m)[jt]s?(x)"];
    // 解析: 匹配任意目录下的 .test.* 或 .spec.* 文件
    // 支持 js/ts/jsx/tsx 以及 CommonJS(.cjs) 和 ES Module(.mjs) 格式

    // 常用自定义模式示例:
    include: [
        "**/*.test.js", // 只匹配以 .test.js 结尾的文件
        "tests/**/*.js", // 只匹配 tests 目录下的所有 .js 文件
        "src/**/*.{test,spec}.{js,ts,jsx,tsx}", // 匹配 src 目录下的测试文件
    ];
}
```

**匹配模式解析:**

-   `**/*` : 递归匹配所有目录
-   `{test,spec}` : 文件名包含 test 或 spec
-   `?(c|m)` : 可选的 c (CommonJS) 或 m (ES Module)
-   `[jt]s` : js 或 ts 扩展名
-   `?(x)` : 可选的 x (JSX/TSX)

### exclude - 排除文件

```typescript
test: {
    exclude: [
        "**/node_modules/**", // 默认排除
        "**/.git/**", // 默认排除
        "**/dist/**", // 构建输出
        "**/coverage/**", // 覆盖率报告
        "**/.vscode/**", // 编辑器配置
        "**/*.config.js", // 配置文件
        "**/*.stories.js", // Storybook 文件
        "**/mock-data/**", // 模拟数据
    ];
}
```

### environment - 测试环境

```typescript
test: {
    environment: "jsdom"; // 'node' | 'jsdom' | 'happy-dom'
}
```

**环境对比表:**

| 环境        | 特点          | 适用场景           | DOM API | 性能    | 内存占用 |
| ----------- | ------------- | ------------------ | ------- | ------- | -------- |
| `node`      | Node.js 原生  | 后端逻辑, 工具函数 | ❌      | 🚀 最快 | 🟢 最低  |
| `jsdom`     | 完整 DOM 模拟 | React/Vue 组件     | ✅ 完整 | 🐌 较慢 | 🔴 较高  |
| `happy-dom` | 轻量 DOM 模拟 | 简单前端测试       | ✅ 部分 | ⚡ 快   | 🟡 中等  |

**环境选择建议:**

```typescript
// 纯逻辑测试
environment: "node";

// React/Vue 组件测试
environment: "jsdom";

// 追求速度的前端测试
environment: "happy-dom";
```

### sequence - 执行顺序控制

```typescript
test: {
    // sequence: 控制测试执行的顺序、方式和行为
    // 这个配置对测试性能和可靠性有重要影响
    sequence: {
        // === 并发执行控制 ===
        // concurrent: 是否允许测试用例并发执行
        concurrent: true,
        // true:  多个测试同时运行, 速度更快但可能有副作用冲突
        // false: 测试按顺序逐个执行, 更安全但速度较慢
        //
        // 使用建议:
        // - 独立的单元测试: 推荐 true (提升速度)
        // - 有共享状态的测试: 建议 false (避免冲突)
        // - 数据库操作测试: 建议 false (避免数据竞争)

        // === 随机化执行顺序 ===
        // shuffle: 是否随机打乱测试执行顺序
        // 目的: 发现测试间的隐藏依赖关系
        shuffle: true,  // 简单开启: 随机化所有测试和文件顺序

        // 或者使用对象形式进行细粒度控制:
        shuffle: {
            files: true,    // 随机化测试文件的执行顺序
            tests: false    // 保持单个文件内测试用例的原始顺序
        },
        //
        // 为什么需要随机化?
        // - 好的测试应该相互独立, 不依赖执行顺序
        // - 随机化可以暴露测试间的意外依赖
        // - 帮助发现 "只有在特定顺序下才能通过" 的脆弱测试
        //
        // 使用场景:
        // - 开发阶段: 建议开启, 尽早发现问题
        // - CI/CD: 建议开启, 确保测试稳定性
        // - 调试阶段: 可以关闭, 便于重现问题

        // === 随机种子设置 ===
        // seed: 随机化的种子值, 用于控制 "随机" 的具体行为
        seed: 12345,
        //
        // 作用原理:
        // - 相同的种子 = 相同的 "随机" 顺序
        // - 不同的种子 = 不同的随机顺序
        //
        // 实际用途:
        // - 重现问题: 使用相同种子可以重现特定的测试顺序
        // - 调试失败: 当随机顺序导致测试失败时, 记录种子值便于调试
        // - CI 一致性: 在 CI 环境中使用固定种子确保结果可重现
        //
        // 最佳实践:
        // - 开发时: 可以使用随机种子 (不设置或设为随机值)
        // - 调试时: 使用固定种子重现问题
        // - 生产 CI: 考虑使用基于日期或提交哈希的种子

        // === 钩子函数执行方式 ===
        // hooks: 控制 beforeEach, afterEach 等钩子的执行顺序
        hooks: 'stack',     // 可选值: 'stack' | 'list' | 'parallel'
        //
        // 'stack' (默认, 推荐):
        //   - beforeEach: 按定义顺序执行 (父 → 子)
        //   - afterEach: 按相反顺序执行 (子 → 父)
        //   - 模拟函数调用栈的行为, 符合直觉
        //   - 适合大多数场景
        //
        // 'list':
        //   - 所有钩子都按定义顺序执行
        //   - beforeEach 和 afterEach 都是 父 → 子
        //   - 行为更直观但可能不符合清理逻辑
        //
        // 'parallel':
        //   - 同级钩子并发执行
        //   - 速度最快但可能有副作用
        //   - 只在确保钩子间无依赖时使用
        //
        // 示例场景:
        // describe('父级', () => {
        //   beforeEach(() => console.log('父 setup'))
        //   afterEach(() => console.log('父 cleanup'))
        //
        //   describe('子级', () => {
        //     beforeEach(() => console.log('子 setup'))
        //     afterEach(() => console.log('子 cleanup'))
        //     it('测试', () => {})
        //   })
        // })
        //
        // 'stack' 模式输出: 父setup → 子setup → 子cleanup → 父cleanup
        // 'list' 模式输出:  父setup → 子setup → 父cleanup → 子cleanup

        // === Setup 文件执行方式 ===
        // setupFiles: 控制多个 setup 文件的执行方式
        setupFiles: 'parallel'  // 可选值: 'list' | 'parallel'
        //
        // 'parallel' (推荐):
        //   - 多个 setup 文件同时执行
        //   - 速度更快, 适合独立的初始化任务
        //   - 例如: 全局变量设置、环境配置等
        //
        // 'list':
        //   - setup 文件按顺序逐个执行
        //   - 适合有依赖关系的初始化任务
        //   - 例如: 数据库连接 → 数据初始化 → 权限设置
        //
        // 配置示例:
        // setupFiles: [
        //   './test/setup/globals.js',     // 设置全局变量
        //   './test/setup/database.js',   // 数据库初始化
        //   './test/setup/mocks.js'       // Mock 设置
        // ]
    }
}
```

**并发执行对比:**

```typescript
// concurrent: false (串行)
// test1 → test2 → test3
// 时间: 100ms + 200ms + 150ms = 450ms

// concurrent: true (并行)
// test1 || test2 || test3
// 时间: max(100ms, 200ms, 150ms) = 200ms
```

### coverage - 覆盖率配置

```typescript
test: {
    coverage: {
        // 覆盖率提供者
        provider: 'v8',  // 'v8' | 'istanbul' | 'custom'

        // 启用覆盖率
        enabled: true,

        // 报告输出目录
        reportsDirectory: './coverage',

        // 报告格式
        reporter: [
            'text',      // 控制台输出
            'html',      // HTML 报告
            'json',      // JSON 数据
            'lcov',      // LCOV 格式
            'clover'     // Clover XML
        ],

        // 包含文件
        include: ['src/**/*.{js,ts,jsx,tsx}'],

        // 排除文件
        exclude: [
            '**/*.d.ts',
            '**/*.config.*',
            '**/*.stories.*',
            '**/test/**',
            '**/tests/**'
        ],

        // 覆盖率阈值
        thresholds: {
            lines: 80,        // 行覆盖率
            functions: 75,    // 函数覆盖率
            branches: 70,     // 分支覆盖率
            statements: 80,   // 语句覆盖率
            perFile: true     // 每个文件都要达到阈值
        },

        // 其他选项
        clean: true,              // 运行前清理
        cleanOnRerun: true,       // 重运行时清理
        skipFull: false,          // 不跳过 100% 覆盖的文件
        reportOnFailure: true,    // 失败时也生成报告
        allowExternal: false      // 不收集外部文件覆盖率
    }
}
```

**Provider 对比:**

```typescript
// v8 - 推荐 (基于 Chrome V8)
provider: "v8";
// ✅ 速度快, 内存占用低
// ✅ 原生支持 ES 模块
// ❌ 某些边缘情况可能不准确

// istanbul - 传统方案
provider: "istanbul";
// ✅ 成熟稳定, 准确度高
// ✅ 丰富的配置选项
// ❌ 速度较慢, 内存占用高
```

## 高级配置

### 多项目配置

```typescript
export default defineConfig({
    test: {
        projects: [
            // glob 模式匹配
            "packages/*",

            // 内联配置
            {
                test: {
                    name: "frontend",
                    include: ["src/components/**/*.test.{js,jsx}"],
                    environment: "jsdom",
                    setupFiles: ["./test-setup/frontend.js"],
                },
            },
            {
                test: {
                    name: "backend",
                    include: ["src/api/**/*.test.js"],
                    environment: "node",
                    setupFiles: ["./test-setup/backend.js"],
                },
            },
        ],
    },
});
```

### 浏览器测试配置

```typescript
test: {
    // browser: 浏览器测试配置 - 在真实浏览器环境中运行测试
    // 与 jsdom/happy-dom 不同, 这是在真实浏览器中执行测试
    browser: {
        // === 基础启用配置 ===
        // enabled: 是否启用浏览器测试模式
        enabled: true,
        // true:  测试在真实浏览器中运行
        // false: 使用 Node.js 环境或 DOM 模拟器
        //
        // 浏览器测试的优势:
        // - 100% 真实的浏览器环境
        // - 完整的浏览器 API 支持
        // - 真实的渲染和交互行为
        // - 可以测试浏览器特定功能 (如文件上传、剪贴板等)
        //
        // 浏览器测试的劣势:
        // - 启动速度较慢
        // - 资源占用更多
        // - 需要安装浏览器驱动

        // === 浏览器驱动提供者 ===
        // provider: 选择浏览器自动化工具
        provider: 'playwright',  // 可选值: 'playwright' | 'webdriverio'
        //
        // 'playwright' (推荐):
        //   - 现代化的浏览器自动化工具
        //   - 支持 Chromium, Firefox, Safari
        //   - 速度快, API 简洁
        //   - 内置等待和重试机制
        //   - 更好的调试支持
        //
        // 'webdriverio':
        //   - 基于 W3C WebDriver 标准
        //   - 生态系统成熟
        //   - 支持更多浏览器和移动端
        //   - 插件丰富
        //   - 学习曲线较陡

        // === 浏览器实例配置 ===
        // instances: 定义多个浏览器实例, 可以同时在不同浏览器中测试
        instances: [
            {
                // browser: 指定浏览器类型
                browser: 'chromium',  // 可选: 'chromium' | 'firefox' | 'webkit' | 'chrome' | 'edge'

                // setupFile: 该浏览器实例专用的设置文件
                // 在这个文件中可以配置该浏览器特有的初始化逻辑
                setupFile: './chromium-setup.js'
                // 示例用途:
                // - 设置 Chromium 特定的启动参数
                // - 安装浏览器扩展
                // - 配置特定的 mock 或环境变量
                // - 设置浏览器特定的全局变量
            },
            {
                // 第二个浏览器实例 - Firefox
                browser: 'firefox',

                // headless: 该实例是否以无头模式运行
                // true:  不显示浏览器窗口 (适合 CI 环境)
                // false: 显示浏览器窗口 (适合本地调试)
                headless: true

                // 其他可选配置:
                // setupFile: './firefox-setup.js',  // Firefox 专用设置
                // viewport: { width: 1920, height: 1080 },  // 覆盖全局视口设置
                // launch: {  // 浏览器启动选项
                //     args: ['--disable-web-security'],  // 启动参数
                //     timeout: 30000  // 启动超时
                // }
            }

            // 可以添加更多浏览器实例:
            // {
            //     browser: 'webkit',  // Safari 内核
            //     headless: false,
            //     setupFile: './safari-setup.js'
            // }
        ],

        // === 全局浏览器配置 ===
        // headless: 全局无头模式设置 (可被实例配置覆盖)
        // 这里使用环境变量进行智能配置:
        // - CI 环境: 无头模式 (提升性能, 避免显示问题)
        // - 本地开发: 有头模式 (便于调试和观察)
        headless: process.env.CI,

        // viewport: 浏览器视口大小设置
        // 影响页面的初始渲染尺寸和响应式布局测试
        viewport: {
            width: 1280,   // 视口宽度 (像素)
            height: 720,   // 视口高度 (像素)
        },
        // 常用视口尺寸参考:
        // - 桌面: 1920x1080, 1280x720, 1366x768
        // - 平板: 768x1024, 1024x768
        // - 手机: 375x667, 414x896, 360x640

        // === 截图和调试配置 ===
        // screenshotFailures: 测试失败时是否自动截图
        screenshotFailures: true,
        // true:  失败时自动保存截图, 便于调试
        // false: 不自动截图, 减少存储空间占用
        //
        // 截图的用途:
        // - 快速定位 UI 问题
        // - 在 CI 中查看失败时的页面状态
        // - 记录测试执行时的实际渲染结果
        // - 用于生成测试报告

        // screenshotDirectory: 截图保存目录
        screenshotDirectory: './screenshots'
        // 目录结构通常如下:
        // screenshots/
        // ├── chromium/
        // │   ├── test-name-1.png
        // │   └── test-name-2.png
        // └── firefox/
        //     ├── test-name-1.png
        //     └── test-name-2.png

        // === 其他常用配置选项 ===
        isolate: true,  // 每个测试是否在独立的页面上下文中运行
        slowMo: 100,    // 操作间的延迟时间 (毫秒, 便于观察)
        video: true,    // 是否录制测试视频
        trace: true,    // 是否启用 Playwright 的跟踪功能

        // 高级配置示例:
        api: {
            port: 63315,  // API 服务端口
            host: 'localhost'  // API 服务主机
        },

        // 自定义启动选项:
        launch: {
            devtools: true,  // 打开开发者工具
            timeout: 60000   // 浏览器启动超时
        }
    }
}
```

### 性能优化配置

```typescript
test: {
    // === 线程池配置 ===
    // pool: 选择测试执行的进程/线程模式
    // 这是影响测试性能的最重要配置之一
    pool: 'threads',  // 可选值: 'threads' | 'forks' | 'vmThreads' | 'vmForks'
    //
    // 'threads' (推荐, 默认):
    //   - 使用 Worker Threads 并行执行测试
    //   - 内存共享效率高, 启动速度快
    //   - 适合大多数项目, 性能最佳
    //   - 支持共享内存和 Atomics 优化
    //
    // 'forks':
    //   - 使用子进程 (child_process.fork) 执行测试
    //   - 进程间完全隔离, 更安全但开销大
    //   - 适合有内存泄漏风险的测试
    //   - 启动较慢, 内存占用更多
    //
    // 'vmThreads':
    //   - 在 VM 上下文中使用 Worker Threads
    //   - 提供更好的隔离性, 但性能略低
    //   - 适合需要严格沙箱环境的测试
    //
    // 'vmForks':
    //   - 在 VM 上下文中使用子进程
    //   - 最高隔离性, 但性能开销最大
    //   - 适合安全要求极高的场景

    // === 线程池详细配置 ===
    // poolOptions: 针对选定 pool 类型的详细配置
    poolOptions: {
        // threads 模式的配置选项
        threads: {
            // maxThreads: 最大并发线程数
            // 影响测试的并行度和系统资源占用
            maxThreads: 4,
            // 配置建议:
            // - CPU 密集型测试: CPU 核心数
            // - I/O 密集型测试: CPU 核心数 * 2
            // - 内存受限环境: 适当减少
            // - CI 环境: 通常设为 2-4
            //
            // 动态配置示例:
            // maxThreads: process.env.CI ? 2 : require('os').cpus().length

            // minThreads: 最小保持的线程数
            // 避免频繁创建/销毁线程的开销
            minThreads: 1,
            // 设置原则:
            // - 小项目: 1 (节省资源)
            // - 大项目: 2-3 (保持响应性)
            // - 持续集成: 1-2 (资源有限)

            // useAtomics: 是否使用 Atomics 进行线程间通信
            // 这是一个重要的性能优化选项
            useAtomics: true
            // true (推荐):
            //   - 使用 SharedArrayBuffer 和 Atomics API
            //   - 线程间通信更高效
            //   - 减少序列化/反序列化开销
            //   - 显著提升大型测试套件性能
            //
            // false:
            //   - 使用传统的消息传递机制
            //   - 兼容性更好但性能较低
            //   - 适合不支持 SharedArrayBuffer 的环境
            //
            // 注意事项:
            // - 需要浏览器支持 SharedArrayBuffer
            // - 某些安全策略可能禁用此功能
            // - Node.js 版本需要 >= 16.0.0

            // === 其他线程配置选项 ===
            singleThread: false,  // 是否强制单线程执行
            isolate: true,        // 每个测试文件是否在独立上下文中运行

            // 内存管理:
            maxMemoryLimitBeforeRecycle: 100,  // MB, 线程回收内存阈值

            // 超时配置:
            execArgv: [],  // 传递给 worker 的 Node.js 参数
            env: {},       // worker 环境变量
        }

        // 如果使用 'forks' 模式, 配置示例:
        // forks: {
        //     maxForks: 4,
        //     minForks: 1,
        //     isolate: true,
        //     execArgv: ['--max-old-space-size=4096']  // 增加内存限制
        // }
    },

    // === 文件扫描优化 ===
    // dir: 限制测试文件的扫描目录
    // 通过减少扫描范围来提升启动速度
    dir: './src',
    // 优化效果:
    // - 减少文件系统遍历时间
    // - 避免扫描不必要的目录 (如 node_modules, dist)
    // - 特别适合大型项目或 monorepo
    //
    // 配置建议:
    // - 单一项目: './src' 或 './lib'
    // - Monorepo: './packages/*/src'
    // - 全栈项目: ['./src', './server']
    //
    // 注意事项:
    // - 确保所有测试文件都在指定目录内
    // - 可以配合 include/exclude 进一步精确控制

    // === 缓存配置 ===
    // cache: 测试结果和依赖分析的缓存设置
    // 显著提升重复运行的速度
    cache: {
        // dir: 缓存文件存储目录
        dir: './node_modules/.vitest'
        // 缓存内容包括:
        // - 测试文件的依赖关系图
        // - 模块转换结果 (TypeScript, JSX 等)
        // - 测试结果和覆盖率数据
        // - Mock 和 stub 的元数据
        //
        // 缓存策略:
        // - 基于文件修改时间和内容哈希
        // - 依赖变更时自动失效
        // - 配置变更时自动清理
        //
        // 性能提升:
        // - 首次运行: 建立缓存 (稍慢)
        // - 后续运行: 利用缓存 (显著加速)
        // - 增量测试: 只运行变更相关的测试
        //
        // 缓存管理:
        // - 自动清理过期缓存
        // - 可通过 --no-cache 禁用
        // - 可通过 vitest --run --reporter=verbose --cache.dir=./custom-cache 自定义
    }

    // === 其他性能优化选项 ===
    //
    // 并发控制:
    maxConcurrency: 10,  // 最大并发测试数 (跨文件)

    // 文件监听优化:
    watchExclude: ['**/node_modules/**', '**/dist/**'],

    // 依赖优化:
    deps: {
        external: ['lodash'],  // 外部依赖, 不进行转换
        inline: ['@testing-library/react']  // 内联依赖, 强制转换
    },

    // 转换优化:
    esbuild: {
        target: 'node14'  // 降低转换复杂度
    },

    // 内存优化:
    forceRerunTriggers: ['**/package.json/**'],  // 强制重新运行的触发器

    // 网络优化 (用于浏览器测试):
    testTimeout: 10000,  // 单个测试超时时间
    hookTimeout: 10000   // 钩子函数超时时间
}
```

### 报告器配置

```typescript
test: {
    reporters: [
        'default',               // 默认控制台报告
        'verbose',               // 详细输出
        'json',                  // JSON 格式
        'junit',                 // JUnit XML (CI 友好)
        'html'                   // HTML 报告
    ],

    // 输出文件配置
    outputFile: {
        json: './test-results.json',
        junit: './junit.xml',
        html: './test-report.html'
    }
}
```

## 实际项目配置示例

### React 项目配置

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

export default defineConfig({
    plugins: [react()],
    test: {
        environment: "jsdom",
        setupFiles: ["./src/test/setup.ts"],
        include: ["src/**/*.{test,spec}.{js,jsx,ts,tsx}"],
        exclude: ["**/node_modules/**", "**/dist/**", "**/*.stories.*"],
        coverage: {
            provider: "v8",
            reporter: ["text", "html"],
            include: ["src/**/*.{js,jsx,ts,tsx}"],
            exclude: ["**/*.d.ts", "**/*.stories.*", "**/test/**"],
            thresholds: {
                lines: 80,
                functions: 80,
                branches: 80,
                statements: 80,
            },
        },
    },
});
```

### Vue 项目配置

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
    plugins: [vue()],
    test: {
        environment: "happy-dom", // Vue 推荐使用 happy-dom
        include: ["src/**/*.{test,spec}.{js,ts}", "tests/**/*.{js,ts}"],
        globals: true,
        coverage: {
            provider: "v8",
            include: ["src/**/*.{js,ts,vue}"],
            exclude: ["**/*.d.ts"],
        },
    },
});
```

### Node.js 项目配置

```typescript
// vitest.config.ts
export default defineConfig({
    test: {
        environment: "node",
        include: ["src/**/*.test.js", "tests/**/*.js"],
        sequence: {
            concurrent: true,
        },
        coverage: {
            provider: "v8",
            include: ["src/**/*.js"],
            exclude: ["src/**/*.config.js"],
            thresholds: {
                lines: 90,
                functions: 90,
                branches: 85,
                statements: 90,
            },
        },
    },
});
```

### 全栈项目配置

```typescript
export default defineConfig({
    test: {
        projects: [
            {
                test: {
                    name: "frontend",
                    include: ["src/client/**/*.test.{js,jsx,ts,tsx}"],
                    environment: "jsdom",
                    setupFiles: ["./test/frontend-setup.js"],
                },
            },
            {
                test: {
                    name: "backend",
                    include: ["src/server/**/*.test.{js,ts}"],
                    environment: "node",
                    setupFiles: ["./test/backend-setup.js"],
                },
            },
            {
                test: {
                    name: "e2e",
                    include: ["tests/e2e/**/*.test.js"],
                    browser: {
                        enabled: true,
                        provider: "playwright",
                    },
                },
            },
        ],
    },
});
```

## 配置最佳实践

### 1. 环境变量支持

```typescript
// vitest.config.ts
export default defineConfig({
    test: {
        environment: process.env.NODE_ENV === "production" ? "node" : "jsdom",
        coverage: {
            enabled: process.env.CI === "true",
            thresholds: {
                lines: process.env.CI ? 90 : 70,
            },
        },
    },
});
```

### 2. 条件配置

```typescript
export default defineConfig(({ mode }) => ({
    test: {
        ...(mode === "development" && {
            sequence: { concurrent: false }, // 开发时串行执行便于调试
            reporter: "verbose",
        }),

        ...(mode === "ci" && {
            coverage: { enabled: true },
            reporter: ["default", "junit"],
        }),
    },
}));
```

### 3. 配置复用

```typescript
// test.config.base.ts
export const baseConfig = {
    include: ["**/*.{test,spec}.{js,ts,jsx,tsx}"],
    exclude: ["**/node_modules/**", "**/dist/**"],
    coverage: {
        provider: "v8",
        reporter: ["text", "html"],
    },
};

// vitest.config.ts
import { baseConfig } from "./test.config.base";

export default defineConfig({
    test: {
        ...baseConfig,
        environment: "jsdom", // 项目特定配置
    },
});
```

## 总结

Vitest 的配置系统非常灵活, 关键要点:

1. **文件匹配**: 使用 `include/exclude` 精确控制测试范围
2. **环境选择**: 根据测试内容选择合适的执行环境
3. **性能优化**: 合理配置并发和线程池提升速度
4. **覆盖率**: 设置合理的阈值和报告格式
5. **多项目**: 使用 projects 配置支持复杂项目结构

建议从简单配置开始, 根据项目需求逐步添加高级功能.
