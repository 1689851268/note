# Vitest 入门指南

## 简介

**Vitest** 是一个由 Vite 驱动的下一代前端测试框架. 它专为现代前端项目设计, 提供了极快的测试体验.

### 核心特点

-   🚀 **极速启动**: 基于 Vite 构建系统, 接近原生 ESM 性能
-   📦 **开箱即用**: 内置 TypeScript 支持, 零配置启动
-   🔄 **Jest 兼容**: 支持 Jest API, 迁移成本极低
-   🌐 **现代化**: 原生支持 ES 模块和最新 JavaScript 特性
-   🎯 **智能监听**: 只重新运行相关测试, 提升开发效率

## 快速开始

### 1. 安装

```bash
# npm
npm install -D vitest

# yarn
yarn add -D vitest

# pnpm
pnpm add -D vitest
```

### 2. 配置 package.json

```json
{
    "scripts": {
        "test": "vitest",
        "test:run": "vitest run",
        "coverage": "vitest run --coverage"
    }
}
```

### 3. 编写第一个测试

创建 `src/utils.js`:

```javascript
export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}
```

创建 `src/utils.test.js`:

```javascript
// 从 vitest 导入测试相关的函数
// describe: 用于创建测试套件 (一组相关测试的集合)
// it: 用于定义单个测试用例
// expect: 用于创建断言 (验证结果是否符合预期)
import { describe, it, expect } from "vitest";

// 导入要测试的函数
import { add, multiply } from "./utils.js";

// describe() 创建一个测试套件, 第一个参数是描述性名称
describe("数学工具函数", () => {
    // it() 定义一个具体的测试用例
    // 第一个参数是测试用例的描述, 应该清楚说明测试的内容
    it("应该正确相加两个数字", () => {
        // expect() 创建一个断言, 传入要测试的实际值
        // toBe() 是匹配器, 用于严格相等比较 (===)
        expect(add(2, 3)).toBe(5); // 验证 2 + 3 = 5
        expect(add(-1, 1)).toBe(0); // 验证 -1 + 1 = 0
    });

    // 另一个测试用例, 测试乘法函数
    it("应该正确相乘两个数字", () => {
        expect(multiply(3, 4)).toBe(12); // 验证 3 * 4 = 12
        expect(multiply(0, 5)).toBe(0); // 验证 0 * 5 = 0
    });
});
```

### 4. 运行测试

```bash
# 监听模式 (推荐开发时使用)
npm run test

# 单次运行
npm run test:run

# 生成覆盖率报告
npm run coverage
```

## 基础 API

### 测试结构

```javascript
// 导入 Vitest 提供的测试函数
import { describe, it, expect, beforeEach, afterEach } from "vitest";

// describe() 创建测试套件 - 用于组织相关的测试用例
describe("测试套件名称", () => {
    // beforeEach() 在每个测试用例运行前执行
    // 通常用于设置测试数据或初始化状态
    beforeEach(() => {
        // 每个测试前执行的代码
        // 例如: 重置变量, 清理数据库, 设置 mock 等
    });

    // afterEach() 在每个测试用例运行后执行
    // 通常用于清理资源或重置状态
    afterEach(() => {
        // 每个测试后执行的代码
        // 例如: 清理文件, 关闭连接, 重置 mock 等
    });

    // it() 定义单个测试用例
    // 第一个参数: 测试用例的描述 (应该说明测试的具体行为)
    // 第二个参数: 包含测试逻辑的函数
    it("测试用例描述", () => {
        // 测试逻辑代码
        // expect() 创建断言, 验证实际结果是否符合预期
        expect(实际值).toBe(期望值);
    });
});
```

### 常用断言

```javascript
// === 基本断言 ===
// toBe() 用于严格相等比较 (使用 === 操作符)
expect(value).toBe(4); // 检查 value 是否严格等于 4

// toEqual() 用于深度相等比较 (比较对象内容)
expect(value).toEqual({ a: 1 }); // 检查对象内容是否相等

// toBeTruthy() 检查值转为 boolean 后是否为 true
expect(value).toBeTruthy(); // 等同于 expect(!!value).toBe(true)

// toBeFalsy() 检查值转为 boolean 后是否为 false
expect(value).toBeFalsy(); // 等同于 expect(!!value).toBe(false)

// toBeNull() 检查值是否为 null
expect(value).toBeNull(); // 等同于 expect(value).toBe(null)

// toBeUndefined() 检查值是否为 undefined
expect(value).toBeUndefined(); // 等同于 expect(value).toBe(undefined)

// === 数字断言 ===
// toBeGreaterThan() 检查数字是否大于指定值
expect(value).toBeGreaterThan(3); // 检查 value > 3

// toBeLessThan() 检查数字是否小于指定值
expect(value).toBeLessThan(5); // 检查 value < 5

// toBeCloseTo() 用于浮点数近似相等比较 (避免精度问题)
expect(0.1 + 0.2).toBeCloseTo(0.3); // 浮点数计算结果近似等于 0.3

// === 字符串断言 ===
// toContain() 检查字符串是否包含子串
expect("hello world").toContain("world"); // 检查是否包含 "world"

// toMatch() 检查字符串是否匹配正则表达式
expect("hello").toMatch(/ell/); // 检查是否匹配正则 /ell/

// === 数组断言 ===
// toContain() 检查数组是否包含指定元素
expect(["a", "b", "c"]).toContain("b"); // 检查数组是否包含 "b"

// toHaveLength() 检查数组长度
expect([1, 2, 3]).toHaveLength(3); // 检查数组长度是否为 3

// === 异常断言 ===
// toThrow() 检查函数是否抛出异常
expect(() => {
    throw new Error("错误"); // 这个函数会抛出错误
}).toThrow("错误"); // 检查是否抛出包含 "错误" 的异常
```

## 配置文件

### 基础配置

创建 `vitest.config.js`:

```javascript
// 从 vitest/config 导入配置函数
import { defineConfig } from "vitest/config";

// defineConfig() 用于创建 Vitest 配置, 提供类型提示和验证
export default defineConfig({
    // test 属性包含所有 Vitest 相关配置
    test: {
        // include: 指定哪些文件会被当作测试文件
        // 使用 glob 模式匹配文件路径
        include: ["**/*.{test,spec}.{js,ts,jsx,tsx}"],

        // exclude: 指定哪些文件/目录要排除在测试之外
        exclude: ["**/node_modules/**", "**/dist/**"],

        // environment: 指定测试运行的环境
        // 'node': Node.js 环境 (无 DOM)
        // 'jsdom': 模拟浏览器环境 (有 DOM API)
        // 'happy-dom': 轻量级浏览器环境模拟
        environment: "jsdom",

        // globals: 是否将测试 API 注册为全局变量
        // true: 可以直接使用 describe, it, expect 而无需导入
        // false: 需要手动导入这些函数
        globals: true,

        // sequence: 控制测试执行顺序和方式
        sequence: {
            // concurrent: 是否并发执行测试
            // true: 测试并行运行 (更快但可能有副作用)
            // false: 测试串行运行 (更安全但较慢)
            concurrent: true,
        },
    },
});
```

### 与 Vite 项目集成

如果已有 `vite.config.js`:

```javascript
// 这行注释告诉 TypeScript 编译器包含 Vitest 的类型定义
// 这样在 test 配置中就能获得代码提示和类型检查
/// <reference types="vitest/config" />

// 从 vite 导入配置函数 (注意不是从 vitest/config)
import { defineConfig } from "vite";

// 使用 Vite 的 defineConfig 创建配置
export default defineConfig({
    // Vite 相关配置 (构建、插件等)
    plugins: [
        /* Vite 插件配置 */
    ],

    // Vitest 配置 - 直接添加到 Vite 配置中
    // 这样 Vitest 可以复用 Vite 的配置 (如插件、别名等)
    test: {
        // 测试环境设置
        environment: "jsdom",
        // 全局变量设置
        globals: true,
    },
});
```

## 测试环境对比

| 环境        | 适用场景           | DOM API | 浏览器 API | 性能    | 兼容性  | 稳定性    |
| ----------- | ------------------ | ------- | ---------- | ------- | ------- | --------- |
| `node`      | 工具函数, 后端逻辑 | ❌      | ❌         | 🚀 最快 | ✅ 完美 | ✅ 最稳定 |
| `jsdom`     | React/Vue 组件测试 | ✅ 完整 | 🟡 较多    | 🐌 较慢 | ✅ 成熟 | ✅ 稳定   |
| `happy-dom` | 简单前端测试       | 🟡 部分 | 🔴 较少    | ⚡ 快   | ⚠️ 新兴 | ⚠️ 发展中 |

### 详细对比说明

**Node 环境:**

-   ✅ 优势: 最快速度, 最稳定, 无额外依赖
-   ❌ 劣势: 无 DOM API, 不能测试浏览器相关功能

**jsdom 环境:**

-   ✅ 优势: DOM API 最完整, 生态成熟, 兼容性好, 大量项目验证
-   ❌ 劣势: 启动较慢, 内存占用高, 某些浏览器 API 仍不支持

**happy-dom 环境:**

-   ✅ 优势: 速度快, 内存占用低, 现代化设计
-   ❌ 劣势: DOM API 不完整, 浏览器 API 支持有限, 生态较新, 可能有未知 bug, 复杂组件测试可能出现兼容性问题

## 实际项目示例

### React 组件测试

```javascript
// Button.jsx
export function Button({ children, onClick, disabled }) {
    return (
        <button onClick={onClick} disabled={disabled}>
            {children}
        </button>
    );
}

// Button.test.jsx - React 组件测试文件
// 从 @testing-library/react 导入 React 测试工具
// render: 将 React 组件渲染到虚拟 DOM 中
// fireEvent: 模拟用户交互事件 (点击、输入等)
// screen: 提供查询渲染结果的方法
import { render, fireEvent, screen } from "@testing-library/react";

// 从 vitest 导入测试相关函数
// describe, it, expect: 基础测试 API
// vi: Vitest 的 mock 工具 (类似 Jest 的 jest)
import { describe, it, expect, vi } from "vitest";

// 导入要测试的 Button 组件
import { Button } from "./Button";

// 创建 Button 组件的测试套件
describe("Button 组件", () => {
    // 测试用例 1: 验证组件能正确渲染文本内容
    it("应该渲染正确的文本", () => {
        // render() 将 Button 组件渲染到测试环境的虚拟 DOM 中
        // 传入 "点击我" 作为 children prop
        render(<Button>点击我</Button>);

        // screen.getByText() 在渲染结果中查找包含指定文本的元素
        // toBeInTheDocument() 验证元素确实存在于 DOM 中
        // 这个断言来自 @testing-library/jest-dom 扩展
        expect(screen.getByText("点击我")).toBeInTheDocument();
    });

    // 测试用例 2: 验证组件能正确响应点击事件
    it("应该响应点击事件", () => {
        // vi.fn() 创建一个 mock 函数
        // 可以追踪这个函数是否被调用、调用次数、调用参数等
        const handleClick = vi.fn();

        // 渲染 Button 组件, 传入 mock 函数作为 onClick 处理器
        render(<Button onClick={handleClick}>点击</Button>);

        // fireEvent.click() 模拟用户点击操作
        // 先用 screen.getByText() 找到按钮元素, 然后触发点击事件
        fireEvent.click(screen.getByText("点击"));

        // toHaveBeenCalledTimes() 验证 mock 函数被调用的次数
        // 确认点击事件处理器被调用了 1 次
        expect(handleClick).toHaveBeenCalledTimes(1);
    });

    // 测试用例 3: 验证禁用状态下组件不响应点击
    it("禁用状态下不应响应点击", () => {
        // 创建 mock 点击处理器
        const handleClick = vi.fn();

        // 渲染禁用状态的 Button 组件
        // disabled prop 设置为 true
        render(
            <Button onClick={handleClick} disabled>
                禁用
            </Button>
        );

        // 尝试点击禁用的按钮
        fireEvent.click(screen.getByText("禁用"));

        // not.toHaveBeenCalled() 验证 mock 函数没有被调用
        // 确认禁用状态下点击事件不会被触发
        expect(handleClick).not.toHaveBeenCalled();
    });
});
```

### 异步测试

```javascript
// api.js - 要测试的异步 API 函数
// 这是一个异步函数, 使用 fetch 获取用户数据
export async function fetchUser(id) {
    // 发起 HTTP 请求到指定的用户 API 端点
    const response = await fetch(`/api/users/${id}`);
    // 将响应转换为 JSON 格式并返回
    return response.json();
}

// api.test.js - 异步函数的测试文件
// 导入测试所需的 Vitest 函数
import { describe, it, expect, vi } from "vitest";
// 导入要测试的异步函数
import { fetchUser } from "./api";

// === Mock 全局 fetch 函数 ===
// 将浏览器的 fetch API 替换为 mock 函数
// 这样可以控制网络请求的行为, 避免真实的网络调用
global.fetch = vi.fn();

// 创建 API 函数的测试套件
describe("API 函数", () => {
    // 测试异步函数的成功情况
    // 注意: 测试函数标记为 async, 因为要测试异步行为
    it("应该正确获取用户数据", async () => {
        // 准备模拟的用户数据
        const mockUser = { id: 1, name: "John" };

        // mockResolvedValueOnce() 让 fetch 在下一次调用时返回成功的 Promise
        // 模拟 fetch 返回一个包含 json() 方法的响应对象
        fetch.mockResolvedValueOnce({
            // json() 方法返回一个 Promise, 解析为我们的模拟数据
            json: () => Promise.resolve(mockUser),
        });

        // 调用被测试的异步函数
        // await 等待 Promise 完成并获取结果
        const user = await fetchUser(1);

        // 验证 fetch 被正确调用
        // toHaveBeenCalledWith() 检查函数被调用时的参数
        expect(fetch).toHaveBeenCalledWith("/api/users/1");

        // 验证函数返回了正确的用户数据
        expect(user).toEqual(mockUser);
    });
});
```

## 覆盖率配置

```javascript
// 覆盖率配置 - 用于衡量测试对代码的覆盖程度
export default defineConfig({
    test: {
        // coverage: 代码覆盖率相关配置
        coverage: {
            // provider: 选择覆盖率收集工具
            // 'v8': 基于 Chrome V8 引擎, 速度快, 推荐使用
            // 'istanbul': 传统工具, 功能完整但较慢
            provider: "v8",

            // reporter: 覆盖率报告的输出格式
            // 'text': 在控制台显示覆盖率摘要
            // 'html': 生成详细的 HTML 报告 (可在浏览器中查看)
            // 'json': 生成 JSON 格式数据 (供其他工具使用)
            reporter: ["text", "html", "json"],

            // reportsDirectory: 覆盖率报告的输出目录
            // 所有报告文件都会保存在这个目录下
            reportsDirectory: "./coverage",

            // include: 指定哪些文件需要计算覆盖率
            // 只有这些文件会被包含在覆盖率统计中
            include: ["src/**/*.{js,ts,jsx,tsx}"],

            // exclude: 从覆盖率统计中排除的文件
            // 这些文件不会影响覆盖率百分比
            exclude: [
                "**/*.d.ts", // TypeScript 类型定义文件
                "**/*.config.*", // 各种配置文件
                "**/*.stories.*", // Storybook 故事文件
                "**/test/**", // 测试文件本身
            ],

            // thresholds: 覆盖率阈值设置
            // 如果覆盖率低于这些值, 测试会失败
            thresholds: {
                lines: 80, // 行覆盖率至少 80%
                functions: 80, // 函数覆盖率至少 80%
                branches: 80, // 分支覆盖率至少 80%
                statements: 80, // 语句覆盖率至少 80%
            },
        },
    },
});
```

## 常用命令

```bash
# 基础命令
vitest                    # 监听模式
vitest run               # 单次运行
vitest --coverage        # 生成覆盖率

# 过滤测试
vitest button            # 运行文件名包含 "button" 的测试
vitest --grep "用户"     # 运行描述包含 "用户" 的测试

# 调试模式
vitest --inspect-brk     # 启用 Node.js 调试器
vitest --reporter=verbose # 详细输出

# 并发控制
vitest --threads=false   # 禁用多线程
vitest --sequence.concurrent=false # 禁用并发
```

## 最佳实践

### 1. 测试文件组织

```
src/
    components/
        Button/
            Button.jsx
            Button.test.jsx     # 与源码同目录
    utils/
        math.js
        math.test.js
tests/                  # 或单独测试目录
    integration/
    e2e/
```

### 2. 描述性测试名称

```javascript
// ❌ 不好的命名
it("test 1", () => {});

// ✅ 好的命名
it("应该在输入无效邮箱时显示错误信息", () => {});
```

### 3. 测试结构 (AAA 模式)

```javascript
it("应该计算正确的总价", () => {
    // Arrange (准备)
    const items = [{ price: 10 }, { price: 20 }];

    // Act (执行)
    const total = calculateTotal(items);

    // Assert (断言)
    expect(total).toBe(30);
});
```

### 4. Mock 的使用

```javascript
// === 模拟整个模块 ===
// vi.mock() 是 Vitest 提供的模块模拟功能
// 第一个参数: 要模拟的模块路径 (相对路径或 npm 包名)
// 第二个参数: 工厂函数, 返回模拟的模块导出
vi.mock("./api", () => ({
    // fetchData: 创建一个模拟函数来替代真实的 fetchData 函数
    // vi.fn() 创建一个可追踪的 mock 函数
    // () => Promise.resolve() 定义 mock 函数的默认返回值
    // 这里模拟 fetchData 总是返回成功的 Promise, 包含 { data: "test" }
    fetchData: vi.fn(() => Promise.resolve({ data: "test" })),
}));
// 使用场景: 当你想要控制外部依赖的行为时
// 比如测试时不想真的发起网络请求, 就可以 mock API 模块

// === 模拟时间相关功能 ===
// vi.useFakeTimers() 启用虚拟时间控制
// 这会拦截所有时间相关的 JavaScript API:
// - setTimeout, setInterval, clearTimeout, clearInterval
// - Date 构造函数和 Date.now()
// - process.nextTick (Node.js 环境)
vi.useFakeTimers();

// vi.setSystemTime() 设置虚拟的系统时间
// 参数: Date 对象, 表示要设置的固定时间点
// 之后所有的 new Date() 调用都会返回这个固定时间
// 这对于测试时间相关的逻辑非常有用 (比如日期格式化、过期检查等)
vi.setSystemTime(new Date("2024-01-01"));
// 使用场景: 测试依赖当前时间的功能, 确保测试结果的一致性

// === 模拟浏览器 DOM API ===
// Object.defineProperty() 用于重新定义对象的属性
// 这里模拟浏览器的 window.location 对象
Object.defineProperty(window, "location", {
    // value: 新的属性值, 这里是一个模拟的 location 对象
    value: {
        href: "http://localhost", // 模拟当前页面的完整 URL
        // 你还可以添加其他 location 属性:
        // pathname: "/test",      // URL 路径部分
        // search: "?id=123",      // 查询参数部分
        // hash: "#section1"       // 锚点部分
    },
    // writable: true 允许后续在测试中修改这个属性
    writable: true,
    // configurable: true 允许重新定义这个属性
    configurable: true,
});
// 使用场景: 测试依赖 URL 或页面位置的功能
// 比如根据 URL 参数显示不同内容, 或者页面跳转逻辑

// === 其他常用的 Mock 示例 ===
// Mock localStorage
const localStorageMock = {
    getItem: vi.fn(), // 模拟获取存储项
    setItem: vi.fn(), // 模拟设置存储项
    removeItem: vi.fn(), // 模拟删除存储项
    clear: vi.fn(), // 模拟清空存储
};
Object.defineProperty(window, "localStorage", {
    value: localStorageMock,
});

// Mock console (避免测试时输出日志)
global.console = {
    log: vi.fn(), // 模拟 console.log
    error: vi.fn(), // 模拟 console.error
    warn: vi.fn(), // 模拟 console.warn
};

// Mock 环境变量
vi.mock("process", () => ({
    env: {
        NODE_ENV: "test", // 模拟测试环境
        API_URL: "http://test-api.com",
    },
}));
```

## 总结

Vitest 为现代前端项目提供了优秀的测试体验:

-   **快速**: Vite 驱动的极速启动和热重载
-   **简单**: 类似 Jest 的 API, 学习成本低
-   **现代**: 原生 ESM 和 TypeScript 支持
-   **灵活**: 支持多种测试环境和配置

建议从简单的单元测试开始, 逐步探索 Vitest 的高级功能, 为你的项目构建可靠的测试体系.
