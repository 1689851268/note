# 内存分配

## 栈 stack

-   stack 主要用于存储局部变量和函数调用，占用的空间小且存储地址连续，操作起来简单方便。
-   一般由系统自动分配、自动回收。
-   基本类型数据 (Number、Boolean、String、Null、Undefined、Symbol) 都保存在 stack 内存中；<br>
    引用类型数据存储在 heap 内存中，引用类型数据会将 [一个指向堆内存中实际对象的引用] 存储在 stack 内存中。

<br>

为什么基本类型数据存储在 stack 内存中，而引用类型数据存储在 heap 内存中？

答：JS 引擎需要用 stack 来维护程序执行期上下文的状态，如果 stack 占用的空间过大，会影响上下文切换的效率，进而影响整个程序的执行效率。

<br>

## 堆 heap

-   heap 用于存储对象等动态数据，是内存中最大的区域。
-   heap 是 GC (Garbage Collection 垃圾回收) 工作的地方。但并不是所有的 heap 内存都可以进行 GC，只有 [新生代] & [老生代] 可以进行 GC。
    1. 新生代空间：是最新产生的数据存活的地方，这些数据往往都是短暂的。<br>
       该空间被 Scavenger (Minor GC) 管理。
    2. 老生代空间：是从新生代空间经过至少两轮 Minor GC 仍然存活下来的数据。<br>
       该空间被 Mark-Sweep & Mark-Compact (Major GC) 管理。

<br><br>

# 代际假说

1. 在 V8 中会把堆分为 [新生代] 和 [老生代] 两个区域：<br>
   新生代中存放的是生存时间短的对象；老生代中存放的生存时间长的对象。
2. 新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多。
3. 对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：
    1. 副垃圾回收器，主要负责新生代的垃圾回收。
    2. 主垃圾回收器，主要负责老生代的垃圾回收。

<br><br>

# 新生代回收

新生代中用 Scavenge 算法进行处理：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

<br>

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作：

1. 先标记需要回收的对象，然后把对象区激活(标记)对象复制到空闲区，并排序。
2. 完成复制后，对象区域与空闲区域进行角色翻转。即原来的对象区域变成空闲区域，原来的空闲区域变成对象区域。
3. 然后把空闲区中的非活动对象清除。

<br>

新生代中采用的 Scavenge 算法在每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。<br>
复制操作需要时间成本，如果新生区空间设置得太大，每次清理的时间就会过久；为了执行效率，一般新生区的空间会被设置得比较小。

正是因为新生区的空间不大，所以很容易被存活的对象装满。
为了解决这个问题，JS 引擎采用了 [对象晋升策略]：经过两次垃圾回收依然存活的对象，会被移动到老生区。

<br><br>

# 老生代回收

## Mark-Sweep

Mark-Sweep 处理时分为 2 个阶段：标记阶段、清理阶段：

1.  标记阶段：对老生代进行第一次扫描，标记活动对象。
2.  清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象。

看起来与 Scavenge 类似，不同的是，Scavenge 算法是复制活动对象，而由于在老生代中活动对象占大多数，所以 Mark-Sweep 在标记了活动对象和非活动对象之后，直接把非活动对象清除

<br>

## Mark-Compact

由于 Mark-Sweep 完成后，老生代的内存中会产生很多内存碎片。若不清理这些内存碎片，如果出现需要分配一个大对象的情况，而这时所有的碎片空间都无法完成分配，就会提前触发垃圾回收，而这次回收其实不是必要的。

为了解决内存碎片问题，Mark-Compact 被提出，它是在 Mark-Sweep 的基础上添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。

<br><br>

# 全停顿 Stop-The-World

如果垃圾回收十分耗费时间，主线程的 JS 操作就要停下来等待垃圾回收完成，我们把这种行为叫做 **全停顿 (Stop-The-World)**。

<br>

## 增量标记

为了降低老生代的垃圾回收造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记 (Incremental Marking) 算法。

<br>

## 惰性清理

增量标记只是对活动对象和非活动对象进行标记，惰性清理用来真正的清理释放内存。

当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，先执行 JS 代码；而且，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕。

<br>

## 并发回收

并发式 GC 允许在垃圾回收的同时指定 JS 代码。只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。

但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于 JS 代码在执行，堆中的对象的引用关系随时可能变化，所以也要进行写屏障操作。

<br>

## 并行回收

并行式 GC 允许主线程和辅助线程一起执行 GC 工作，这样可以让辅助线程来分担主线程的 GC 工作。
使得垃圾回收所耗费的时间 = 总时间 / 参与的线程数量（加上一些同步开销）

<br><br>

# 内存管理

优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 `null`，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用。

如下面的例子所示：

```js
function createPerson(name) {
    let localPerson = new Object();
    localPerson.name = name;
    return localPerson;
}
let globalPerson = createPerson('Nicholas');

// 解除 globalPerson 对值的引用
globalPerson = null;
```

在上面的代码中，`localPerson` 在 createPerson 执行完成超出上下文后会自动被解除引用，不需要显式处理。但 `globalPerson` 是一个全局变量，应该在不再需要时手动解除其引用。

不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。

<br>
