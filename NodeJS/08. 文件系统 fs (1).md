# 文件系统 fs

-   fs (File System) 属于 NodeJS 的核心模块，用于操作文件(夹)
-   使用 fs，需要先引入该模块

```js
const fs = require('fs');
```

<br>

**路径问题**：

-   使用相对路径时，是相对项目根目录而言的。就是说，在项目根目录不同的情况下，文件执行的结果会不一样
-   开发中，尽量使用 `__dirname` 拼接路径

<br><br>

# 操作文件

## writeFile[Sync]

-   **`fs.writeFile(path, data[, options], callBack)`**
-   **`fs.writeFileSync(path, data[, options])`**

用于向指定文件写入数据。如果该文件不存在，能自动创建。

1. `path`：文件的路径
2. `data`：要写入的数据
3. `option`：配置对象
    - `encoding`：编码格式，默认为 `utf8`
    - `flag`：文件系统标志，默认为 `'w'` - 写入数据（覆盖旧数据）；改为 `'a'` - 追加数据
4. `callBack`：回调函数，写入完成后调用；接收 1 个参数 `err`：出错时表示出错的信息，默认为 `null`

```js
const fs = require('fs');
const data = '新写入的数据';

// 同步写入数据
fs.writeFileSync('./writeFileSync.txt', data);

// 异步写入数据
fs.writeFile(
    './writeFile.txt',
    data,
    (err) => console.log('err', err) // err null
);
```

如果写入的文件中原来就有内容，原来的内容会被覆盖；如果想追加数据，可以设置 `flag: 'a'`：

```js
const fs = require('fs');
const data = '追加的内容';

// 同步追加数据
fs.writeFileSync(
    './writeFileSync.txt',
    data,
    { flag: 'a' } // 设置 flag 为 a
);

// 异步追加数据
fs.writeFile(
    './writeFile.txt',
    data,
    { flag: 'a' }, // 设置 flag 为 a
    (err) => console.log('err', err)
);
```

<br>

## appendFile[Sync]

-   **`fs.appendFile(path, data[, options], callback)`**
-   **`fs.appendFileSync(path, data[, options]`**

用于向指定文件追加数据。如果该文件不存在，能自动创建。

1. `path`：文件的路径
2. `data`：写入的数据
3. `options`：配置对象
    - `encoding`：默认为 `'utf8'`
    - `flag`：默认值为 `'a'`
4. `callback`：回调函数，追加完成后调用；接收 1 个参数 `err`：出错时表示出错的信息，默认为 `null`

```js
const fs = require('fs');
const data = '追加的内容';

// 同步追加数据
fs.appendFileSync('./appendFileSync.txt', data);

// 异步追加数据
fs.appendFile(
    './appendFile.txt',
    data,
    (err) => console.log('err', err) // err null
);
```

<br>

## readFile[Sync]

-   **`fs.readFile(path[, options], callback)`**
-   **`fs.readFileSync(path[, options])`**

用于读取指定文件的内容。

1. `path`：文件的路径
2. `options`：配置对象
    - `encoding`：数据的编码格式，默认为 `null`；如果只设置 `encoding` 可以直接写成 String 格式
    - `flag`：文件系统标志，默认为 `'r'`
3. `callback`：回调函数，接收 2 个参数：① 出错信息 `err`，默认为 `null`、② 读取的数据 `data`

```js
const fs = require('fs');

// 同步读取数据
const data = fs.readFileSync('./writeFileSync.txt');
console.log('syncData', data); // <Buffer e6 96 b0...>
console.log("syncData + ''", data + ''); // 新写入的数据

// 异步读取数据
fs.readFile('./writeFile.txt', (err, data) => {
    if (err) return console.log('err', err);
    console.log('data', data); // <Buffer e6 96 b0...>
    console.log("data + ''", data + ''); // 新写入的数据
});
```

-   读取出来的数据默认是 Buffer 格式的，可以将其转成字符串形式
-   读取成功 - `err` 为 `null`、`data` 为文件内容；读取失败 - `err` 为错误信息，`data` 为 `undefined`

<br>

## unlink[Sync]

-   **`fs.unlink(path, callback)`**
-   **`fs.unlinkSync(path)`**

用于删除指定文件。

-   `path`：文件的路径
-   `callBack`：接收 1 个参数 `err`：出错时表示出错的信息，默认为 `null`

```js
const fs = require('fs');

// 同步删除文件
fs.unlinkSync('./writeFileSync.txt');

// 异步删除文件
fs.unlink(
    './writeFile.txt',
    (err) => console.log('err', err) // err null
);
```

<br><br>

# 操作目录

## mkdir[Sync]

-   **`fs.mkdir(path[, options], callback)`**
-   **`fs.mkdirSync(path[, options])`**

用于创建目录。

1. `path`：新建的文件夹的路径
2. `options`：配置对象
    - `recursive`：是否可以递归创建，默认为 `false`
3. `callback`：回调函数，接收 1 个参数 `err`，默认为 `null`

```js
const fs = require('fs');

// 同步创建文件夹
fs.mkdirSync('./mkdirSync');

// 异步创建文件夹
fs.mkdir(
    './mkdir',
    (err) => console.log('err', err) // err null
);
```

通过配置 `option` 可以实现递归创建文件夹

```js
const fs = require('fs');

// 同步创建递归文件夹
fs.mkdirSync('./reMkdirSync/mkdirSync', { recursive: true });

// 异步创建递归文件夹
fs.mkdir(
    './reMkdir/mkdir',
    { recursive: true },
    (err) => console.log('err', err) // err null
);
```

<br>

## readdir[Sync]

-   **`fs.readdir(path[, options], callback)`**
-   **`fs.readdirSync(path[, options])`**

用于获取目录的内容。

1. `path`：文件夹的路径
2. `options`：配置对象
    - `encoding`：默认为 `'utf8'`、可设置为 `'buffer'`
    - `withFileTypes`：是否显现文件类型，默认为 `false`
3. `callback`：回调函数，接收 2 个参数 `err`、`files` - 目录的内容

```js
const fs = require('fs');

// 同步获取目录信息
const syncFiles = fs.readdirSync('./reMkdirSync');
console.log('syncFiles', syncFiles); // syncFiles [ 'mkdirSync' ]

// 异步获取目录信息
fs.readdir(
    './reMkdir',
    (err, files) => console.log('files', files) // files [ 'mkdir' ]
);
```

可以通过配置 `option` 显示文件的类型

```js
const fs = require('fs');

// 同步获取目录信息
const syncFiles = fs.readdirSync('./reMkdirSync', { withFileTypes: true });
console.log('syncFiles', syncFiles); // syncFiles [ Dirent { name: 'mkdirSync', [Symbol(type)]: 2 } ]

// 异步获取目录信息
fs.readdir(
    './reMkdir',
    { withFileTypes: true },
    (err, files) => console.log('files', files) // files [ Dirent { name: 'mkdir', [Symbol(type)]: 2 } ]
);
```

<br>

## rmdir[Sync]

-   **`fs.rmdir(path, callback)`**
-   **`fs.rmdirSync(path)`**

用于删除目录。

1. `path`：文件夹的路径
2. `callback`：回调函数，接收 1 个错误信息的参数 `err`，默认为 `null`

```js
const fs = require('fs');

// 同步删除目录
fs.rmdirSync('./mkdirSync');

// 异步删除目录
fs.rmdir('./mkdir', (err) => console.log('err', err)); // err null
```

<br>

## rm[Sync]

-   **`fs.rm(path[, options], callback)`**
-   **`fs.rmSync(path[, options])`**

用于删除文件(夹)。

1. `path`：文件夹的路径

2. `options`：配置对象

    - `force`：为 `true` 时，如果 `path` 不存在，则异常将被忽略，默认为 `false`

    - `recursive`：如果为 `true`，则执行递归删除，默认为 `false`。在递归模式下，操作将在失败时重试

        `maxRetries`：表示重试次数，默认为 `0`（如果 `recursive` 选项为 `false`，则忽略此选项）

        `retryDelay`：重试之间等待的时间（以毫秒为单位），默认为 `100`（如果 `recursive` 选项为 `false`，则忽略此选项）

3. `callback`：回调函数，接收 1 个参数 `err`，默认为 `null`

```js
const fs = require('fs');

// 同步、递归删除文件夹
fs.rmSync('./reMkdirSync', { recursive: true });

// 异步、递归删除文件夹
fs.rm('./reMkdir', { recursive: true }, (err) => console.log('err', err));
```

<br><br>

# 其他操作

## rename[Sync]

-   **`fs.rename(oldPath, newPath, callback)`**
-   **`fs.renameSync(oldPath, newPath)`**

用于文件(夹)重命名。

1. `oldPath`：文件的原路径
2. `newPath`：文件的新路径
3. `callback`：回调函数，接收一个参数 `err`，默认为 `null`

```js
const fs = require('fs');

// 同步重命名
fs.renameSync('./oldSync.txt', './newSync.txt');

// 异步重命名
fs.rename(
    './old.txt',
    './new.txt',
    (err) => console.log('err', err) // err null
);
```

因为参数写的是路径，所以也可以在重命名的同时，把文件剪切到其他位置

```js
const fs = require('fs');

// 同步重命名 并剪切到 folder 文件夹下
fs.renameSync('./newSync.txt', './folder/newSync.txt');

// 异步重命名 并剪切到 folder 文件夹下
fs.rename(
    './new.txt',
    './folder/new.txt',
    (err) => console.log('err', err) // err null
);
```

如果 `newPath` 已经存在，则它将被覆盖。 如果在 `newPath` 中有目录，则会引发错误

```js
const fs = require('fs');

// 同步剪切 并覆盖同名文件
fs.renameSync('./folder/newSync.txt', './newSync.txt');

// 异步剪切 并覆盖同名文件
fs.rename('./folder/new.txt', './new.txt', (err) => console.log('err', err));
```

<br>

## existsSync

-   **`fs.existsSync(path)`**

用于查看文件(夹)是否存在。

1. `path`：文件的路径

-   如果文件存在，则返回 `true`；否则返回 `false`

```js
const fs = require('fs');
const result = fs.existsSync('./writeFile.txt');
console.log('result', result); // result false
```

-   该操作的同步方法已被弃用

<br>

## stat[Sync]

-   **`fs.stat(path[, options], callback)`**
-   **`fs.statSync(path[, options])`**

用于获取文件状态。

1. `path`：文件的路径
2. `options`：对获取操作的设置
    - `bigint`：`status` 中的数值是否为 bigint，默认为 `false`
3. `callBack`：接收 2 个参数：
    - `err`：错误信息，默认为 `null`
    - `status`：状态对象 `fs.Stats`，该对象中保存了当前对象状态的相关信息。eg：大小`size`、创建时间`birthtime`...

-   调用 `isDirectory` 方法可以查看当前对象是否为目录
-   调用 `isFile` 方法可以查看当前对象是否为文件

```js
const fs = require('fs');

const syncStatus = fs.statSync('./newSync.txt');
console.log('syncStatus', syncStatus); // syncStatus Stats {...}
console.log('syncStatus.isDirectory()', syncStatus.isDirectory()); // false -- 是否为目录
console.log('syncStatus.isFile()', syncStatus.isFile()); // true -- 是否为文件

fs.stat('./new.txt', (err, status) => {
    if (err) return console.log('err', err); // 如果该文件不存在，则报错
    console.log('status', status); // status Stats {...}
    console.log('status.isDirectory()', status.isDirectory()); // false
    console.log('status.isFile()', status.isFile()); // true
});
```

<br>

## truncate[Sync]

-   **`fs.truncate(path[, len], callback)`**
-   **`fs.truncateSync(path[, len])`**

用于截取文件内容。

1. `path`：文件的路径
2. `len`：将文件数据截到指定大小 (byte)，默认为 `0`
3. `callback`：回调函数，接收 1 个参数 `err`，默认为 `null`

```js
const fs = require('fs');

// 同步截取文件
fs.truncateSync('./newSync.txt', 5);

// 异步截取文件
fs.truncate('./new.txt', 5, (err) => console.log('err', err));
```

-   注意这里，一个中文字符占 2 / 3 个字节，所以截取指定字节后，可能会出现乱码

<br>

## watchFile

-   **`fs.watchFile(filename[, options][, listener])`**

监听文件数据的变化。

1. `filename`：文件的路径

2. `options`：配置对象

    - `bigint`：默认为 `false`

    - `persistent`：只要正在监视文件，进程是否应继续运行。默认为 `true`

    - `interval`：监听的间隔时间，默认为 `5007`

3. `listener`：回调函数，监听的文件被修改后调用，接收 2 个参数：
    - `current`：文件当前的状态，是 fs.status 对象
    - `previous`：文件修改前的状态，也是 fs.status 对象

返回值：`fs.StatWatcher` 对象，存储着一些监听的信息。eg：大小`size`

```js
const fs = require('fs');

const wf = fs.watchFile('new.txt', (current, previous) => {
    console.log('文件当前大小' + current.size);
    console.log('文件先前大小' + previous.size);
});
console.log('wf', wf);
```

<br>

## watch

-   **`fs.watch(filename[, options][, listener])`**

用于监听文件(夹)变化（改动数据 & 移动 / 重命名）。

1. `filename`：文件(夹)路径
2. `options`：配置对象
    - `encoding`：指定用于传给监听器的文件名的字符编码。如果只设置 `encoding`，可以直接写成 String 形式
    - `persistent`：只要正在监视文件，进程是否应继续运行。默认为 `true`
    - `recursive`：是否监视所有子目录，还是仅监视当前目录。默认为 `false`（仅在 macOS 和 Windows 上受支持）
3. `listener`：回调函数，接收 2 个参数：
    - `eventType`：参数值为 `rename` / `change`
    - `filename`：触发事件的文件(夹)名称

```js
const fs = require('fs');

fs.watch('./new.txt', (eventType, filename) => {
    console.log('eventType', eventType);
    console.log('filename', filename);
});
```

-   修改文件的数据时，会输出：`eventType change` `filename new.txt`
-   修改文件名 / 删除文件时，会输出：`eventType rename` `filename new.txt`。修改文件名 / 删除文件之后，监听事件失效

<br>
