# 调用其他钱包

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Demo {
    // 方法 1
    function setDemo2X(address _demo2, uint _x) public returns (uint) {
        Demo2 demo2 = Demo2(_demo2);
        return demo2.setX(_x);
    }

    // 方法 2
    function setDemo2X2(Demo2 _demo2, uint _x) public returns (uint) {
        return _demo2.setX(_x);
    }
}

contract Demo2 {
    uint public x;

    function setX(uint _x) public returns (uint) {
        x = _x;
        return x;
    }
}
```

调用的同时传输以太币：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Demo {
    function setDemo2(Demo2 _demo2) public payable returns (uint) {
        return _demo2.getEther{value: msg.value}();
    }
}

contract Demo2 {
    uint public value;

    function getEther() public payable returns (uint) {
        value = msg.value;
        return value;
    }
}
```

处理多返回值：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Demo {
    function getDemo2(Demo2 demo2) public pure returns (uint x, uint y) {
        (x, y) = demo2.getMulNum();
    }
}

contract Demo2 {
    function getMulNum() public pure returns (uint, uint) {
        return (1, 2);
    }
}
```

综合 demo：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MyTargetContract {
    uint public x;
    uint public value;

    function setX(uint _x) public {
        x = _x;
    }

    function getX() public view returns (uint) {
        return x;
    }

    function setXAndReceiveEther(uint _x) public payable {
        x = _x;
        value = msg.value;
    }

    function getXAndValue() public view returns (uint, uint) {
        return (x, value);
    }
}

contract MyCallerContract {
    MyTargetContract public target;

    constructor(MyTargetContract _target) {
        target = _target;
    }

    function setTargetX(uint _x) public {
        target.setX(_x);
    }

    function getTargetX() public view returns (uint) {
        return target.getX();
    }

    function setXWithEther(uint _x) public payable {
        target.setXAndReceiveEther{value: msg.value}(_x);
    }

    function getXAndValueFromTarget() public view returns (uint x, uint value) {
        (x, value) = target.getXAndValue();
    }
}
```

<br><br>

# 接口

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Counter {
    uint public count;

    function increment() public {
        count += 1;
    }
}

contract MyContract {
    function incrementCounter(address _counter) public {
        Counter(_counter).increment();
    }

    function getCount(address _counter) public view returns (uint) {
        return Counter(_counter).count();
    }
}
```

如果我们不知道 Counter 里面的代码，我们就需要使用接口：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface ICounter {
    function increment() external;

    function count() external view returns (uint);
}

contract MyContract {
    function incrementCounter(address _counter) public {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) public view returns (uint) {
        return ICounter(_counter).count();
    }
}
```

<br><br>

# call 方法

call 是一个比较底层的方法，除了可以用来发送以太，还能用来调用其他合约的函数。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestCall {
    event Log(string message, uint value);

    function foo(
        string calldata _str,
        uint _num
    ) external payable returns (bool, uint) {
        emit Log(_str, _num);
        return (true, 999);
    }
}

contract Call {
    bytes public data;

    function testCall(address _addr) public payable {
        (bool success, bytes memory _data) = _addr.call{
            // 传输的以太数量, 这里设置成与 msg.value 一致; 若设置的值与 msg.value 不一致 会报错
            value: msg.value,
            // 限制的 gas 上限; 若消耗的 gas 超过上限 会报错
            gas: 500000
            // 调用其他合约的方法, 并传入参数; 第 1 参数是方法签名, 不能有空格, 不能用简写
        }(abi.encodeWithSignature("foo(string,uint256)", "call foo", 123));
        require(success, "call failed");
        data = _data; // 返回值 _data 是被调用合约的方法的返回值
    }
}
```

demo：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestContract {
    string public message;
    uint256 public number;

    function foo(string memory _msg, uint256 _num) public {
        message = _msg;
        number = _num;
    }

    fallback() external {
        emit Log("Fallback was called");
    }

    event Log(string msg);
}

contract Caller {
    function callFoo(
        address _testContract,
        string memory _msg,
        uint256 _num
    ) public {
        (bool success, ) = _testContract.call(
            abi.encodeWithSignature("foo(string,uint256)", _msg, _num)
        );
        require(success, "call foo failed");
    }

    function callNonExistentFunction(address _testContract) public {
        (bool success, ) = _testContract.call(
            abi.encodeWithSignature("nonExistentFunction()")
        );
        require(success, "call nonExistentFunction failed");
    }
}
```

<br>
