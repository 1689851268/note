# 关键字

-   public：任何地方都能访问

-   private：仅能在合约内部访问

-   internal：仅能在合约内部或者继承合约内部访问

-   external：仅能在合约外部访问

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint public publicVar = 1;
    uint internal internalVar = 2;
    uint private privateVar = 3;
    uint initVar = 4; // default internal

    function publicFunc() public view returns (uint) {
        return publicVar;
    }

    function internalFunc() internal view returns (uint) {
        return internalVar;
    }

    function privateFunc() private view returns (uint) {
        return privateVar;
    }

    function externalFunc() external view returns (uint) {
        return initVar;
    }

    function testFuncInDemo() public view {
        publicVar + internalVar + privateVar + initVar;

        publicFunc();
        internalFunc();
        privateFunc();
        // externalFunc();
    }
}

contract DemoChild is Demo {
    function testFunc() public view {
        publicVar + internalVar + initVar;

        publicFunc();
        internalFunc();
        // privateFunc();
        // externalFunc();
    }
}

contract DemoExternal {
    Demo demo = new Demo();

    function testFunc() public view {
        demo.publicVar;

        demo.publicFunc();
        // demo.internalFunc();
        // demo.privateFunc();
        demo.externalFunc();
    }
}
```

<br><br>

# Immutable

immutable 修饰的变量需要在合约部署时初始化，之后不可修改。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint public immutable immutableVar1 = 1; // 声明时初始化
    uint public immutable immutableVar2;

    constructor(uint _immutableVar2) {
        immutableVar2 = _immutableVar2; // 通过构造函数初始化
    }
}

```

使用 immutable 能节省 gas 费用。

<br><br>

# payable

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 用 payable 修饰符修饰 owner 变量
    address payable public owner;

    constructor() {
        // 使用 payable() 函数将 msg.sender 转换为 payable 的 address 类型
        owner = payable(msg.sender);
    }

    // 用 payable 修饰符修饰 deposit 函数
    function deposit() public payable {}

    function getBalance() public view returns (uint) {
        // 获取 owner 的余额并返回
        return address(this).balance;
    }
}
```

<br><br>

# receive & fallback

在 Solidity 中，receive & fallback 是一种特殊的函数。声明形式为 `receive/fallback() external payable { ... }`。它不需要 `function` 关键字，没有参数，也没有返回值。

**特性**：

-   唯一性：一个合约最多只能有一个 receive & fallback 方法。
-   可见性：必须声明为 `external`，表示只能通过外部调用来触发。
-   支付能力：receive 必须使用 `payable` 修饰符；fallback 可以使用 `payable` 修饰符。

**receive & fallback 的区别**：

-   receive：专门用于处理没有附加数据的以太币转账。
-   fallback：用于处理所有其他情况，包括调用不存在的函数或接收带有附加数据的以太币转账。如果合约没有定义 `receive` 方法，但定义了 `payable` 的 `fallback` 方法，那么在接收以太币时会调用 `fallback` 方法。

**demo1**：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract ReceiveExample {
    event Log(string message, address sender, uint256 value, bytes data);

    // 定义 receive 方法
    receive() external payable {
        emit Log("receive", msg.sender, msg.value, "");
    }

    // 定义 fallback 方法
    fallback() external payable {
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }
}
```

**demo2**：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract ReceiveExample {
    // 声明一个变量，用于存储接收到的以太币数量
    uint256 private receivedAmount;

    // 定义 receive 方法
    receive() external payable {
        receivedAmount += msg.value; // 更新接收到的以太币数量
    }

    // 定义 fallback 方法
    fallback() external payable {
        revert("fallback");
    }

    // 获取合约的余额
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
```

<br><br>

# 以太币的发送与接收

在 Solidity 中，有 3 种方法发送以太币：

1.  transfer：消耗 2300 gas；如果发送失败，会回退交易
2.  send：消耗 2300 gas；会返回一个布尔值，表示发送成功/失败（较少使用）
3.  call：消耗所有 gas；会返回一个布尔值，表示发送成功/失败、还会返回一些数据（推荐使用）

有 2 种方法接收以太币：

1. 用 payable 修饰 constructor，接收部署时传入的以太币
2. 编写 receive 或 fallback 方法，接收以太币

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract SendEther {
    // 使用 transfer 方法发送以太币
    function sendViaTransfer(address payable _to) public payable {
        _to.transfer(msg.value);
    }

    // 使用 send 方法发送以太币
    function sendViaSend(address payable _to) public payable {
        bool sent = _to.send(msg.value);
        require(sent, "Send failed");
    }

    // 使用 call 方法发送以太币
    function sendViaCall(address payable _to) public payable {
        (bool success, ) = _to.call{value: msg.value}("");
        require(success, "Call failed");
    }
}

contract ReceiveEther {
    // 接收部署时传入的以太币
    constructor() payable {}

    event Received(address, uint, uint);

    // 接收以太币
    receive() external payable {
        // 打印发送者、接收的以太币数量、剩余的 gas
        emit Received(msg.sender, msg.value, gasleft());
    }
}
```
