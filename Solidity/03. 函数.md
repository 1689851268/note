# 函数

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Function {
    uint public num = 10;

    function add(uint x, uint y) external pure returns (uint) {
        // external: 只能被合约外部调用, 不能被合约内部调用
        // pure: 既不读取也不修改合约状态
        return x + y;
    }

    function getNum() external view returns (uint) {
        // view: 读取合约状态但不修改状态
        return num;
    }
}
```

<br><br>

# pure & view

-   pure：不修改状态变量、不读取状态变量
-   view：不修改状态变量、读取状态变量

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint public x = 10;

    function pureFunc(uint a, uint b) public pure returns (uint) {
        return a * b;
    }

    function viewFunc() public view returns (uint) {
        return x;
    }
}
```

会修改状态变量的函数不需要关键字修饰：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Counter {
    uint public count;

    function increment() external {
        count++;
    }

    function decrement() external {
        count--;
    }
}
```

<br><br>

# 函数装饰器

函数装饰器可以在函数执行之前或之后插入代码逻辑，用于改变函数的行为，比如检查条件、限制访问权限等。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义一个修饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 使用修饰器
    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}
```

修饰器可以接收参数 & 函数可以同时使用多个装饰器：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义一个修饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 定义一个带参数的修饰器
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        // address(0) is often used to represent an invalid or uninitialized address.
        _;
    }

    // 同时使用多个修饰器
    function changeOwner(
        address newOwner
    ) public onlyOwner validAddress(newOwner) {
        owner = newOwner;
    }
}
```

三明治装饰器 demo - 防止重入攻击，这是智能合约安全性的重要方面：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    bool private locked = false;

    // 定义一个防重入攻击的修饰器
    modifier noReentrant() {
        require(!locked, "No Reentrant");
        locked = true;
        _;
        locked = false;
    }

    // 使用防重入攻击的修饰器
    function withdraw() public noReentrant {
        // 提现逻辑
    }
}
```

<br><br>

# 构造函数

构造函数仅在部署合约的时候调用一次，它的作用主要是初始化一些状态变量。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;
    uint public num;

    constructor(uint _num) {
        owner = msg.sender;
        num = _num;
    }
}
```

<br><br>

# 函数输出

在 Solidity 中，函数可以拥有多个输出，且可以为输出命名。在其他函数获取该函数的输出值时，可以使用解构赋值。

demo - 函数拥有多个输出：

```solidity
contract Demo {
    function multipleReturns() public pure returns (uint, bool, string memory) {
        // In Solidity, complex types like string, bytes, and arrays
        // require a data location to be specified. This tells the compiler where the data is stored.
        // data location: memory 会告诉编译器, 变量值存储在内存中; 函数执行完后, 会释放内存
        //                修改 memory 修饰的变量, 不会影响区块链上的数据
        // data location: storage 会告诉编译器, 这个变量是一个引用
        //                修改 storage 修饰的变量, 会影响区块链上的数据
        return (1, true, "Hello, World!");
    }
}
```

demo - 为输出命名：

```solidity
contract Demo {
    function namedReturns1()
        public
        pure
        returns (uint x, bool y, string memory z)
    {
        // 显式返回
        return (1, true, "Hello, World!");
    }

    function namedReturns2()
        public
        pure
        returns (uint x, bool y, string memory z)
    {
        // 隐式返回
        x = 1;
        y = true;
        z = "Hello, World!";
    }
}
```

demo - 解构赋值：

```solidity
contract Demo {
    function get() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = multipleReturns();
        return (a, b, c);
    }

    function getNamed1() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = namedReturns1();
        return (a, b, c);
    }

    function getNamed2() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = namedReturns2();
        return (a, b, c);
    }
}
```

<br>
