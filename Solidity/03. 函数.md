# 构造函数

构造函数仅在部署合约时调用一次，它的作用主要是初始化一些状态变量。

```solidity
contract Demo {
    address public owner;
    uint public num;

    constructor(uint _num) {
        owner = msg.sender;
        num = _num;
    }
}
```

<br><br>

# 函数装饰器

函数装饰器可以在函数执行之前或之后插入代码逻辑，用于改变函数的行为，比如检查条件、限制访问权限等。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义装饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 使用装饰器
    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}
```

装饰器可以接收参数 & 函数可以同时使用多个装饰器：

```solidity
contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义装饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 定义带参数的装饰器
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        // address(0) is often used to represent an invalid or uninitialized address.
        _;
    }

    // 同时使用多个装饰器
    function changeOwner(
        address newOwner
    ) public onlyOwner validAddress(newOwner) {
        owner = newOwner;
    }
}
```

三明治装饰器：可以在函数执行之前和之后插入代码逻辑的装饰器。demo - 防止重入攻击：

```solidity
contract Demo {
    bool private locked = false;

    // 定义一个防止重入攻击的装饰器
    modifier noReentrant() {
        require(!locked, "No Reentrant");
        locked = true;
        _;
        locked = false;
    }

    // 使用装饰器
    function withdraw() public noReentrant {
        // 提现逻辑
    }
}
```

<br><br>

# 函数输出

单个返回值：

```solidity
contract Demo {
    function getSingleNumber() public pure returns (uint) {
        return 42;
    }
}
```

多个返回值：

```solidity
contract Demo {
    function getMultipleNumbers() public pure returns (uint, uint) {
        return (1, 2);
    }
}
```

命名返回值：

```solidity
contract Demo {
    function getNamedNumbers() public pure returns (uint first, uint second) {
        first = 3;
        second = 4;
        // 会自动执行 return (first, second)
    }
}
```

获取函数返回值：

```solidity
contract Demo {
    // ...

    function callFunctions() public pure returns (uint, uint, uint) {
        uint singleNumber = getSingleNumber(); // 获取单个返回值
        (uint multipleNumber1, uint multipleNumber2) = getMultipleNumbers(); // 获取多个返回值
        return (singleNumber, multipleNumber1, multipleNumber2);
    }
}
```

<br><br>

# 异常处理

Solidity 中的异常处理方法：

```solidity
contract Demo {
    // 1. require
    function testRequire(uint a) public pure returns (uint) {
        require(a > 10, "a must be greater than 10"); // 若条件不满足, 则触发异常, 并抛出异常信息; 会退还剩余的 gas
        return a;
    }

    // 2. revert
    function testRevert(uint a) public pure returns (uint) {
        if (a <= 10) {
            revert("a must be greater than 10"); // 触发异常, 并抛出异常信息; 会退还剩余的 gas
        }
        return a;
    }

    // 3. assert
    function testAssert(uint a) public pure returns (uint) {
        assert(a > 10); // 若条件不满足, 则触发异常; 会消耗剩余的 gas
        return a;
    }
}
```

自定义异常 - 可以自定义异常信息，且更节省 gas ：

```solidity
contract Demo {
    error MyError(address sender, uint value);

    function testCustomError(uint a) public view returns (uint) {
        if (a <= 10) {
            revert MyError(msg.sender, a); // 触发异常, 并抛出自定义的异常信息
        }
        return a;
    }
}
```

try catch - 适用于处理外部合约调用失败的情况：

```solidity
// 外部合约, 用于示例
contract ExternalContract {
    function mayFail(uint value) public pure returns (uint) {
        require(value != 0, "Value cannot be zero");
        return value * 2;
    }
}

// 主合约, 使用 try/catch 处理外部调用
contract TryCatchExample {
    event Success(uint value);
    event Failure(string reason);

    ExternalContract externalContract;

    constructor() {
        externalContract = new ExternalContract();
    }

    function tryCatchExample(uint value) public {
        try externalContract.mayFail(value) returns (uint result) {
            emit Success(result);
        } catch Error(string memory reason) {
            // 捕获 require 和 revert 抛出的错误，并返回错误消息
            emit Failure(reason);
        } catch (bytes memory) {
            // 捕获低级别错误（如 assert 抛出的错误），并返回通用错误消息
            emit Failure("Low-level error");
        }
    }
}
```



<br><br>

# 事件

```solidity
contract Demo {
    event Transfer(address indexed from, address indexed to, uint value); // 定义事件

    function transfer(address _to, uint _value) public {
        emit Transfer(msg.sender, _to, _value); // 触发事件
    }
}
```

事件的用途：

-   事件可以用于记录交易日志，帮助调试和监控合约的运行状态。
-   外部应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件，从而在事件发生时执行相应的操作。

事件的继承：

-   事件可以在合约中被继承，这使得子合约可以使用父合约定义的事件。

索引参数：

-   事件参数可以使用 `indexed` 关键字进行索引，最多可以索引三个参数。
-   索引参数可以加快事件的搜索和过滤。

监听事件：

外部应用程序（如 DApp）可以使用 Web3.js 等库来监听和处理事件。

```javascript
var event = contractInstance.Transfer();
event.watch(function (error, result) {
    if (!error) {
        console.log(result.args.from, result.args.to, result.args.value);
    }
});
```

<br>
