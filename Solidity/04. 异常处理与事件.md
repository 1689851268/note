# 异常处理

在 Solidity 中，有 3 种方法抛出异常：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 1. require
    function testRequire(uint256 a) public pure returns (uint256) {
        require(a > 10, "a must be greater than 10"); // 若条件不满足, 则会触发异常, 并抛出异常信息
        return a;
    }

    // 2. revert
    function testRevert(uint256 a) public pure returns (uint256) {
        if (a <= 10) {
            revert("a must be greater than 10"); // 触发异常, 并抛出异常信息
        }
        return a;
    }

    // 3. assert
    function testAssert(uint256 a) public pure returns (uint256) {
        assert(a > 10); // 若条件不满足, 则会触发异常
        return a;
    }
}
```

自定义异常 - 用于自定义异常信息：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    error MyError(address sender, uint256 value);

    function testCustomError(uint256 a) public view returns (uint256) {
        if (a <= 10) {
            revert MyError(msg.sender, a); // 触发异常, 并抛出自定义的异常信息
        }
        return a;
    }
}
```

try catch - 适用于处理外部合约调用失败的情况：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

// 外部合约, 用于示例
contract ExternalContract {
    function mayFail(bool _fail) public pure returns (string memory) {
        require(!_fail, "External call failed");
        return "Success";
    }
}

// 主合约, 使用 try/catch 处理外部调用
contract MainContract {
    event Success(string message);
    event Failure(string reason);

    ExternalContract externalContract;

    constructor() {
        externalContract = new ExternalContract();
    }

    function callExternal(bool _fail) public {
        try externalContract.mayFail(_fail) returns (string memory result) {
            emit Success(result);
        } catch Error(string memory reason) {
        	// 处理函数抛出的错误
            emit Failure(reason);
        } catch (bytes memory) {
           // 处理更底层的错误, 比如: out-of-gas、invalid opcode
            emit Failure("Unknown error");
        }
    }
}
```

在 Solidity 中，抛出异常会退还剩余的 gas，并恢复状态变量值。

<br><br>

# Event

```solidity
pragma solidity ^0.8.0;

contract Example {
    event Transfer(address indexed from, address indexed to, uint256 value); // 定义事件

    function transfer(address _to, uint256 _value) public {
        emit Transfer(msg.sender, _to, _value); // 触发事件
    }
}
```

**事件的用途**：

-   事件可以用于记录交易日志，帮助调试和监控合约的运行状态。
-   外部应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件，从而在事件发生时执行相应的操作。

**事件的继承**：

-   事件可以在合约中被继承，这使得子合约可以使用父合约定义的事件。

**索引参数**：

-   事件参数可以使用 `indexed` 关键字进行索引，最多可以索引三个参数。
-   索引参数可以加快事件的搜索和过滤。

**监听事件**：

外部应用程序（如 DApp）可以使用 Web3.js 等库来监听和处理事件。

```javascript
var event = contractInstance.Transfer();
event.watch(function (error, result) {
    if (!error) {
        console.log(result.args.from, result.args.to, result.args.value);
    }
});
```

<br>
