# 荷兰式拍卖

荷兰式拍卖（Dutch Auction），也称为减价拍卖。

拍卖从一个较高的起始价格开始，这个价格通常高于市场预期。随着时间的推移，价格按照预先设定的降价阶梯逐步降低。当价格降到某个竞买人愿意接受的水平时，该竞买人出价并成交。第一个应价的竞买人获胜，并支付当时的价格。

1. 定义接口：

```solidity
interface IERC721 {
    function transferFrom(
        address _from,
        address _to,
        uint _tokenId
    ) external;
}
```

2. 定义状态变量：

```solidity
contract DutchAuction {
    // 拍卖的 NFT 合约地址
    IERC721 public immutable nft;

    // 拍卖的 NFT ID
    uint public immutable nftId;

    // 卖家地址
    address payable public immutable seller;

    // 拍卖的持续时间
    uint public constant DURATION = 7 days;

    // 起拍价
    uint public immutable startPrice;

    // 拍卖开始时间
    uint public immutable startTime;

    // 拍卖结束时间
    uint public immutable endTime;

    // 每天的降价幅度
    uint public immutable discountPerDay;
}
```

3. 实现构造函数：

```solidity
contract DutchAuction {
    constructor(
        uint _startPrice,
        uint _discountPerDay,
        address _nft,
        uint _tokenId
    ) {
        require(
            _startPrice >= _discountPerDay * DURATION,
            "start price must be greater than or equal to the end price"
        );

        seller = payable(msg.sender);
        startPrice = _startPrice;
        discountPerDay = _discountPerDay;
        startTime = block.timestamp;
        endTime = startTime + DURATION;
        nft = IERC721(_nft);
        nftId = _tokenId;
    }
}
```

4. 实现函数：

```solidity
contract DutchAuction {
    // 查询当前价格
    function getCurrentPrice() public view returns (uint) {
        uint timeElapsed = block.timestamp - startTime; // 已经过去的时间
        return startPrice - discountPerDay * timeElapsed; // 当前价格
    }

    // 购买
    function buy() public payable {
        require(block.timestamp >= startTime, "auction has not started yet");
        require(block.timestamp < endTime, "auction has ended");
        uint currentPrice = getCurrentPrice();
        require(msg.value >= currentPrice, "insufficient funds");

		// 将 nftId 代币从卖家转给买家
        nft.transferFrom(seller, msg.sender, nftId);
        uint refund = msg.value - currentPrice;
        if (refund > 0) {
        	// 向调用者找零
            payable(msg.sender).transfer(refund);
        }
    }
}
```

<br><br>

# 英式拍卖

英式拍卖（English Auction），也称为增价拍卖。

拍卖从一个较低的起拍价开始。竞买人按竞价阶梯逐步提高出价。每次出价必须高于当前最高出价。当没有人愿意再出更高的价格时，拍卖结束，出价最高者成为买受人。

1. 定义接口：

```solidity
interface IERC721 {
    function transferFrom(
        address _from,
        address _to,
        uint _tokenId
    ) external;
}
```

2. 定义事件：

```solidity
contract EnglishAuction {
    // 当拍卖开始时触发
    event Start();

    // 当有新的出价时触发
    event Bid(address indexed bidder, uint amount);

    // 当退款时触发
    event Refund(address indexed bidder, uint amount);

    // 当拍卖结束时触发
    event End(address highestBidder, uint highestBid);
}
```

3. 定义状态变量：

```solidity
contract EnglishAuction {
    // 拍卖的 NFT 合约地址
    IERC721 public immutable nft;

    // 拍卖的 NFT ID
    uint public immutable nftId;

    // 卖家地址
    address payable public immutable seller;

    // 拍卖结束时间
    uint public endTime;

    // 拍卖是否已开始
    bool public isStarted;

    // 拍卖是否已结束
    bool public isEnded;

    // 当前最高出价者
    address public highestBidder;

    // 当前最高出价
    uint public highestBid;

    // 出价记录
    mapping(address => uint) public bids;
}
```

4. 实现构造函数：

```solidity
contract EnglishAuction {
    // 构造函数
    constructor(IERC721 _nft, uint _nftId, uint _startBid) {
        nft = _nft;
        nftId = _nftId;
        seller = payable(msg.sender);
        highestBid = _startBid;
    }
}
```

5. 实现函数开始拍卖：

```solidity
contract EnglishAuction {
    // 开始售卖
    function startAuction() external {
        require(msg.sender == seller, "Only seller can start auction");
        require(!isStarted, "Auction already started");

        isStarted = true;
        endTime = block.timestamp + 7 days;
        // 将 nftId 代币从卖家转给合约
        nft.transferFrom(seller, address(this), nftId);

        emit Start();
    }
}
```

6. 实现函数出价：

```solidity
contract EnglishAuction {
    // 出价
    function bid() external payable {
        require(isStarted, "Auction not started");
        require(block.timestamp < endTime && !isEnded, "Auction ended");
        require(msg.sender != seller, "Seller cannot bid");
        require(msg.value > highestBid, "Bid must be higher than highest bid");

        if (highestBidder != address(0)) {
            bids[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }
}
```

7. 实现函数结束拍卖：

```solidity
contract EnglishAuction {
    // 结束拍卖
    function endAuction() external {
        require(isStarted, "Auction not started");
        require(!isEnded, "Auction already ended");
        require(block.timestamp >= endTime, "Auction not ended");

        isEnded = true;
        if (highestBidder != address(0)) {
            // 有人出价, 将 nftId 代币从合约转为最高出价者
            nft.transferFrom(address(this), highestBidder, nftId);
            seller.transfer(highestBid);
        } else {
            // 无人出价, 将 ntfId 代币从合约转给卖家
            nft.transferFrom(address(this), seller, nftId);
        }

        emit End(highestBidder, highestBid);
    }
}
```

8. 实现函数退款：

```solidity
contract EnglishAuction {
    // 退款
    function refund() external {
        require(msg.sender != highestBidder, "Highest bidder cannot refund");

        uint amount = bids[msg.sender];
        bids[msg.sender] = 0;
        payable(msg.sender).transfer(amount);

        emit Refund(msg.sender, amount);
    }
}
```

<br><br>

# 金库 (Vault)

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000); // 为部署者 mint 1000 个代币
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract Vault {
    // 代币实例
    IERC20 public immutable token;

    // 总供应量
    uint public totalSupply;

    // 用户余额
    mapping(address => uint) public balanceOf;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function _mint(address _to, uint _amount) private {
        totalSupply += _amount;
        balanceOf[_to] += _amount;
    }

    function _burn(address _from, uint _amount) private {
        totalSupply -= _amount;
        balanceOf[_from] -= _amount;
    }

    // 存款
    function deposit(uint _amount) public {
        // a - 表示用户存入的代币数量 _amount
        // B - 存之前 合约中的代币数量
        // T - totalSupply
        // s - 需要 mint 的 shares
        // 满足公式 (T + s) / T = (a + B) / B
        // 得 s = a * T / B
        uint shares;
        if (totalSupply == 0) {
            shares = _amount;
        } else {
            shares = (_amount * totalSupply) / token.balanceOf(address(this));
        }
        _mint(msg.sender, shares);
        token.transferFrom(msg.sender, address(this), _amount);
    }

    // 提款
    function withdraw(uint _shares) public {
        // a - 表示用户提取的 shares 数量 _shares
        // B - 提取之前 合约中的代币数量
        // T - totalSupply
        // s - 需要 burn 的代币数量
        // 满足公式 (T - s) / T = (B - a) / B
        // 得 s = a * B / T
        uint amount = (_shares * token.balanceOf(address(this))) / totalSupply;
        _burn(msg.sender, _shares);
        token.transfer(msg.sender, amount);
    }
}
```

1.  传入 "MyToken"、"MT"，部署 MyToken 合约

2.  传入编辑器地址，查看 MyToken 合约的 balanceOf，为 1000 wei

3.  传入 MyToken 合约地址，部署 Vault 合约

4.  传入 Vault 合约地址、1000，调用 MyToken 合约的 approve 方法，授权 1000 wei

模拟用户存款：

1.  传入 1000，调用 Vault 合约的 deposit 方法，存入 1000 wei

2.  查看 Vault 合约的 totalSupply，为 1000

3.  复制编辑器地址，查看 Vault 合约的 balanceOf，为 1000

模拟金库赚钱了：

1. 传入编辑器地址、1000，调用 MyToken 合约的 mint 方法，mint 1000 wei

2. 传入 Vault 合约地址、1000，调用 MyToken 合约的 transfer 方法转账

模拟用户提款：

1. 传入 1000，调用 Vault 合约的 withdraw 方法，提取

2. 传入编辑器地址，查看 MyToken 合约的 balanceOf，增加了 2000 wei

3. 传入编辑器地址，查看 Vault 合约的 balanceOf、totalSupply，均为 0

<br><br>
