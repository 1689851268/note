# 访问修饰符

-   `private`：表示仅能在合约内部访问；可用于修饰函数和状态变量

-   `internal`：表示能在合约内部或继承合约内部访问；可用于修饰函数和状态变量

-   `public`：表示能在任何地方访问；可用于修饰函数和状态变量

-   `external`：表示仅能在合约外部访问；仅可用于修饰函数

```solidity
contract Demo {
    uint private privateVar = 1;
    uint internalVar = 2; // default internal
    uint public publicVar = 3;

    function privateFunc() private view returns (uint) {
        return privateVar;
    }

    function internalFunc() internal view returns (uint) {
        return internalVar;
    }

    function publicFunc() public view returns (uint) {
        return publicVar;
    }

    function externalFunc() external pure returns (uint) {
        return 4;
    }

    function testFuncInDemo() public view {
        privateVar + internalVar + publicVar;

        privateFunc();
        internalFunc();
        publicFunc();
        // externalFunc();
    }
}

contract ChildDemo is Demo {
    function testFuncInChild() public view {
        publicVar + internalVar + publicVar;

        // privateFunc();
        internalFunc();
        publicFunc();
        // externalFunc();
    }
}

contract ExternalDemo {
    Demo demo = new Demo(); // 通过 new 创建外部合约实例

    function testFuncInExternal() public view {
        demo.publicVar;

        // demo.privateFunc();
        // demo.internalFunc();
        demo.publicFunc();
        demo.externalFunc();
    }
}
```

在 Solidity 中，public 修饰的状态变量会自动生成 getter 函数，一般情况下 可以直接访问变量，但也有需要调用 getter 的情况：

```solidity
contract Demo {
    uint public publicVar = 1;
}

contract ExternalDemo {
    Demo demo = new Demo(); // 通过 new 创建外部合约实例

    function testFunc() public view returns (uint) {
        demo.publicVar; // 直接访问
        return demo.publicVar(); // 通过 getter 访问
    }
}
```

<br><br>

# 函数修饰符

-   `pure`：表示函数既不读取也不修改合约的状态变量
-   `view`：表示函数会读取合约的状态变量，但不修改它们

```solidity
contract Demo {
    uint public x = 10;

    function pureFunc(uint a, uint b) public pure returns (uint) {
        return a * b;
    }

    function viewFunc() public view returns (uint) {
        return x;
    }
}
```

对于会修改状态变量的函数，不需要函数修饰符：

```solidity
contract Demo {
    uint public count;

    function increment() external {
        count++;
    }
}
```

<br><br>

# 状态变量修饰符

-   `constant`：表示变量会在编译时确定值，且之后不会再更新
-   `immutable`：表示变量会在合约部署时确定值，且之后不会再更新

```solidity
contract Demo {
    uint public constant NUM = 100;
    address public immutable OWNER;

    constructor() {
        OWNER = msg.sender;
    }
}
```

<br><br>

# 本地变量修饰符

在函数中，可用 storage、memory、calldata 修饰引用类型数据。

-   `storage`：表示此处操作的是数据地址；仅可用于变量
-   `memory`：表示此处操作的是数据副本；可用于变量、参数、返回值
-   `calldata`：表示数据只读，不可操作；仅可用于参数

```solidity
contract Demo {
    struct Person {
        string name;
        uint age;
    }
    Person[] public persons;

    // calldata: 表示数据只读, 不可操作; 仅可用于参数
    function addPerson(string calldata _name, uint _age) public {
        persons.push(Person(_name, _age));
    }

    function getPerson(uint _index) public view returns (string memory, uint) {
        // memory: 表示此处操作的是数据副本; 可用于变量、参数、返回值
        return (persons[_index].name, persons[_index].age);
    }

    function updatePerson(uint _index, uint _age) public {
        // storage: 表示此处操作的是数据地址; 仅可用于变量
        Person storage person = persons[_index];
        person.age = _age;
    }
}
```

<br>
