# 位运算

位运算用于直接操作整数的二进制位。位运算可以帮助优化存储和计算效率，特别是在需要处理大量数据或进行复杂计算时。

**常用位运算符**：

1. 与运算（AND）`a & b`：对应位都为 1 时，结果为 1，否则为 0

2. 或运算（OR）`a | b`：对应位只要有一个为 1，结果为 1

3. 异或运算（XOR）`a ^ b`：对应位不同，结果为 1，相同为 0

4. 非运算（NOT）`~a`：将每个位取反，0 变 1，1 变 0

5. 左移运算（Left Shift）`a << n`：将二进制位向左移动指定的位数，右侧补 0

6. 右移运算（Right Shift）`a >> n`：将二进制位向右移动指定的位数，左侧补 0

**基础示例**：

```solidity
contract Demo {
    // 与运算
    function andOperation(uint8 a, uint8 b) public pure returns (uint8) {
        return a & b;
    }

    // 或运算
    function orOperation(uint8 a, uint8 b) public pure returns (uint8) {
        return a | b;
    }

    // 异或运算
    function xorOperation(uint8 a, uint8 b) public pure returns (uint8) {
        return a ^ b;
    }

    // 非运算
    function notOperation(uint8 a) public pure returns (uint8) {
        return ~a;
    }

    // 左移运算
    function leftShiftOperation(uint8 a, uint8 n) public pure returns (uint8) {
        return a << n;
    }

    // 右移运算
    function rightShiftOperation(uint8 a, uint8 n) public pure returns (uint8) {
        return a >> n;
    }
}
```

1. 与运算示例：`5 & 3`，二进制表示为 `0101 & 0011`，结果为 `0001`，即 `1`

2. 或运算示例：`5 | 3`，二进制表示为 `0101 | 0011`，结果为 `0111`，即 `7`

3. 异或运算示例：`5 ^ 3`，二进制表示为 `0101 ^ 0011`，结果为 `0110`，即 `6`

4. 非运算示例：`~5`，二进制表示为 `~00000101`（对于 8 位无符号整数），结果为 `11111010`，即 `250`

5. 左移运算示例：`5 << 1`，二进制表示为 `0101 << 1`，结果为 `1010`，即 `10`

6. 右移运算示例：`5 >> 1`，二进制表示为 `0101 >> 1`，结果为 `0010`，即 `2`

**应用场景**：

-   数据压缩：通过位运算可以将多个小数据压缩到一个变量中，节省存储空间。

-   权限管理：使用位掩码来管理权限和状态标志。

-   高效计算：在某些情况下，位运算比常规算术运算更高效。

<br><br>

# 应用示例

**将某数值转为二进制表示**：

```solidity
contract Demo {
    // 将无符号整数转换为二进制字符串表示
    function toBinary(uint num) public pure returns (string memory) {
        // 如果输入数字为 0, 直接返回字符串 "0"
        if (num == 0) {
            return "0";
        }

        // 计算二进制表示所需的位数
        uint length = 0;
        uint temp = num;
        while (temp > 0) {
            length++;
            temp >>= 1; // 将 temp 右移一位, 相当于除以 2
        }

        // 创建一个长度为 length 的字节数组, 用于存储二进制表示
        bytes memory binary = new bytes(length);

        // 循环遍历每一位
        for (uint i = 0; i < length; i++) {
            // 使用位运算检查 num 的第 i 位是否为 1
            // (1 << i) 将 1 左移 i 位, 得到一个只有第 i 位为 1 的数
            // num & (1 << i) 检查 num 的第 i 位是否为 1
            // 如果结果不为 0, 则第 i 位为 1, 否则为 0
            binary[length - i - 1] = (num & (1 << i)) != 0
                ? bytes1("1")
                : bytes1("0");
        }

        // 将字节数组转换为字符串并返回
        return string(binary);
    }
}
```

<br>

**获取某二进制数值的最后 n 位**：eg: x = 00001101 = 13, getLastBits(x, 3) = 00000101 = 5

```solidity
contract Demo {
    // 思路 1: 定义一个掩码, 掩码的最后 n 位为 1, 其余位为 0, 与原数值进行 & 运算
    function getLastBits(uint8 x, uint8 n) public pure returns (uint8) {
        // 生成掩码: 1 << n - 1
        // 1 << n 生成一个二进制数值, 只有倒数第 n + 1 位为 1, 其余位为 0
        // 减 1 后, 得到的二进制数值, 最后 n 位为 1, 其余位为 0
        // eg: n = 3, 1 << 3 = 00001000, 00001000 - 1 = 00000111
        uint8 mask = (uint8(1) << n) - uint8(1);
        return x & mask;
    }

    // 思路 2: 定义一个除数，除数的倒数第 n + 1 位为 1，其余位为 0，对原数值进行 % 运算
    function getLastBits2(uint8 x, uint8 n) public pure returns (uint8) {
        // 生成除数: 2 ** n 或 1 << n
        // eg: n = 3, 2 ** 3 = 8 = 00001000; 1 << 3 = 00001000
        uint8 divisor = uint8(1) << n;
        return x % divisor;
    }
}
```

<br>

**查找最高有效位**：最高有效位（Most Significant Bit，MSB）是二进制表示中最左边的 1 所在的位置。可以使用位运算来查找一个数值的最高有效位。

```solidity
contract Demo {
    // 查找 uint 数值的最高有效位; eg: 42 -> 101010 -> 5; 10 -> 001010 -> 3
    function findMSB(uint value) public pure returns (uint8) {
        uint8 msb = 0;

        if (value >= 2 ** 128) {
            value >>= 128;
            msb += 128;
        }
        if (value >= 2 ** 64) {
            value >>= 64;
            msb += 64;
        }
        if (value >= 2 ** 32) {
            value >>= 32;
            msb += 32;
        }
        if (value >= 2 ** 16) {
            value >>= 16;
            msb += 16;
        }
        if (value >= 2 ** 8) {
            value >>= 8;
            msb += 8;
        }
        if (value >= 2 ** 4) {
            value >>= 4;
            msb += 4;
        }
        if (value >= 2 ** 2) {
            value >>= 2;
            msb += 2;
        }
        if (value >= 2 ** 1) {
            // value >>= 1; 最后一个就不需要做位运算啦
            msb += 1;
        }

        return msb;
    }
}
```

<br><br>

# unchecked

在 Solidity 0.8.0 版本及之后，算术运算默认会进行上溢和下溢检查。如果发生溢出，操作会回退并抛出异常。这种检查增加了代码的安全性，但也会带来一些额外的 gas 费用。在某些情况下，你可能希望避免这些检查以提高效率，这时可以使用 `unchecked` 关键字。

```solidity
contract UncheckedExample {
    // 使用 checked 模式进行加法运算
    function checkedAdd(uint8 a, uint8 b) public pure returns (uint8) {
        return a + b; // 如果 a + b 溢出, 将抛出异常
    }

    // 使用 unchecked 模式进行加法运算
    function uncheckedAdd(uint8 a, uint8 b) public pure returns (uint8) {
        unchecked {
            return a + b; // 如果 a + b 溢出, 将不会抛出异常, 结果会截断
        }
    }
}
```

<br>
