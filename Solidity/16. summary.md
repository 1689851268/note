

# ERC20

ERC-20 是以太坊区块链上的一种代币标准，全称为 "Ethereum Request for Comment 20"。ERC-20 标准定义了一组通用的接口，使得代币可以在不同的应用程序和平台之间互操作。

ERC-20 标准包括以下核心方法：

```solidity
interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}
```

ERC-20 标准还定义了两个重要的事件：

-   `Transfer(address indexed from, address indexed to, uint value)`: 记录代币转移操作。
-   `Approval(address indexed owner, address indexed spender, uint value)`: 记录授权操作。

以下是一个简单的 ERC-20 代币合约示例：

```solidity
contract ERC20 is IERC20 {
    // 存储代币的名称、符号和小数位数
    string public name = "TestToken";
    string public symbol = "TTK";
    uint8 public decimals = 18; // 10^decimals 表示一个 "TestToken" 代币

    // 存储代币的总供应量
    uint public totalSupply;

    // 存储每个地址的代币余额; owner => balance
    mapping(address => uint) public balanceOf;

    // 存储每个地址对其他地址的授权额度; owner => spender => amount
    mapping(address => mapping(address => uint)) public allowance;

    // 定义两个事件，用于记录代币转移和授权操作
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint value
    );

    // 将 amount 数量的代币从调用者的账户转移到 recipient 账户
    function transfer(
        address recipient,
        uint amount
    ) external override returns (bool) {
        require(
            balanceOf[msg.sender] >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    // 授权 spender 可以从调用者的账户中转移最多 amount 数量的代币
    function approve(
        address spender,
        uint amount
    ) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 从 sender 账户转移 amount 数量的代币到 recipient 账户
    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external override returns (bool) {
        require(
            balanceOf[sender] >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        require(
            allowance[sender][msg.sender] >= amount,
            "ERC20: transfer amount exceeds allowance"
        );
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        allowance[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}
```

除了上述核心方法，你可能还听过 mint、burn 等方法，这些方法是 ERC-20 标准之外的扩展方法，用于增发和销毁代币。

```solidity
contract ERC20 is IERC20 {
    // ...

    // 增发 amount 数量的代币
    function mint(uint amount) external {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
    }

    // 销毁 amount 数量的代币
    function burn(uint amount) external {
        require(
            balanceOf[msg.sender] >= amount,
            "ERC20: burn amount exceeds balance"
        );
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}
```

如果 mint 方法没有适当的权限控制，可能会导致无限制地创建代币，进而引发通货膨胀和代币价值下降。如果 burn 方法没有适当的检查，可能会导致用户意外销毁大量代币，造成经济损失。为了防止这些风险，通常会在合约中加入权限控制和严格的检查机制。例如，只有合约所有者或经过授权的账户才能调用 mint 方法。

<br><br>

# 多签钱包

多签钱包（Multisig Wallet）是一种需要多个密钥持有者共同授权才能执行交易的数字钱包。常见的签名模式包括 2/3、3/5 等。例如，在 2/3 签名模式中，三个密钥中至少需要两个签名才能执行交易。

在创建多签钱包时，需要指定多个密钥持有者和最少签名数。例如，可以设置三个密钥持有者，并要求至少两个签名才能执行交易。任何一个密钥持有者可以提交交易请求，其他密钥持有者需要对交易进行签名和确认，当达到最少签名数时，交易将被执行。

以下是一个简单的多签钱包智能合约示例：

1. 先定义一些事件：

```solidity
contract MultiSigWallet {
    // 当 sender 把 amount 存入合约时触发
    event Deposit(address indexed sender, uint amount);

    // 当 txIndex 被提交时触发
    event Submit(uint indexed txIndex);

    // 当 owner 批准 txIndex 时触发
    event Approve(address indexed owner, uint indexed txIndex);

    // 当 owner 撤销 txIndex 时触发
    event Revoke(address indexed owner, uint indexed txIndex);

    // 当 txIndex 被执行时触发
    event Execute(uint indexed txIndex);
}
```

2. 定义交易的结构体：

```solidity
contract MultiSigWallet {
    // 交易的结构体
    struct Transaction {
        address to; // 接收地址
        uint value; // 金额
        bytes data; // 数据
        bool executed; // 是否已执行
    }
}
```

3. 定义一些状态变量：

```solidity
contract MultiSigWallet {
    // 交易
    Transaction[] public transactions;

    // owner 们
    address[] public owners;

    // owner => 是否为 owner
    mapping(address => bool) public isOwner;

    // 需要多少个 owner 批准, 交易才能被执行
    uint public numApprovalsRequired;

    // 交易被 owner 批准的情况; txIndex => owner => 是否批准
    mapping(uint => mapping(address => bool)) public isApproved;
}
```

4. 实现构造函数：

```solidity
contract MultiSigWallet {
    constructor(address[] memory _owners, uint _numApprovalsRequired) {
        require(_owners.length > 0, "owners required");
        require(
            _numApprovalsRequired > 0 &&
                _numApprovalsRequired <= _owners.length,
            "invalid number of required approvals"
        );

        for (uint i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "invalid owner");
            require(!isOwner[owner], "owner not unique");
            isOwner[owner] = true;
            owners.push(owner);
        }

        numApprovalsRequired = _numApprovalsRequired;
    }
}
```

5. 实现一些函数装饰器：

```solidity
contract MultiSigWallet {
    // 函数装饰器; 检查调用者是否为 owner, 是则继续
    modifier onlyOwner() {
        require(isOwner[msg.sender], "not owner");
        _;
    }

    // 函数装饰器; 检查交易是否存在, 存在则继续
    modifier txExists(uint _txIndex) {
        require(_txIndex < transactions.length, "tx does not exist");
        _;
    }

    // 函数装饰器; 检查交易是否已执行, 未执行则继续
    modifier notExecuted(uint _txIndex) {
        require(!transactions[_txIndex].executed, "tx already executed");
        _;
    }

    // 函数装饰器; 检查交易是否被 owner 批准, 未批准则继续
    modifier notApproved(uint _txIndex) {
        require(!isApproved[_txIndex][msg.sender], "tx already approved");
        _;
    }
}
```

6. 实现函数接收以太币：

```solidity
contract MultiSigWallet {
    // 接收以太币
    receive() external payable {
        emit Deposit(msg.sender, msg.value);
    }
}
```

7. 实现函数提交交易：

```solidity
contract MultiSigWallet {
    // 提交交易
    function submitTransaction(
        address _to,
        uint _value,
        bytes calldata _data
    ) external onlyOwner {
        uint txIndex = transactions.length;
        transactions.push(
            Transaction({to: _to, value: _value, data: _data, executed: false})
        );
        emit Submit(txIndex);
    }
}
```

8. 实现函数批准交易：

```solidity
contract MultiSigWallet {
    // 批准交易
    function approveTransaction(
        uint _txIndex
    )
        external
        onlyOwner
        txExists(_txIndex)
        notExecuted(_txIndex)
        notApproved(_txIndex)
    {
        isApproved[_txIndex][msg.sender] = true;
        emit Approve(msg.sender, _txIndex);
    }
}
```

9. 实现函数撤销批准：

```solidity
contract MultiSigWallet {
    // 撤销批准
    function revokeTransaction(
        uint _txIndex
    ) external onlyOwner txExists(_txIndex) notExecuted(_txIndex) {
        require(isApproved[_txIndex][msg.sender], "tx not approved");
        isApproved[_txIndex][msg.sender] = false;
        emit Revoke(msg.sender, _txIndex);
    }
}
```

10. 实现函数执行交易：

```solidity
contract MultiSigWallet {
    // helper function; 获取已批准的 owner 数量
    function _getApprovals(uint _txIndex) private view returns (uint) {
        uint approvals = 0;
        for (uint i = 0; i < owners.length; i++) {
            if (isApproved[_txIndex][owners[i]]) {
                approvals++;
            }
        }
        return approvals;
    }

    // 执行交易
    function executeTransaction(
        uint _txIndex
    ) external onlyOwner txExists(_txIndex) notExecuted(_txIndex) {
        require(
            _getApprovals(_txIndex) >= numApprovalsRequired,
            "cannot execute tx"
        );

        Transaction storage transaction = transactions[_txIndex];
        transaction.executed = true;

        (bool success, ) = transaction.to.call{value: transaction.value}(
            transaction.data
        );
        require(success, "tx failed");

        emit Execute(_txIndex);
    }
}
```

<br><br>

# WETH

包装以太币（Wrapped Ether，简称 WETH）是一种将原生的以太币（ETH）转换为 ERC-20 代币的机制。由于以太坊网络上的许多去中心化应用（DApps）和智能合约主要与 ERC-20 代币交互，WETH 使得 ETH 可以与这些应用和合约无缝集成。

WETH 的价值与 ETH 1:1 锚定。包装和解包过程涉及将 ETH 存入或从智能合约中提取。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract WETH {
    // 代币名称
    string public name = "Wrapped Ether";

    // 代币符号
    string public symbol = "WETH";

    // 代币的小数位数, 通常为 18
    uint8 public decimals = 18;

    // 记录每个地址的 WETH 余额
    mapping(address => uint) public balanceOf;

    // 记录存入 ETH 的事件
    event Deposit(address indexed account, uint amount);

    // 记录提取 ETH 的事件
    event Withdrawal(address indexed account, uint amount);

    // 使合约可以接受 ETH
    receive() external payable {
        deposit();
    }

    // 接受 ETH 并将其转换为 WETH
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    // 将 WETH 转换回 ETH 并提取到调用者的地址
    function withdraw(uint amount) public {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    // 返回合约中存储的 ETH 总量
    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }
}
```

我们可以直接使用 OpenZeppelin 的 ERC20 合约库来实现 WETH 合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract WETH is ERC20 {
    // 记录存入 ETH 的事件
    event Deposit(address indexed account, uint amount);

    // 记录提取 ETH 的事件
    event Withdrawal(address indexed account, uint amount);

    // 初始化 WETH 合约
    constructor() ERC20("Wrapped Ether", "WETH") {}

    // 使合约可以接受 ETH
    receive() external payable {
        deposit();
    }

    // 接受 ETH 并将其转换为 WETH
    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    // 将 WETH 转换回 ETH 并提取到调用者的地址
    function withdraw(uint amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }
}
```

1. 部署 WETH 合约

2. 调用 WETH 合约的 deposit 函数，设置传入的 ETH 数量，这里以 1 ETH 为例

3. 调用 WETH 合约继承的 balanceOf 函数，传入部署 WETH 合约的地址，查看 WETH 余额

4. 调用 WETH 合约继承的 totalSupply 函数，查看合约中存储的 ETH 总量

5. 调用 WETH 合约的 withdraw 函数，传入提取的 WETH 数量，提取 ETH

6. 调用 WETH 合约继承的 balanceOf 函数，查看 WETH 余额

7. 调用 WETH 合约继承的 totalSupply 函数，查看合约中存储的 ETH 总量

<br>

# 荷兰式拍卖

荷兰式拍卖（Dutch Auction），也称为减价拍卖。

拍卖从一个较高的起始价格开始，这个价格通常高于市场预期。随着时间的推移，价格按照预先设定的降价阶梯逐步降低。当价格降到某个竞买人愿意接受的水平时，该竞买人出价并成交。第一个应价的竞买人获胜，并支付当时的价格。

1. 定义接口：

```solidity
interface IERC721 {
    function transferFrom(
        address _from,
        address _to,
        uint _tokenId
    ) external;
}
```

2. 定义状态变量：

```solidity
contract DutchAuction {
    // 拍卖的 NFT 合约地址
    IERC721 public immutable nft;

    // 拍卖的 NFT ID
    uint public immutable nftId;

    // 卖家地址
    address payable public immutable seller;

    // 拍卖的持续时间
    uint public constant DURATION = 7 days;

    // 起拍价
    uint public immutable startPrice;

    // 拍卖开始时间
    uint public immutable startTime;

    // 拍卖结束时间
    uint public immutable endTime;

    // 每天的降价幅度
    uint public immutable discountPerDay;
}
```

3. 实现构造函数：

```solidity
contract DutchAuction {
    constructor(
        uint _startPrice,
        uint _discountPerDay,
        address _nft,
        uint _tokenId
    ) {
        require(
            _startPrice >= _discountPerDay * DURATION,
            "start price must be greater than or equal to the end price"
        );

        seller = payable(msg.sender);
        startPrice = _startPrice;
        discountPerDay = _discountPerDay;
        startTime = block.timestamp;
        endTime = startTime + DURATION;
        nft = IERC721(_nft);
        nftId = _tokenId;
    }
}
```

4. 实现函数：

```solidity
contract DutchAuction {
    // 查询当前价格
    function getCurrentPrice() public view returns (uint) {
        uint timeElapsed = block.timestamp - startTime; // 已经过去的时间
        return startPrice - discountPerDay * timeElapsed; // 当前价格
    }

    // 购买
    function buy() public payable {
        require(block.timestamp >= startTime, "auction has not started yet");
        require(block.timestamp < endTime, "auction has ended");
        uint currentPrice = getCurrentPrice();
        require(msg.value >= currentPrice, "insufficient funds");

        nft.transferFrom(seller, msg.sender, nftId);
        uint refund = msg.value - currentPrice;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
    }
}
```

<br><br>

# 英式拍卖

英式拍卖（English Auction），也称为增价拍卖。

拍卖从一个较低的起拍价开始。竞买人按竞价阶梯逐步提高出价。每次出价必须高于当前最高出价。当没有人愿意再出更高的价格时，拍卖结束，出价最高者成为买受人。

1. 定义接口：

```solidity
interface IERC721 {
    function transferFrom(
        address _from,
        address _to,
        uint _tokenId
    ) external;
}
```

2. 定义事件：

```solidity
contract EnglishAuction {
    // 当拍卖开始时触发
    event Start();

    // 当有新的出价时触发
    event Bid(address indexed bidder, uint amount);

    // 当退款时触发
    event Refund(address indexed bidder, uint amount);

    // 当拍卖结束时触发
    event End(address highestBidder, uint highestBid);
}
```

3. 定义状态变量：

```solidity
contract EnglishAuction {
    // 拍卖的 NFT 合约地址
    IERC721 public immutable nft;

    // 拍卖的 NFT ID
    uint public immutable nftId;

    // 卖家地址
    address payable public immutable seller;

    // 拍卖结束时间
    uint public endTime;

    // 拍卖是否已开始
    bool public isStarted;

    // 拍卖是否已结束
    bool public isEnded;

    // 当前最高出价者
    address public highestBidder;

    // 当前最高出价
    uint public highestBid;

    // 出价记录
    mapping(address => uint) public bids;
}
```

4. 实现构造函数：

```solidity
contract EnglishAuction {
    // 构造函数
    constructor(IERC721 _nft, uint _nftId, uint _startBid) {
        nft = _nft;
        nftId = _nftId;
        seller = payable(msg.sender);
        highestBid = _startBid;
    }
}
```

5. 实现函数开始拍卖：

```solidity
contract EnglishAuction {
    // 开始售卖
    function startAuction() external {
        require(msg.sender == seller, "Only seller can start auction");
        require(!isStarted, "Auction already started");

        isStarted = true;
        endTime = block.timestamp + 7 days;
        nft.transferFrom(seller, address(this), nftId);

        emit Start();
    }
}
```

6. 实现函数出价：

```solidity
contract EnglishAuction {
    // 出价
    function bid() external payable {
        require(isStarted, "Auction not started");
        require(block.timestamp < endTime && !isEnded, "Auction ended");
        require(msg.sender != seller, "Seller cannot bid");
        require(msg.value > highestBid, "Bid must be higher than highest bid");

        if (highestBidder != address(0)) {
            bids[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }
}
```

7. 实现函数结束拍卖：

```solidity
contract EnglishAuction {
    // 结束拍卖
    function endAuction() external {
        require(isStarted, "Auction not started");
        require(!isEnded, "Auction already ended");
        require(block.timestamp >= endTime, "Auction not ended");

        isEnded = true;
        if (highestBidder != address(0)) {
            // 有人出价, 转移 NFT 和 ETH 给最高出价者
            nft.transferFrom(address(this), highestBidder, nftId);
            seller.transfer(highestBid);
        } else {
            // 无人出价, 退还 NFT 给卖家
            nft.transferFrom(address(this), seller, nftId);
        }

        emit End(highestBidder, highestBid);
    }
}
```

8. 实现函数退款：

```solidity
contract EnglishAuction {
    // 退款
    function refund() external {
        require(msg.sender != highestBidder, "Highest bidder cannot refund");

        uint amount = bids[msg.sender];
        bids[msg.sender] = 0;
        payable(msg.sender).transfer(amount);

        emit Refund(msg.sender, amount);
    }
}
```

<br>

# 群众筹资

1. 定义接口：

```solidity
interface IERC20 {
    function transfer(address, uint) external returns (bool);

    function transferFrom(address, address, uint) external returns (bool);
}
```

2. 定义事件：

```solidity
contract CrowdFunding {
    // 发起众筹时触发
    event Launch(
        uint id,
        address indexed creator,
        uint goal,
        uint balance,
        uint32 startTime,
        uint32 endTime
    );

    // 取消众筹时触发
    event Cancel(uint id);

    // 用户参与众筹时触发
    event Donate(uint indexed id, address indexed donor, uint amount);

    // 用户取消参与众筹时触发
    event CancelDonation(uint indexed id, address indexed donor, uint amount);

    // 发起人提取众筹资金时触发
    event Claim(uint id);

    // 退还未达标的众筹资金时触发
    event Refund(uint indexed id, address indexed donor, uint amount);
}
```

3. 定义结构体：

```solidity
contract CrowdFunding {
    // 众筹项目的数据结构
    struct Campaign {
        // 众筹发起人
        address creator;
        // 众筹目标金额
        uint goal;
        // 众筹已筹金额
        uint balance;
        // 众筹开始时间
        uint32 startTime;
        // 众筹结束时间
        uint32 endTime;
        // 众筹是否已被提取
        bool claimed;
    }
}
```

4. 定义状态变量：

```solidity
contract CrowdFunding {
    // 众筹代币
    IERC20 public immutable token;

    // 众筹项目数量
    uint public count;

    // 众筹项目
    mapping(uint => Campaign) public campaigns;

    // 用户对众筹项目的捐赠
    mapping(uint => mapping(address => uint)) public donations;
}
```

5. 实现构造函数：

```solidity
contract CrowdFunding {
    constructor(IERC20 _token) {
        token = _token;
    }
}
```

6. 实现发起众筹方法：

```solidity
contract CrowdFunding {
    // 发起众筹
    function launch(uint _goal, uint32 _startTime, uint32 _endTime) external {
        require(_goal > 0, "invalid goal");
        require(_startTime > block.timestamp, "invalid start time");
        require(_endTime > _startTime, "invalid end time");

        count++;
        campaigns[count] = Campaign(
            msg.sender,
            _goal,
            0,
            _startTime,
            _endTime,
            false
        );

        emit Launch(count, msg.sender, _goal, 0, _startTime, _endTime);
    }
}
```

7. 实现取消众筹方法：

```solidity
contract CrowdFunding {
    // 取消众筹
    function cancel(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(msg.sender == campaign.creator, "not creator");
        require(block.timestamp < campaign.startTime, "crowdfunding started");

        delete campaigns[_id];

        emit Cancel(_id);
    }
}
```

8. 实现用户参与众筹方法：

```solidity
contract CrowdFunding {
    // 用户参与众筹
    function donate(uint _id, uint _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator != address(0), "invalid campaign");
        require(
            block.timestamp >= campaign.startTime,
            "crowdfunding not started"
        );
        require(block.timestamp < campaign.endTime, "crowdfunding ended");
        require(_amount > 0, "invalid amount");

        campaign.balance += _amount;
        donations[_id][msg.sender] += _amount;
        token.transferFrom(msg.sender, address(this), _amount);

        emit Donate(_id, msg.sender, _amount);
    }
}
```

9. 实现用户取消参与众筹方法：

```solidity
contract CrowdFunding {
    // 用户取消参与众筹
    function cancelDonation(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(
            block.timestamp >= campaign.startTime,
            "crowdfunding not started"
        );
        require(block.timestamp < campaign.endTime, "crowdfunding ended");
        require(donations[_id][msg.sender] > 0, "invalid donation");

        uint amount = donations[_id][msg.sender];
        campaign.balance -= amount;
        donations[_id][msg.sender] = 0;
        token.transfer(msg.sender, amount);

        emit CancelDonation(_id, msg.sender, amount);
    }
}
```

10. 实现发起人提取众筹资金方法：

```solidity
contract CrowdFunding {
    // 发起人提取众筹资金
    function claim(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator");
        require(block.timestamp >= campaign.endTime, "crowdfunding not ended");
        require(campaign.balance >= campaign.goal, "not reach goal");
        require(!campaign.claimed, "claimed");

        campaign.claimed = true;
        token.transfer(msg.sender, campaign.balance);

        emit Claim(_id);
    }
}
```

11. 实现退还未达标的众筹资金方法：

```solidity
contract CrowdFunding {
    // 退还未达标的众筹资金
    function refund(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator != address(0), "invalid campaign");
        require(block.timestamp >= campaign.endTime, "crowdfunding not ended");
        require(campaign.balance < campaign.goal, "reach goal");
        require(!campaign.claimed, "claimed");

        uint amount = donations[_id][msg.sender];
        donations[_id][msg.sender] = 0;
        token.transfer(msg.sender, amount);

        emit Refund(_id, msg.sender, amount);
    }
}
```

<br><br>

# CREATE2

CREATE2 是以太坊虚拟机（EVM）中的一个操作码，用于创建智能合约。与传统的 CREATE 操作码不同，CREATE2 允许开发者在部署合约之前预测其地址。

CREATE2 通过以下公式计算合约地址：`address = keccak256(0xff + sender + salt + keccak256(bytecode))`，其中：`0xff` 是一个常量，用于区分 CREATE2 和 CREATE；`sender` 是创建合约的合约地址；`salt` 是一个 32 字节的随机值，由开发者提供；`bytecode` 是要部署的合约的字节码。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract DeployWithCreate2 {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }
}

contract Create2Factory {
    event Deploy(address addr);

    // 使用 CREATE2 操作码部署 DeployWithCreate2 合约
    function deploy(uint _salt) external {
        DeployWithCreate2 _contract = new DeployWithCreate2{
            salt: bytes32(_salt)
        }(msg.sender);
        emit Deploy(address(_contract));
    }

    // 获取 DeployWithCreate2 合约的字节码
    function getBytecode(address _owner) public pure returns (bytes memory) {
        // 获取 DeployWithCreate2 合约的创建字节码
        // 创建字节码包含了合约的所有代码, 但不包括构造函数参数
        bytes memory bytecode = type(DeployWithCreate2).creationCode;
        // 将创建字节码和编码后的构造函数参数打包在一起, 并返回
        return abi.encodePacked(bytecode, abi.encode(_owner));
    }

    // 计算合约地址
    function getAddress(
        bytes memory bytecode,
        uint _salt
    ) public view returns (address) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(bytecode)
            )
        );
        // 将 hash 转为 uint 再转为 uint160, 表示取最后 20 个字节, 因为以太坊地址是 20 字节长
        return address(uint160(uint(hash)));
    }
}
```

1. 部署 Create2Factory 合约

2. 将编辑器的地址作为参数传入 getBytecode 方法并调用，获取 DeployWithCreate2 合约的字节码

3. 将获取到的字节码和随机值作为参数传入 getAddress 方法并调用，计算合约地址；随机值这里以 123 为例

4. 调用 deploy 方法，传入随机值 123，部署 DeployWithCreate2 合约

5. 查看 DeployWithCreate2 合约地址，与计算的合约地址比对，两者应该相等

<br><br>

# Time Lock

时间锁（TimeLock）是一种机制，用于将智能合约中的某些操作延迟执行，以提高安全性和透明度。时间锁通常用于去中心化金融（DeFi）和去中心化自治组织（DAO）中，以防止恶意操作和提供足够的时间进行审查和反应。

时间锁合约允许用户创建一个交易，并将其放入一个队列中。该交易在指定的延迟时间后才能执行。

主要功能：

1.  创建交易：将交易加入时间锁队列。

2.  执行交易：在锁定期满后执行交易。

3.  取消交易：在锁定期内取消交易。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TimeLock {
    // 管理员地址
    address public immutable admin;

    // 最小锁定时间
    uint public constant MIN_DELAY = 60; // 生产环境常用 1 days ~ 2 days

    // 最大锁定时间
    uint public constant MAX_DELAY = 120; // 生产环境常用 7 days ~ 30 days

    // 到期执行的宽限时间
    uint public constant GRACE_PERIOD = 60; // 生产环境常用 1 days ~ 7 days

    // 记录所有在时间锁队列中的交易
    mapping(bytes32 => bool) public queuedTransactions;

    // 交易创建并进入时间锁队列的事件
    event QueueTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 锁定期满后交易执行的事件
    event ExecuteTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 交易取消事件
    event CancelTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 初始化管理员地址
    constructor() {
        admin = msg.sender;
    }

    // 让合约可以接收以太币
    receive() external payable {}

    // 限制只有管理员才能调用的函数
    modifier onlyAdmin() {
        require(msg.sender == admin, "TimeLock: Caller is not admin");
        _;
    }

    // 创建交易并添加到时间锁队列中
    function queueTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin returns (bytes32) {
        require(
            executeTime >= block.timestamp + MIN_DELAY &&
                executeTime <= block.timestamp + MAX_DELAY,
            "TimeLock: Invalid execution time"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            !queuedTransactions[txHash],
            "TimeLock: Transaction already queued"
        );

        queuedTransactions[txHash] = true;
        emit QueueTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return txHash;
    }

    // 取消交易
    function cancelTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin {
        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        emit CancelTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
    }

    // 执行交易
    function executeTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public payable onlyAdmin returns (bytes memory) {
        require(
            block.timestamp >= executeTime,
            "TimeLock: Transaction hasn't surpassed time lock"
        );
        require(
            block.timestamp <= executeTime + GRACE_PERIOD,
            "TimeLock: Transaction is stale"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        bytes memory callData = bytes(signature).length == 0
            ? data
            : abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        (bool success, bytes memory returnData) = target.call{value: value}(
            callData
        );
        require(success, "TimeLock: Transaction execution reverted");

        emit ExecuteTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return returnData;
    }
}
```

编写测试合约：

```solidity
contract TestTimeLock {
    address public timeLock;

    event Log(string message);

    constructor(address _timeLock) {
        timeLock = _timeLock;
    }

    // 测试函数
    function test() public {
        require(msg.sender == timeLock, "Only timeLock can call");
        emit Log("Test");
    }

    // 辅助函数, 获取测试函数的执行时间
    function getExecutedTime() public view returns (uint) {
        return block.timestamp + 30;
    }
}
```

1. 部署 TimeLock 合约

2. 部署 TestTimeLock 合约，构造函数传入 `TimeLock 合约地址`

3. 调用 TestTimeLock 合约的 getExecutedTime 函数，获取执行时间 `executeTime`

4. 调用 TimeLock 合约的 queueTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，将 TestTimeLock 合约的 test 函数添加到时间锁队列中

5. 等待 `executeTime` 时间到达，调用 TimeLock 合约的 executeTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，执行 TestTimeLock 合约的 test 函数

6. 在未到达 `executeTime` 之前，可调用 TimeLock 合约的 cancelTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，取消 TestTimeLock 合约的 test 函数

<br><br>

# CSAMM

恒和自动市场制造商 (Constant Sum Automated Market Maker) 是一种去中心化交易协议，用于在区块链上实现自动化的代币交易。与常见的恒定乘积做市商（如 Uniswap）不同，CSAMM 使用恒定和公式来确定交易价格。

在 CSAMM 中，交易价格由以下公式决定：`x + y = k`，其中 `x` 和 `y` 分别代表池中的两种代币数量，`k` 是一个常数，表示池中两种代币数量的总和。

由于使用恒定和公式，CSAMM 在价格波动较小时表现较好，适用于稳定币之间的交易。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ConstantSumAMM {
    // 合约中两种代币的实例
    IERC20 public immutable tokenX;
    IERC20 public immutable tokenY;

    // 两种代币的总供应量
    uint public totalSupplyX;
    uint public totalSupplyY;

    // 池中总的流动性份额
    uint public totalSupply;

    // 记录每个用户的流动性份额
    mapping(address => uint) public balanceOf;

    // 初始化两种代币的实例
    constructor(address _tokenX, address _tokenY) {
        tokenX = IERC20(_tokenX);
        tokenY = IERC20(_tokenY);
    }

    // 发行新的代币
    function _mint(address to, uint amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    // 销毁代币
    function _burn(address from, uint amount) internal {
        totalSupply -= amount;
        balanceOf[from] -= amount;
    }

    // 在两种代币之间进行交换
    function swap(
        address _tokenIn,
        uint _amountIn
    ) external returns (uint amountOut) {
        require(
            _tokenIn == address(tokenX) || _tokenIn == address(tokenY),
            "Invalid token"
        );

        // 确定传入的代币为 tokenX 还是 tokenY
        bool isX = _tokenIn == address(tokenX);

        // 根据传入的代币确定两种代币的实例和总供应量
        (
            IERC20 tokenIn,
            IERC20 tokenOut,
            uint totalSupplyIn,
            uint totalSupplyOut
        ) = isX
                ? (tokenX, tokenY, totalSupplyX, totalSupplyY)
                : (tokenY, tokenX, totalSupplyY, totalSupplyX);

        // 用户将代币转移到合约中
        tokenIn.transferFrom(msg.sender, address(this), _amountIn);

        // 计算用户实际转移的代币数量
        uint amountIn = tokenIn.balanceOf(address(this)) - totalSupplyIn;

        // 计算用户可以获得的代币数量
        amountOut = (amountIn * 997) / 1000; // 0.3% 手续费

        // 更新两种代币的总供应量
        totalSupplyIn += amountIn;
        totalSupplyOut -= amountOut;

        // 将代币转移给用户
        tokenOut.transfer(msg.sender, amountOut);
    }

    // 向池中添加流动性，获得相应的份额
    function addLiquidity(
        uint amountX,
        uint amountY
    ) external returns (uint shares) {
        // 用户将代币转移到合约中
        tokenX.transferFrom(msg.sender, address(this), amountX);
        tokenY.transferFrom(msg.sender, address(this), amountY);

        // 计算用户实际转移的代币数量
        uint _amountX = tokenX.balanceOf(address(this)) - totalSupplyX;
        uint _amountY = tokenY.balanceOf(address(this)) - totalSupplyY;

        // 计算用户可以获得的份额
        if (totalSupply == 0) {
            // 对于第一次添加流动性的用户，直接按照转移的代币数量计算份额
            shares = _amountX + _amountY;
        } else {
            shares =
                ((_amountX + _amountY) * totalSupply) /
                (totalSupplyX + totalSupplyY);
        }

        // 发行份额给用户
        require(shares > 0, "Invalid shares");
        _mint(msg.sender, shares);

        // 更新两种代币的总供应量
        totalSupplyX += _amountX;
        totalSupplyY += _amountY;
    }

    // 根据持有的份额提取流动性
    function removeLiquidity(
        uint shares
    ) external returns (uint amountX, uint amountY) {
        // 计算用户可以获得的代币数量
        amountX = (shares * totalSupplyX) / totalSupply;
        amountY = (shares * totalSupplyY) / totalSupply;

        // 销毁用户的份额
        _burn(msg.sender, shares);

        // 更新两种代币的总供应量
        totalSupplyX -= amountX;
        totalSupplyY -= amountY;

        // 将代币转移给用户
        require(amountX > 0 && amountY > 0, "Invalid amount");
        tokenX.transfer(msg.sender, amountX);
        tokenY.transfer(msg.sender, amountY);
    }
}
```

编写测试合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint amount) external {
        _mint(to, amount);
    }
}
```

1. 部署两次 MyToken 合约，分别作为两种代币，这里分别命名为 `tokenX` 和 `tokenY`，符号分别为 `X` 和 `Y`

2. 部署 ConstantSumAMM 合约，传入 `tokenX` 和 `tokenY` 的地址

3. 调用 `tokenX` 合约的 mint 函数，传入编辑器地址和 `1000`，表示在 `tokenX` 合约中发行 `1000` 个代币

4. 调用 `tokenY` 合约的 mint 函数，传入编辑器地址和 `1000`，表示在 `tokenY` 合约中发行 `1000` 个代币

5. 调用 `tokenX` 合约的 approve 函数，传入 ConstantSumAMM 合约的地址和 `500`，表示授权 ConstantSumAMM 合约从 `tokenX` 合约中转移 `500` 个代币

6. 调用 `tokenY` 合约的 approve 函数，传入 ConstantSumAMM 合约的地址和 `800`，表示授权 ConstantSumAMM 合约从 `tokenY` 合约中转移 `800` 个代币

测试 addLiquidity：

1. 调用 ConstantSumAMM 合约的 addLiquidity 函数，传入 `400` 和 `600`，表示向 ConstantSumAMM 合约中添加 `400` 个 `tokenX` 和 `600` 个 `tokenY`，获得相应的份额

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `1000`、两种代币的总供应量 totalSupplyX 为 `400`、totalSupplyY 为 `600`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `1000`

3. 查看 `tokenX` 和 `tokenY` 合约的余额，可以看到用户的 `tokenX` 余额变成了 `600`、`tokenY` 余额变成了 `400`

测试 swap：

1. 调用 ConstantSumAMM 合约的 swap 函数，传入 `tokenX` 的地址和 `100`，表示用户用 `100` 个 `tokenX` 交换 `tokenY`，获得相应的代币数量

2. 查看 `tokenX` 和 `tokenY` 合约的余额，可以看到用户的 `tokenX` 余额变成了 `500`、`tokenY` 余额变成了 `499`，表示用户用 `100` 个 `tokenX` 交换了 `99` 个 `tokenY`

测试 removeLiquidity：

1. 调用 ConstantSumAMM 合约的 removeLiquidity 函数，传入 `500`，表示用户提取 `500` 份额的流动性，获得相应的代币数量

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `500`、两种代币的总供应量 totalSupplyX 为 `200`、totalSupplyY 为 `300`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `500`

3. 查看 `tokenX` 和 `tokenY` 合约的余额，可以看到用户的 `tokenX` 余额变成了 `700`、`tokenY` 余额变成了 `799`

<br><br>

# Oracle

预言机（Oracle）是一种机制，用于将外部世界的数据引入区块链。由于智能合约本身无法直接访问链外数据，预言机充当了区块链与外部数据源之间的桥梁，使得智能合约能够获取和验证与区块链无关的数据。

预言机通过监听智能合约中的事件或直接调用合约函数，将外部数据传递给智能合约。

预言机的类型：

1. 软件预言机：从在线数据源获取信息，如 API、网站等。

2. 硬件预言机：从物理设备获取数据，如传感器等。

3. 共识预言机：通过多个数据源和节点的共识来提供数据，确保数据的准确性和去中心化。

4. 输入预言机：将外部数据输入到智能合约中。

5. 输出预言机：从智能合约中获取数据并传递给外部系统。

<br><br>

# Awesome Project

当然可以！以下是包括 OpenZeppelin 在内的一些主要开源项目，它们提供智能合约开发、部署和管理的工具和库：

1. **OpenZeppelin**

-   简介：OpenZeppelin 提供了一系列用于开发、部署和管理智能合约的工具和库，专注于区块链安全。
-   特点：经过审计和社区验证的智能合约库，涵盖常见的 ERC 标准和其他实用合约。
-   用途：广泛应用于 DeFi、DAO 和代币发行等领域。

2. **Solmate**

-   简介：Solmate 提供了一组用于 Solidity 智能合约开发的开源构建模块，注重 Gas 优化。
-   特点：轻量级、高效、易于集成。
-   用途：适用于需要高效执行的智能合约开发。

3. **Solady**

-   简介：Solady 是 Solmate 的一个分支，专注于 Gas 优化的 Solidity 代码片段。
-   特点：进一步优化了 Gas 消耗，适用于需要极致性能的场景。
-   用途：适用于高频交易和复杂计算的智能合约。

4. **Solbase**

-   简介：Solbase 提供了一个现代化且 Gas 优化的智能合约开发基础库。
-   特点：模块化设计，易于扩展和维护。
-   用途：适用于各种智能合约开发需求。

5. **Gnosis Safe**

-   简介：Gnosis Safe 是一个多签名钱包解决方案，提供了安全的资产管理工具。
-   特点：支持多签名、模块化扩展、高度安全。
-   用途：适用于需要多方签名和高安全性的资产管理。

6. **Truffle Suite**

-   简介：Truffle 是一个开发框架，提供了智能合约编译、部署和测试工具。
-   特点：集成了 Ganache 和 Drizzle，支持全面的开发和测试流程。
-   用途：适用于全栈区块链开发，特别是以太坊生态系统。

7. **Hardhat**

-   简介：Hardhat 是一个以太坊开发环境，提供了智能合约编译、部署和调试工具。
-   特点：支持插件扩展、内置调试工具、与 Ethers.js 和 Waffle 集成。
-   用途：适用于需要灵活开发环境和高级调试功能的开发者。

8. **CertiK**

-   简介：CertiK 提供智能合约的安全审计和验证服务，确保合约的安全性和正确性。
-   特点：专业的安全审计团队、自动化验证工具。
-   用途：适用于需要高安全性和合约审计的项目。

9. **Quantstamp**

-   简介：Quantstamp 提供智能合约的自动化安全审计服务，帮助发现和修复潜在漏洞。
-   特点：自动化审计、详细的安全报告。
-   用途：适用于需要快速和全面安全审计的项目。

这些项目各有其特点和优势，开发者可以根据具体需求选择合适的工具和库。

<br><br>
