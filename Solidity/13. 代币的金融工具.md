# ERC20

ERC-20 是以太坊区块链上的一种代币标准，全称为 "Ethereum Request for Comment 20"。ERC-20 标准定义了一组通用的接口，使得代币可以在不同的应用程序和平台之间互操作。

ERC-20 标准包括以下核心方法：

```solidity
interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}
```

ERC-20 标准还定义了两个重要的事件：

-   `Transfer(address indexed from, address indexed to, uint value)`: 记录代币转移操作。
-   `Approval(address indexed owner, address indexed spender, uint value)`: 记录授权操作。

以下是一个简单的 ERC-20 代币合约示例：

```solidity
contract ERC20 is IERC20 {
    // 存储代币的名称、符号和小数位数
    string public name = "TestToken";
    string public symbol = "TTK";
    uint8 public decimals = 18; // 10^decimals 表示一个 "TestToken" 代币

    // 存储代币的总供应量
    uint public totalSupply;

    // 存储每个地址的代币余额; owner => balance
    mapping(address => uint) public balanceOf;

    // 存储每个地址对其他地址的授权额度; owner => spender => amount
    mapping(address => mapping(address => uint)) public allowance;

    // 定义两个事件，用于记录代币转移和授权操作
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint value
    );

    // 将 amount 数量的代币从调用者的账户转移到 recipient 账户
    function transfer(
        address recipient,
        uint amount
    ) external override returns (bool) {
        require(
            balanceOf[msg.sender] >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    // 授权 spender 可以从调用者的账户中转移最多 amount 数量的代币
    function approve(
        address spender,
        uint amount
    ) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 从 sender 账户转移 amount 数量的代币到 recipient 账户
    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external override returns (bool) {
        require(
            balanceOf[sender] >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        require(
            allowance[sender][msg.sender] >= amount,
            "ERC20: transfer amount exceeds allowance"
        );
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        allowance[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}
```

除了上述核心方法，你可能还听过 mint、burn 等方法，这些方法是 ERC-20 标准之外的扩展方法，用于增发和销毁代币。

```solidity
contract ERC20 is IERC20 {
    // ...

    // 增发 amount 数量的代币
    function mint(uint amount) external {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
    }

    // 销毁 amount 数量的代币
    function burn(uint amount) external {
        require(
            balanceOf[msg.sender] >= amount,
            "ERC20: burn amount exceeds balance"
        );
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}
```

如果 mint 方法没有适当的权限控制，可能会导致无限制地创建代币，进而引发通货膨胀和代币价值下降。如果 burn 方法没有适当的检查，可能会导致用户意外销毁大量代币，造成经济损失。为了防止这些风险，通常会在合约中加入权限控制和严格的检查机制。例如，只有合约所有者或经过授权的账户才能调用 mint 方法。

<br><br>

# 多签钱包

多签钱包（Multisig Wallet）是一种需要多个密钥持有者共同授权才能执行交易的数字钱包。常见的签名模式包括 2/3、3/5 等。例如，在 2/3 签名模式中，三个密钥中至少需要两个签名才能执行交易。

在创建多签钱包时，需要指定多个密钥持有者和最少签名数。例如，可以设置三个密钥持有者，并要求至少两个签名才能执行交易。任何一个密钥持有者可以提交交易请求，其他密钥持有者需要对交易进行签名和确认，当达到最少签名数时，交易将被执行。

以下是一个简单的多签钱包智能合约示例：

1. 先定义一些事件：

```solidity
contract MultiSigWallet {
    // 当 sender 把 amount 存入合约时触发
    event Deposit(address indexed sender, uint amount);

    // 当 txIndex 被提交时触发
    event Submit(uint indexed txIndex);

    // 当 owner 批准 txIndex 时触发
    event Approve(address indexed owner, uint indexed txIndex);

    // 当 owner 撤销 txIndex 时触发
    event Revoke(address indexed owner, uint indexed txIndex);

    // 当 txIndex 被执行时触发
    event Execute(uint indexed txIndex);
}
```

2. 定义交易的结构体：

```solidity
contract MultiSigWallet {
    // 交易的结构体
    struct Transaction {
        address to; // 接收地址
        uint value; // 金额
        bytes data; // 数据
        bool executed; // 是否已执行
    }
}
```

3. 定义一些状态变量：

```solidity
contract MultiSigWallet {
    // 交易
    Transaction[] public transactions;

    // owner 们
    address[] public owners;

    // owner => 是否为 owner
    mapping(address => bool) public isOwner;

    // 需要多少个 owner 批准, 交易才能被执行
    uint public numApprovalsRequired;

    // 交易被 owner 批准的情况; txIndex => owner => 是否批准
    mapping(uint => mapping(address => bool)) public isApproved;
}
```

4. 实现构造函数：

```solidity
contract MultiSigWallet {
    constructor(address[] memory _owners, uint _numApprovalsRequired) {
        require(_owners.length > 0, "owners required");
        require(
            _numApprovalsRequired > 0 &&
                _numApprovalsRequired <= _owners.length,
            "invalid number of required approvals"
        );

        for (uint i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "invalid owner");
            require(!isOwner[owner], "owner not unique");
            isOwner[owner] = true;
            owners.push(owner);
        }

        numApprovalsRequired = _numApprovalsRequired;
    }
}
```

5. 实现一些函数装饰器：

```solidity
contract MultiSigWallet {
    // 函数装饰器; 检查调用者是否为 owner, 是则继续
    modifier onlyOwner() {
        require(isOwner[msg.sender], "not owner");
        _;
    }

    // 函数装饰器; 检查交易是否存在, 存在则继续
    modifier txExists(uint _txIndex) {
        require(_txIndex < transactions.length, "tx does not exist");
        _;
    }

    // 函数装饰器; 检查交易是否已执行, 未执行则继续
    modifier notExecuted(uint _txIndex) {
        require(!transactions[_txIndex].executed, "tx already executed");
        _;
    }

    // 函数装饰器; 检查交易是否被 owner 批准, 未批准则继续
    modifier notApproved(uint _txIndex) {
        require(!isApproved[_txIndex][msg.sender], "tx already approved");
        _;
    }
}
```

6. 实现函数接收以太币：

```solidity
contract MultiSigWallet {
    // 接收以太币
    receive() external payable {
        emit Deposit(msg.sender, msg.value);
    }
}
```

7. 实现函数提交交易：

```solidity
contract MultiSigWallet {
    // 提交交易
    function submitTransaction(
        address _to,
        uint _value,
        bytes calldata _data
    ) external onlyOwner {
        uint txIndex = transactions.length;
        transactions.push(
            Transaction({to: _to, value: _value, data: _data, executed: false})
        );
        emit Submit(txIndex);
    }
}
```

8. 实现函数批准交易：

```solidity
contract MultiSigWallet {
    // 批准交易
    function approveTransaction(
        uint _txIndex
    )
        external
        onlyOwner
        txExists(_txIndex)
        notExecuted(_txIndex)
        notApproved(_txIndex)
    {
        isApproved[_txIndex][msg.sender] = true;
        emit Approve(msg.sender, _txIndex);
    }
}
```

9. 实现函数撤销批准：

```solidity
contract MultiSigWallet {
    // 撤销批准
    function revokeTransaction(
        uint _txIndex
    ) external onlyOwner txExists(_txIndex) notExecuted(_txIndex) {
        require(isApproved[_txIndex][msg.sender], "tx not approved");
        isApproved[_txIndex][msg.sender] = false;
        emit Revoke(msg.sender, _txIndex);
    }
}
```

10. 实现函数执行交易：

```solidity
contract MultiSigWallet {
    // helper function; 获取已批准的 owner 数量
    function _getApprovals(uint _txIndex) private view returns (uint) {
        uint approvals = 0;
        for (uint i = 0; i < owners.length; i++) {
            if (isApproved[_txIndex][owners[i]]) {
                approvals++;
            }
        }
        return approvals;
    }

    // 执行交易
    function executeTransaction(
        uint _txIndex
    ) external onlyOwner txExists(_txIndex) notExecuted(_txIndex) {
        require(
            _getApprovals(_txIndex) >= numApprovalsRequired,
            "cannot execute tx"
        );

        Transaction storage transaction = transactions[_txIndex];
        transaction.executed = true;

        (bool success, ) = transaction.to.call{value: transaction.value}(
            transaction.data
        );
        require(success, "tx failed");

        emit Execute(_txIndex);
    }
}
```

<br><br>

# 函数选择器

函数选择器（Function Selector）可以标识智能合约中的特定函数。主要用于智能合约的调用和交互。

<br>

## 函数选择器的生成

函数选择器通过对函数签名进行 Keccak-256 哈希计算得到的前 4 个字节。

函数签名由函数名称和参数类型组成，中间没有空格。例如，对于以下函数：

```solidity
function transfer(address recipient, uint amount) external returns (bool);
```

其函数签名为：

```
transfer(address,uint)
```

通过 Keccak-256 哈希计算得到的前 4 个字节就是该函数的选择器。

<br>

## 计算函数选择器

可以使用 Solidity 内置的 `selector` 属性或手动计算函数选择器。以下是两种方法的示例：

```solidity
bytes4 selector = this.transfer.selector;
bytes4 selector = bytes4(keccak256("transfer(address,uint)"));
```

<br>

## Demo

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Receiver {
    event Log(bytes data);

    function transfer(
        address to,
        uint amount
    ) public returns (address, uint) {
        emit Log(msg.data);
        return (to, amount);
    }
}

contract FunctionSelector {
    // 传入函数签名 transfer(address,uint)
    function getSelector(string memory signature) public pure returns (bytes4) {
        return bytes4(keccak256(bytes(signature)));
    }
}
```

1. 部署 Receiver、FunctionSelector 合约

2. 调用 Receiver 合约的 transfer 方法，这里我传入的参数是 `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` 和 `123`：

3. 查看 Log 事件，可以看到打印了：

```
0xa9059cbb0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000007b
```

4. 调用 FunctionSelector 合约的 getSelector 方法，传入函数签名 `transfer(address,uint)`，可以得到函数选择器：

```
0xa9059cbb // 可以看到和上面 Log 的前 4 个字节是一样的
```

5. 上面的 Log 中，剩下的部分是参数 `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` 和 `123` 的 16 进制转换结果。

<br><br>

# 荷兰式拍卖

荷兰式拍卖（Dutch Auction），也称为减价拍卖。

拍卖从一个较高的起始价格开始，这个价格通常高于市场预期。随着时间的推移，价格按照预先设定的降价阶梯逐步降低。当价格降到某个竞买人愿意接受的水平时，该竞买人出价并成交。第一个应价的竞买人获胜，并支付当时的价格。

1. 定义接口：

```solidity
interface IERC721 {
    function transferFrom(
        address _from,
        address _to,
        uint _tokenId
    ) external;
}
```

2. 定义状态变量：

```solidity
contract DutchAuction {
    // 拍卖的 NFT 合约地址
    IERC721 public immutable nft;

    // 拍卖的 NFT ID
    uint public immutable nftId;

    // 卖家地址
    address payable public immutable seller;

    // 拍卖的持续时间
    uint public constant DURATION = 7 days;

    // 起拍价
    uint public immutable startPrice;

    // 拍卖开始时间
    uint public immutable startTime;

    // 拍卖结束时间
    uint public immutable endTime;

    // 每天的降价幅度
    uint public immutable discountPerDay;
}
```

3. 实现构造函数：

```solidity
contract DutchAuction {
    constructor(
        uint _startPrice,
        uint _discountPerDay,
        address _nft,
        uint _tokenId
    ) {
        require(
            _startPrice >= _discountPerDay * DURATION,
            "start price must be greater than or equal to the end price"
        );

        seller = payable(msg.sender);
        startPrice = _startPrice;
        discountPerDay = _discountPerDay;
        startTime = block.timestamp;
        endTime = startTime + DURATION;
        nft = IERC721(_nft);
        nftId = _tokenId;
    }
}
```

4. 实现函数：

```solidity
contract DutchAuction {
    // 查询当前价格
    function getCurrentPrice() public view returns (uint) {
        uint timeElapsed = block.timestamp - startTime; // 已经过去的时间
        return startPrice - discountPerDay * timeElapsed; // 当前价格
    }

    // 购买
    function buy() public payable {
        require(block.timestamp >= startTime, "auction has not started yet");
        require(block.timestamp < endTime, "auction has ended");
        uint currentPrice = getCurrentPrice();
        require(msg.value >= currentPrice, "insufficient funds");

        nft.transferFrom(seller, msg.sender, nftId);
        uint refund = msg.value - currentPrice;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
    }
}
```

<br><br>

# 英式拍卖

英式拍卖（English Auction），也称为增价拍卖。

拍卖从一个较低的起拍价开始。竞买人按竞价阶梯逐步提高出价。每次出价必须高于当前最高出价。当没有人愿意再出更高的价格时，拍卖结束，出价最高者成为买受人。

1. 定义接口：

```solidity
interface IERC721 {
    function transferFrom(
        address _from,
        address _to,
        uint _tokenId
    ) external;
}
```

2. 定义事件：

```solidity
contract EnglishAuction {
    // 当拍卖开始时触发
    event Start();

    // 当有新的出价时触发
    event Bid(address indexed bidder, uint amount);

    // 当退款时触发
    event Refund(address indexed bidder, uint amount);

    // 当拍卖结束时触发
    event End(address highestBidder, uint highestBid);
}
```

3. 定义状态变量：

```solidity
contract EnglishAuction {
    // 拍卖的 NFT 合约地址
    IERC721 public immutable nft;

    // 拍卖的 NFT ID
    uint public immutable nftId;

    // 卖家地址
    address payable public immutable seller;

    // 拍卖结束时间
    uint public endTime;

    // 拍卖是否已开始
    bool public isStarted;

    // 拍卖是否已结束
    bool public isEnded;

    // 当前最高出价者
    address public highestBidder;

    // 当前最高出价
    uint public highestBid;

    // 出价记录
    mapping(address => uint) public bids;
}
```

4. 实现构造函数：

```solidity
contract EnglishAuction {
    // 构造函数
    constructor(IERC721 _nft, uint _nftId, uint _startBid) {
        nft = _nft;
        nftId = _nftId;
        seller = payable(msg.sender);
        highestBid = _startBid;
    }
}
```

5. 实现函数开始拍卖：

```solidity
contract EnglishAuction {
    // 开始售卖
    function startAuction() external {
        require(msg.sender == seller, "Only seller can start auction");
        require(!isStarted, "Auction already started");

        isStarted = true;
        endTime = block.timestamp + 7 days;
        nft.transferFrom(seller, address(this), nftId);

        emit Start();
    }
}
```

6. 实现函数出价：

```solidity
contract EnglishAuction {
    // 出价
    function bid() external payable {
        require(isStarted, "Auction not started");
        require(block.timestamp < endTime && !isEnded, "Auction ended");
        require(msg.sender != seller, "Seller cannot bid");
        require(msg.value > highestBid, "Bid must be higher than highest bid");

        if (highestBidder != address(0)) {
            bids[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }
}
```

7. 实现函数结束拍卖：

```solidity
contract EnglishAuction {
    // 结束拍卖
    function endAuction() external {
        require(isStarted, "Auction not started");
        require(!isEnded, "Auction already ended");
        require(block.timestamp >= endTime, "Auction not ended");

        isEnded = true;
        if (highestBidder != address(0)) {
            // 有人出价, 转移 NFT 和 ETH 给最高出价者
            nft.transferFrom(address(this), highestBidder, nftId);
            seller.transfer(highestBid);
        } else {
            // 无人出价, 退还 NFT 给卖家
            nft.transferFrom(address(this), seller, nftId);
        }

        emit End(highestBidder, highestBid);
    }
}
```

8. 实现函数退款：

```solidity
contract EnglishAuction {
    // 退款
    function refund() external {
        require(msg.sender != highestBidder, "Highest bidder cannot refund");

        uint amount = bids[msg.sender];
        bids[msg.sender] = 0;
        payable(msg.sender).transfer(amount);

        emit Refund(msg.sender, amount);
    }
}
```

<br>
