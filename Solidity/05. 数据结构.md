# Array

åœ¨ Solidity ä¸­ï¼ŒArray çš„ length å¯ä»¥æ˜¯åŠ¨æ€/å›ºå®šçš„ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // å›ºå®šé•¿åº¦çš„æ•°ç»„
    uint256[5] public fixedArray = [1, 2, 3, 4, 5];

    // åŠ¨æ€é•¿åº¦çš„æ•°ç»„
    uint256[] public dynamicArray = [1, 2, 3, 4, 5];
}
```

å¯¹åŠ¨æ€æ•°ç»„çš„å¢åˆ æ”¹æŸ¥ï¼š

```solidity
    // æ·»åŠ å…ƒç´ åˆ°åŠ¨æ€æ•°ç»„
    function addDynamicArray(uint256 _value) public {
        dynamicArray.push(_value);
    }

    // è·å–åŠ¨æ€æ•°ç»„çš„é•¿åº¦
    function getDynamicArrayLength() public view returns (uint256) {
        return dynamicArray.length;
    }

    // è·å–åŠ¨æ€æ•°ç»„çš„å…ƒç´ 
    function getDynamicArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return dynamicArray[_index];
    }

    // æ›´æ–°åŠ¨æ€æ•°ç»„çš„å…ƒç´ 
    function updateDynamicArrayElement(uint256 _index, uint256 _value) public {
        dynamicArray[_index] = _value;
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„å…ƒç´ 
    function deleteDynamicArrayElement(uint256 _index) public {
        delete dynamicArray[_index]; // æ³¨æ„: è¿™é‡Œæ˜¯å°†è¯¥å…ƒç´ é‡ç½®ä¸ºé»˜è®¤å€¼äº†, ä¸ä¼šæ”¹å˜æ•°ç»„çš„é•¿åº¦
    }
    // è‹¥æƒ³åˆ é™¤æŒ‡å®šå…ƒç´  åé¢çš„å…ƒç´ å¾€å‰ç§» (eg: [1, 2, 3] ğŸ‘‰ [1, 3]), å¯è¿™ä¹ˆå®ç°:
    function deleteNum(uint256 _index) public {
        for (uint i = _index; i < dynamicArray.length - 1; i++) {
            dynamicArray[i] = dynamicArray[i + 1];
        }
        dynamicArray.pop();
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    function popDynamicArray() public {
        dynamicArray.pop();
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
    function deleteAllDynamicArray() public {
        delete dynamicArray; // è¿™é‡Œæ˜¯å°†æ•°ç»„é‡ç½®ä¸ºç©ºæ•°ç»„äº†, æ•°ç»„é•¿åº¦å˜ä¸º 0
    }
```

å¯¹å›ºå®šæ•°ç»„çš„å¢åˆ æ”¹æŸ¥ï¼š

```solidity
    // æ·»åŠ å…ƒç´ åˆ°å›ºå®šæ•°ç»„
    function addFixedArray(uint256 _value) public {
        // fixedArray.push(_value); // å›ºå®šæ•°ç»„ä¸èƒ½ä½¿ç”¨ push æ–¹æ³•
    }

    // è·å–å›ºå®šæ•°ç»„çš„é•¿åº¦
    function getFixedArrayLength() public view returns (uint256) {
        return fixedArray.length;
    }

    // è·å–å›ºå®šæ•°ç»„çš„å…ƒç´ 
    function getFixedArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return fixedArray[_index];
    }

    // æ›´æ–°å›ºå®šæ•°ç»„çš„å…ƒç´ 
    function updateFixedArrayElement(uint256 _index, uint256 _value) public {
        fixedArray[_index] = _value;
    }

    // åˆ é™¤å›ºå®šæ•°ç»„çš„å…ƒç´ 
    function deleteFixedArrayElement(uint256 _index) public {
        delete fixedArray[_index]; // æ³¨æ„: è¿™é‡Œæ˜¯å°†è¯¥å…ƒç´ é‡ç½®ä¸ºé»˜è®¤å€¼äº†, ä¸ä¼šæ”¹å˜æ•°ç»„çš„é•¿åº¦
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    function popFixedArray() public {
        // fixedArray.pop(); // å›ºå®šæ•°ç»„ä¸èƒ½ä½¿ç”¨ pop æ–¹æ³•
    }

    // åˆ é™¤å›ºå®šæ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
    function deleteAllFixedArray() public {
        delete fixedArray; // æ³¨æ„: è¿™é‡Œæ˜¯å°†è¯¥å…ƒç´ é‡ç½®ä¸ºé»˜è®¤å€¼äº†, ä¸ä¼šæ”¹å˜æ•°ç»„çš„é•¿åº¦
    }
```

åœ¨å†…å­˜ä¸­åˆ›å»ºæ•°ç»„ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = new uint[](3); // [0, 0, 0]

    function getArr() public view returns (uint[] memory) {
        return arr;
    }
}
```

æ³¨æ„ï¼šâ‘  åªèƒ½åœ¨å†…å­˜ä¸­åˆ›å»ºå®šé•¿æ•°ç»„ï¼› â‘¡ åœ¨ Solidity ä¸­ï¼Œæˆ‘ä»¬å°½é‡ä¸è¦è¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„é•¿åº¦è¶Šå¤§ æ¶ˆè€—çš„ gas å°±è¶Šå¤šã€‚

å‡½æ•° demo - æ¥å—ä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªç´¢å¼•ä½œä¸ºå‚æ•°ï¼Œç§»é™¤ç´¢å¼•æŒ‡å®šçš„å…ƒç´ å¹¶è¿”å›æ–°æ•°ç»„ï¼š

```solidity
function removeAtIndex(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(arr.length > 0, "Array is empty");
    require(index < arr.length && index >= 0, "Index out of bounds");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < arr.length; i++) {
        if (i < index) {
            newArr[i] = arr[i];
        } else if (i > index) {
            newArr[i - 1] = arr[i];
        }
    }

    return newArr;
}
```

```solidity
function removeAtIndex2(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(index < arr.length && index >= 0, "Index out of bounds");
    require(arr.length > 0, "Array is empty");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < index; i++) {
        newArr[i] = arr[i];
    }

    for (uint i = index; i < arr.length - 1; i++) {
        newArr[i] = arr[i + 1];
    }

    return newArr;
}
```

å¦‚æœå¯ä»¥æ‰“ä¹±æ•°ç»„çš„é¡ºåºï¼ŒæŸäº›æƒ…å†µä¸‹å¯ä»¥è€ƒè™‘å°†æƒ³åˆ é™¤çš„å…ƒç´ ä¸æ•°ç»„æœ€åä¸€ä½å…ƒç´ äº¤æ¢ï¼Œç„¶åè°ƒç”¨ pop æ–¹æ³•ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = [1, 2, 3, 4, 5];

    function removeAtIndex(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        for (uint i = _index; i < arr.length - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr.pop();
    }

    function removeAtIndex2(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        arr[_index] = arr[arr.length - 1];
        arr.pop();
    }
}
```

<br><br>

# Mapping

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // å®šä¹‰ä¸€ä¸ª address => uint256 çš„ mapping
    mapping(address => uint256) public myBalance;

    // è·å– mapping å€¼
    function getMyBalance() public view returns (uint256) {
        return myBalance[msg.sender]; // è¿”å›è°ƒç”¨è€…çš„ä½™é¢; å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡, åˆ™è¿”å› uint256 çš„é»˜è®¤å€¼ 0
    }

    // æ·»åŠ /ä¿®æ”¹ mapping å€¼
    function setMyBalance(uint256 _amount) public {
        myBalance[msg.sender] += _amount; // å¢åŠ è°ƒç”¨è€…çš„ä½™é¢; å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡, åˆ™åŸºäº uint256 çš„é»˜è®¤å€¼ 0 è¿›è¡Œæ›´æ–°
    }

    // åˆ é™¤ mapping å€¼
    function deleteMyBalance() public {
        delete myBalance[msg.sender]; // åˆ é™¤è°ƒç”¨è€…çš„ä½™é¢; ä¼šå°†è°ƒç”¨è€…çš„ä½™é¢è®¾ç½®ä¸º uint256 çš„é»˜è®¤å€¼ 0
    }
}
```

mapping å¯ä»¥åµŒå¥—ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // å®šä¹‰ä¸€ä¸ªåµŒå¥—çš„ mapping
    mapping(address => mapping(address => uint256)) public allowance;

    // è·å–åµŒå¥— mapping å€¼
    function getAllowance(
        address _owner,
        address _spender
    ) public view returns (uint256) {
        return allowance[_owner][_spender]; // è¿”å› _owner å¯¹ _spender çš„æˆæƒé¢åº¦
    }

    // æ–°å¢/ä¿®æ”¹åµŒå¥— mapping å€¼
    function setAllowance(address _spender, uint256 _amount) public {
        allowance[msg.sender][_spender] = _amount; // è®¾ç½®è°ƒç”¨è€…å¯¹ _spender çš„æˆæƒé¢åº¦
    }

    // åˆ é™¤åµŒå¥— mapping å€¼
    function deleteAllowance(address _spender) public {
        delete allowance[msg.sender][_spender]; // åˆ é™¤è°ƒç”¨è€…å¯¹ _spender çš„æˆæƒé¢åº¦
    }
}
```

demo - ç®€å•çš„é“¶è¡Œè´¦æˆ·ç³»ç»Ÿï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract SimpleBank {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        // payable() is a function that converts an address to an address payable
        // transfer() is a function that sends ether to an address
    }

    function checkBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}
```

å®ç°å¯è¿­ä»£æ˜ å°„ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    mapping(address => uint) public balance;
    mapping(address => bool) public isCustomer;
    address[] public customers;

    function deposit(address _customer, uint _amount) public {
        balance[_customer] += _amount;
        if (!isCustomer[_customer]) {
            customers.push(_customer);
            isCustomer[_customer] = true;
        }
    }

    function getCustomerBalance(address _customer) public view returns (uint) {
        require(isCustomer[_customer], "Customer does not exist");
        return balance[_customer];
    }

    function getCustomerBalanceByIndex(uint _index) public view returns (uint) {
        require(_index < customers.length && _index >= 0, "Index out of bounds");
        return balance[customers[_index]];
    }
}
```

<br><br>

# Struct

åˆ›å»º Struct å®ä¾‹ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    struct Student {
        uint256 id;
        string name;
    }

    Student[] public students;

    function addStudent1(string memory _name) public {
        // æŒ‰å±æ€§é¡ºåºåˆ›å»º Struct å®ä¾‹, å¹¶æ·»åŠ åˆ°æ•°ç»„
        students.push(Student(students.length, _name));
    }

    function addStudent2(string memory _name) public {
        // æŒ‰å±æ€§ååˆ›å»º Struct å®ä¾‹, å¹¶æ·»åŠ åˆ°æ•°ç»„
        students.push(Student({id: students.length, name: _name}));
    }

    function addStudent3(string memory _name) public {
        // åˆ›å»º Struct å®ä¾‹, ä½†ä¸æŒ‡å®šå±æ€§å€¼, ä¼šä½¿ç”¨é»˜è®¤å€¼
        Student memory student;
        // è®¾ç½®å±æ€§å€¼
        student.id = students.length;
        student.name = _name;
        // æ·»åŠ åˆ°æ•°ç»„
        students.push(student);
    }
}
```

è®¿é—® Struct å®ä¾‹å±æ€§ï¼š

```solidity
function getStudentInfoByIndex(
    uint256 _index
) public view returns (uint256, string memory) {
    Student memory student = students[_index];
    // memory ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, å˜é‡å€¼å­˜å‚¨åœ¨å†…å­˜ä¸­; å‡½æ•°æ‰§è¡Œå®Œå, ä¼šé‡Šæ”¾å†…å­˜
    // ä¿®æ”¹ memory ä¿®é¥°çš„å˜é‡, ä¸ä¼šå½±å“æ•°ç»„çš„å€¼
    return (student.id, student.name);
}
```

ä¿®æ”¹ Struct å®ä¾‹å±æ€§ï¼š

```solidity
function updateStudentNameByIndex(
    uint256 _index,
    string memory _name
) public {
    Student storage student = students[_index];
    // storage ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, è¿™ä¸ªå˜é‡æ˜¯ä¸€ä¸ªå¼•ç”¨
    // ä¿®æ”¹ storage ä¿®é¥°çš„å˜é‡, ä¼šå½±å“æ•°ç»„çš„å€¼
    student.name = _name;
}
```

åˆ é™¤ Struct å®ä¾‹å±æ€§ & åˆ é™¤ Struct å®ä¾‹ï¼š

```solidity
function deleteStudentNameByIndex(uint256 _index) public {
    Student storage student = students[_index];
    // storage ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, è¿™ä¸ªå˜é‡æ˜¯ä¸€ä¸ªå¼•ç”¨
    // ä¿®æ”¹ storage ä¿®é¥°çš„å˜é‡, ä¼šå½±å“æ•°ç»„çš„å€¼
    delete student.name; // è¯¥ delete ä¼šå°†è¯¥å±æ€§å€¼é‡ç½®ä¸ºé»˜è®¤å€¼
}

function deleteStudentByIndex(uint256 _index) public {
    delete students[_index]; // è¯¥ delete ä¼šå°†è¯¥ Struct å®ä¾‹çš„å±æ€§å€¼éƒ½é‡ç½®ä¸ºé»˜è®¤å€¼
}
```

<br><br>

# Enum

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    enum State {
        PENDING, // (0)
        ACTIVE, // (1)
        INACTIVE // (2)
    }

    State public state; // é»˜è®¤å€¼ä¸º PENDING (0)

    function updateState(State _state) public {
        state = _state;
    }

    function resetState() public {
        delete state; // é‡ç½®ä¸ºé»˜è®¤å€¼ PENDING (0)
    }

    function getStateVal() public view returns (uint) {
        return uint(state); // å°† State æšä¸¾ç±»å‹è½¬ä¸ºæ•´æ•°ç±»å‹
    }

    function test() public {
        updateState(State.ACTIVE);
        require(state == State.ACTIVE, "state should be ACTIVE");

        updateState(State(2)); // å°†æ•´æ•°ç±»å‹è½¬ä¸º State æšä¸¾ç±»å‹, è¿™é‡Œè¡¨ç¤º INACTIVE
        require(state == State.INACTIVE, "state should be INACTIVE");

        resetState();
        require(state == State.PENDING, "state should be PENDING");
    }
}
```

<br>
