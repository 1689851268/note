# Array

在 Solidity 中，Array 的 length 可以是动态/固定的。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 固定长度的数组
    uint256[5] public fixedArray = [1, 2, 3, 4, 5];

    // 动态长度的数组
    uint256[] public dynamicArray = [1, 2, 3, 4, 5];
}
```

对动态数组的增删改查：

```solidity
    // 添加元素到动态数组
    function addDynamicArray(uint256 _value) public {
        dynamicArray.push(_value);
    }

    // 获取动态数组的长度
    function getDynamicArrayLength() public view returns (uint256) {
        return dynamicArray.length;
    }

    // 获取动态数组的元素
    function getDynamicArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return dynamicArray[_index];
    }

    // 更新动态数组的元素
    function updateDynamicArrayElement(uint256 _index, uint256 _value) public {
        dynamicArray[_index] = _value;
    }

    // 删除动态数组的元素
    function deleteDynamicArrayElement(uint256 _index) public {
        delete dynamicArray[_index]; // 注意: 这里是将该元素重置为默认值了, 不会改变数组的长度
    }
    // 若想删除指定元素 后面的元素往前移 (eg: [1, 2, 3] 👉 [1, 3]), 可这么实现:
    function deleteNum(uint256 _index) public {
        for (uint i = _index; i < dynamicArray.length - 1; i++) {
            dynamicArray[i] = dynamicArray[i + 1];
        }
        dynamicArray.pop();
    }

    // 删除动态数组的最后一个元素
    function popDynamicArray() public {
        dynamicArray.pop();
    }

    // 删除动态数组的所有元素
    function deleteAllDynamicArray() public {
        delete dynamicArray; // 这里是将数组重置为空数组了, 数组长度变为 0
    }
```

对固定数组的增删改查：

```solidity
    // 添加元素到固定数组
    function addFixedArray(uint256 _value) public {
        // fixedArray.push(_value); // 固定数组不能使用 push 方法
    }

    // 获取固定数组的长度
    function getFixedArrayLength() public view returns (uint256) {
        return fixedArray.length;
    }

    // 获取固定数组的元素
    function getFixedArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return fixedArray[_index];
    }

    // 更新固定数组的元素
    function updateFixedArrayElement(uint256 _index, uint256 _value) public {
        fixedArray[_index] = _value;
    }

    // 删除固定数组的元素
    function deleteFixedArrayElement(uint256 _index) public {
        delete fixedArray[_index]; // 注意: 这里是将该元素重置为默认值了, 不会改变数组的长度
    }

    // 删除动态数组的最后一个元素
    function popFixedArray() public {
        // fixedArray.pop(); // 固定数组不能使用 pop 方法
    }

    // 删除固定数组的所有元素
    function deleteAllFixedArray() public {
        delete fixedArray; // 注意: 这里是将该元素重置为默认值了, 不会改变数组的长度
    }
```

在内存中创建数组：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = new uint[](3); // [0, 0, 0]

    function getArr() public view returns (uint[] memory) {
        return arr;
    }
}
```

注意：① 只能在内存中创建定长数组； ② 在 Solidity 中，我们尽量不要返回一个数组，数组的长度越大 消耗的 gas 就越多。

函数 demo - 接受一个整数数组和一个索引作为参数，移除索引指定的元素并返回新数组：

```solidity
function removeAtIndex(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(arr.length > 0, "Array is empty");
    require(index < arr.length && index >= 0, "Index out of bounds");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < arr.length; i++) {
        if (i < index) {
            newArr[i] = arr[i];
        } else if (i > index) {
            newArr[i - 1] = arr[i];
        }
    }

    return newArr;
}
```

```solidity
function removeAtIndex2(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(index < arr.length && index >= 0, "Index out of bounds");
    require(arr.length > 0, "Array is empty");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < index; i++) {
        newArr[i] = arr[i];
    }

    for (uint i = index; i < arr.length - 1; i++) {
        newArr[i] = arr[i + 1];
    }

    return newArr;
}
```

如果可以打乱数组的顺序，某些情况下可以考虑将想删除的元素与数组最后一位元素交换，然后调用 pop 方法：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = [1, 2, 3, 4, 5];

    function removeAtIndex(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        for (uint i = _index; i < arr.length - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr.pop();
    }

    function removeAtIndex2(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        arr[_index] = arr[arr.length - 1];
        arr.pop();
    }
}
```

<br><br>

# Mapping

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 定义一个 address => uint256 的 mapping
    mapping(address => uint256) public myBalance;

    // 获取 mapping 值
    function getMyBalance() public view returns (uint256) {
        return myBalance[msg.sender]; // 返回调用者的余额; 如果没有设置过, 则返回 uint256 的默认值 0
    }

    // 添加/修改 mapping 值
    function setMyBalance(uint256 _amount) public {
        myBalance[msg.sender] += _amount; // 增加调用者的余额; 如果没有设置过, 则基于 uint256 的默认值 0 进行更新
    }

    // 删除 mapping 值
    function deleteMyBalance() public {
        delete myBalance[msg.sender]; // 删除调用者的余额; 会将调用者的余额设置为 uint256 的默认值 0
    }
}
```

mapping 可以嵌套：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 定义一个嵌套的 mapping
    mapping(address => mapping(address => uint256)) public allowance;

    // 获取嵌套 mapping 值
    function getAllowance(
        address _owner,
        address _spender
    ) public view returns (uint256) {
        return allowance[_owner][_spender]; // 返回 _owner 对 _spender 的授权额度
    }

    // 新增/修改嵌套 mapping 值
    function setAllowance(address _spender, uint256 _amount) public {
        allowance[msg.sender][_spender] = _amount; // 设置调用者对 _spender 的授权额度
    }

    // 删除嵌套 mapping 值
    function deleteAllowance(address _spender) public {
        delete allowance[msg.sender][_spender]; // 删除调用者对 _spender 的授权额度
    }
}
```

demo - 简单的银行账户系统：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract SimpleBank {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        // payable() is a function that converts an address to an address payable
        // transfer() is a function that sends ether to an address
    }

    function checkBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}
```

实现可迭代映射：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    mapping(address => uint) public balance;
    mapping(address => bool) public isCustomer;
    address[] public customers;

    function deposit(address _customer, uint _amount) public {
        balance[_customer] += _amount;
        if (!isCustomer[_customer]) {
            customers.push(_customer);
            isCustomer[_customer] = true;
        }
    }

    function getCustomerBalance(address _customer) public view returns (uint) {
        require(isCustomer[_customer], "Customer does not exist");
        return balance[_customer];
    }

    function getCustomerBalanceByIndex(uint _index) public view returns (uint) {
        require(_index < customers.length && _index >= 0, "Index out of bounds");
        return balance[customers[_index]];
    }
}
```

<br><br>

# Struct

创建 Struct 实例：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    struct Student {
        uint256 id;
        string name;
    }

    Student[] public students;

    function addStudent1(string memory _name) public {
        // 按属性顺序创建 Struct 实例, 并添加到数组
        students.push(Student(students.length, _name));
    }

    function addStudent2(string memory _name) public {
        // 按属性名创建 Struct 实例, 并添加到数组
        students.push(Student({id: students.length, name: _name}));
    }

    function addStudent3(string memory _name) public {
        // 创建 Struct 实例, 但不指定属性值, 会使用默认值
        Student memory student;
        // 设置属性值
        student.id = students.length;
        student.name = _name;
        // 添加到数组
        students.push(student);
    }
}
```

访问 Struct 实例属性：

```solidity
function getStudentInfoByIndex(
    uint256 _index
) public view returns (uint256, string memory) {
    Student memory student = students[_index];
    // memory 会告诉编译器, 变量值存储在内存中; 函数执行完后, 会释放内存
    // 修改 memory 修饰的变量, 不会影响数组的值
    return (student.id, student.name);
}
```

修改 Struct 实例属性：

```solidity
function updateStudentNameByIndex(
    uint256 _index,
    string memory _name
) public {
    Student storage student = students[_index];
    // storage 会告诉编译器, 这个变量是一个引用
    // 修改 storage 修饰的变量, 会影响数组的值
    student.name = _name;
}
```

删除 Struct 实例属性 & 删除 Struct 实例：

```solidity
function deleteStudentNameByIndex(uint256 _index) public {
    Student storage student = students[_index];
    // storage 会告诉编译器, 这个变量是一个引用
    // 修改 storage 修饰的变量, 会影响数组的值
    delete student.name; // 该 delete 会将该属性值重置为默认值
}

function deleteStudentByIndex(uint256 _index) public {
    delete students[_index]; // 该 delete 会将该 Struct 实例的属性值都重置为默认值
}
```

<br><br>

# Enum

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    enum State {
        PENDING, // (0)
        ACTIVE, // (1)
        INACTIVE // (2)
    }

    State public state; // 默认值为 PENDING (0)

    function updateState(State _state) public {
        state = _state;
    }

    function resetState() public {
        delete state; // 重置为默认值 PENDING (0)
    }

    function getStateVal() public view returns (uint) {
        return uint(state); // 将 State 枚举类型转为整数类型
    }

    function test() public {
        updateState(State.ACTIVE);
        require(state == State.ACTIVE, "state should be ACTIVE");

        updateState(State(2)); // 将整数类型转为 State 枚举类型, 这里表示 INACTIVE
        require(state == State.INACTIVE, "state should be INACTIVE");

        resetState();
        require(state == State.PENDING, "state should be PENDING");
    }
}
```

<br>
