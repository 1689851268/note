# 部署合约

我们可以通过合约的 creation code 部署合约，并获取合约地址。creation code = 合约代码 code 的长度 (占 32 byte) + 合约代码 code

实现合约部署功能需要在 Solidity 的内联汇编 `assembly { ... }` 里面调用 create 方法。

create 方法：`create(v, p, n)`；`v` 表示要发送的以太数量、`p` 是合约代码 code 的起始指针，用于告诉 Solidity 编译器合约代码 code 的起始位置、`n` 表示合约代码 code 的长度；create 方法会部署合约并返回合约地址。

注意 ①：在 Solidity 中 发送的以太数量用 `msg.value` 表示，但在汇编中 用 `callvalue()` 表示；注意 ②：deployDemo 方法的入参 `_creationCode` = 合约代码 code 的长度 (占 32 byte) + 合约代码 code，所以传入 `p` 时要跳过 32 byte，在汇编中可以通过 `add(_creationCode, 0x20)` 实现；注意 ③：合约代码 code 的长度 `n` 在汇编中可以用 `mload(_creationCode)` 获取。

```solidity
contract Demo {
    address public owner = msg.sender;
}

contract Helper {
    function getByteCode() public pure returns (bytes memory) {
        return type(Demo).creationCode; // 获取 Demo 合约的 creation code 并返回
    }
}

contract Proxy {
    function deployDemo(
        bytes memory _creationCode // 合约的 creation code
    ) public payable returns (address addr) {
        assembly {
            // 部署合约, 获取合约地址并返回
            addr := create(callvalue(), add(_creationCode, 0x20), mload(_creationCode))
        }
        // 检查合约地址的有效性
        require(addr != address(0), "Failed to deploy contract");
    }
}
```

1. 部署 Helper 合约、Proxy 合约

2. 执行 Helper 合约的 getByteCode 方法，得到 Demo 合约的 creation code

3. 将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

4. 通过控制台获取到 Demo 合约地址；通过 Demo 合约的地址添加 Demo 合约到 Remix

5. 检查 Demo 合约的 owner 是否为 Proxy 合约的地址

<br><br>

# 部署合约并传入参数

```solidity
contract Demo {
    address public owner = msg.sender;
    uint public count;

    constructor(uint _count) {
        count = _count;
    }
}

contract Helper {
    function getByteCode(uint _count) public pure returns (bytes memory) {
        return abi.encodePacked(type(Demo).creationCode, abi.encode(_count));
        // 用 encode 编码传入的参数; 用 encodePacked 包装 Demo 合约的 creation code 和编码后的参数; 返回结果
    }
}

contract Proxy {
    function deployDemo(
        bytes memory _creationCode
    ) public returns (address addr) {
        assembly {
            addr := create(callvalue(), add(_creationCode, 0x20), mload(_creationCode))
        }
        require(addr != address(0), "Failed to deploy contract");
    }
}
```

1. 部署 Helper 合约、Proxy 合约

2. 传入参数 \_count 到 Helper 合约的 getByteCode 方法并执行，得到 Demo 合约的 creation code

3. 将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

4. 通过控制台获取到 Demo 合约地址；通过 Demo 合约的地址添加 Demo 合约到 Remix

5. 检查 Demo 合约的 owner 是否为 Proxy 合约的地址、count 是否为步骤 2 中传入的参数

<br><br>

# 部署合约并传输以太

```solidity
contract Demo {
    address public owner = msg.sender;
    uint public value = msg.value;

    constructor() payable {} // 使用 payable 修饰构造方法, 以支持在部署合约时传输以太
}

contract Helper {
    function getByteCode() public pure returns (bytes memory) {
        return type(Demo).creationCode;
    }
}

contract Proxy {
    function deployDemo(
        bytes memory _creationCode
    ) public payable returns (address addr) {
        // 使用 payable 修饰方法, 以支持以太的传输
        assembly {
            addr := create(callvalue(), add(_creationCode, 0x20), mload(_creationCode))
        }
        require(addr != address(0), "Failed to deploy contract");
    }
}
```

1. 部署 Helper 合约、Proxy 合约

2. 执行 Helper 合约的 getByteCode 方法，得到 Demo 合约的 creation code

3. 设置以太数量、将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

4. 通过控制台获取到 Demo 合约地址；通过 Demo 合约的地址添加 Demo 合约到 Remix

5. 检查 Demo 合约的 owner 是否为 Proxy 合约的地址、value 是否为步骤 3 中传输的以太数量

<br>
