# 调用其他合约的方法

```solidity
contract Demo1 {
    // 方法 1: 通过地址调用
    function setDemo2X_1(address _demo2, uint _x) public {
        Demo2 demo2 = Demo2(_demo2);
        demo2.setX(_x);
    }

    // 方法 2: 通过合约实例调用
    function setDemo2X_2(Demo2 _demo2, uint _x) public {
        _demo2.setX(_x);
    }
}

contract Demo2 {
    uint public x;

    event Log(address caller, uint x);

    function setX(uint _x) public {
        x = _x;
        emit Log(msg.sender, x);
    }
}
```

1.  部署 Demo2 合约

2.  调用 Demo2 合约的 setX 方法，设置 x 值；查看 Demo2 合约的 x 值，可以看到 x 值被更新；查看 Log 事件，可以看到调用者地址为编辑器地址

3.  部署 Demo1 合约

4.  传入 Demo1 合约的地址和新 x 值，调用 Demo1 合约的 setDemo2X_1 方法；查看 Demo2 合约的 x 值，可以看到 x 值被更新；查看 Log 事件，可以看到调用者地址为 Demo1 合约地址

5.  传入 Demo1 合约的地址和新 x 值，调用 Demo1 合约的 setDemo2X_2 方法；查看 Demo2 合约的 x 值，可以看到 x 值被更新；查看 Log 事件，可以看到调用者地址为 Demo1 合约地址

<br>

调用的同时传输以太币：

```solidity
contract Demo1 {
    function setDemo2X(Demo2 _demo2, uint _x) public payable {
        _demo2.getEther{value: msg.value}(_x); // 要求: msg.value >= value 值;  这里设置成一样
    }
}

contract Demo2 {
    uint public x;
    uint public value;
    address public caller;

    function setX(uint _x) public payable {
        value = msg.value;
        caller = msg.sender;
        x = _x;
    }
}
```

1. 部署 Demo2 合约

2. 传入新 x 值，设置以太币数量，调用 Demo2 合约的 setX 方法；查看 Demo2 合约的 x 值、value 值、caller 值，可以看到 x 值被更新、value 值为设置的以太币数量、caller 值为编辑器地址

3. 部署 Demo1 合约

4. 传入 Demo2 合约的地址、新 x 值，设置以太币数量，调用 Demo1 合约的 setDemo2X 方法；查看 Demo2 合约的 x 值、value 值、caller 值，可以看到 x 值被更新、value 值为设置的以太币数量、caller 值为 Demo1 合约地址

<br><br>

# call 方法

call 是一个比较底层的方法，可以用来调用其他合约的函数 同时发送以太。

```solidity
contract TestCall {
    event Log(string _str, uint _num, uint _value, address _sender);

    function foo(
        string calldata _str,
        uint _num
    ) external payable returns (string memory, uint) {
        emit Log(_str, _num, msg.value ,msg.sender);
        return (_str, _num);
    }
}

contract Call {
    bytes public data;

    function testCall(address _addr) public payable {
        (bool success, bytes memory _data) = _addr.call{
            // 传输的以太数量; 若设置的以太数量小于该下限, 会报错
            value: 100,
            // gas 上限; 若消耗的 gas 大于该上限, 会报错
            gas: 500000
            // 传入 encodeWithSignature 包装后的调用数据; 第 1 参数是方法签名, 不能有空格, 不能用简写
        }(abi.encodeWithSignature("foo(string,uint256)", "call foo", 123));
        require(success, "call failed");
        data = _data; // 返回值 _data 是被调用合约的方法的返回值
    }
}
```

1. 部署 TestCall 合约

2. 传入字符串和数字，设置以太币数量，调用 TestCall 合约的 foo 方法；查看 Log 事件，可以看到传入的字符串、数字、以太币数量、调用者地址 (为编辑器地址)

3. 部署 Call 合约

4. 传入 TestCall 合约的地址，设置以太币数量，调用 Call 合约的 testCall 方法；查看 Call 合约的 data 值，可以看到 TestCall 合约的 foo 方法的返回值 (为 bytes 形式)；查看 Log 事件，可以看到传入的字符串、数字、以太币数量、调用者地址 (为 Call 合约地址)

<br><br>

# 委托调用

Delegate Call：在当前合约通过 delegatecall 借用其他合约的方法，更新当前合约的状态变量

```solidity
contract B {
    uint public num;
    address public sender;
    uint public value;

    function setVars(uint _num) public payable {
        num = _num;
        sender = msg.sender;
        value = msg.value;
    }
}

contract A {
    uint public num;
    address public sender;
    uint public value;

    function setVars1(address _contract, uint _num) public payable {
        // 搭配 encodeWithSignature
        (bool success1, ) = _contract.delegatecall(
            abi.encodeWithSignature("setVars(uint256)", _num)
        );
        require(success1, "delegatecall 1 failed");
    }

    function setVars2(address _contract, uint _num) public payable {
        // 搭配 encodeWithSelector
        (bool success2, ) = _contract.delegatecall(
            abi.encodeWithSelector(B.setVars.selector, _num)
        );
        require(success2, "delegatecall 2 failed");
    }
}
```

1. 部署 B 合约

2. 传入数字，设置以太币数量，调用 B 合约的 setVars 方法；可以看到 B 合约的 num 被更新为传入的数字、sender 为编辑器地址、value 为设置的以太币数量

3. 部署 A 合约

4. 传入 B 合约的地址、数字，设置以太币数量，调用 A 合约的 setVars 方法；可以看到 A 合约的 num 被更新为传入的数字、sender 为编辑器地址、value 为设置的以太币数量

使用 delegatecall 后，只要 B 合约更新、升级了，A 合约就能跟着升级 而无需更新代码，非常方便~

<br><br>

# Multi Call

Multi Call 表示在单个交易中调用多个合约函数。

Multi Call 合约通过循环调用多个目标合约的函数，并将结果聚合返回。每个函数调用使用 staticcall，这是一种低级调用方式，不会改变区块链状态。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestMultiCall {
    function func1() external view returns (uint, uint) {
        return (1, block.timestamp);
    }

    function func2() external view returns (uint, uint) {
        return (2, block.timestamp);
    }

    // 返回调用 func1 函数所需的编码数据
    function getFunc1Data() external pure returns (bytes memory) {
        // 使用 abi.encodeWithSelector 编码 func1 函数的选择器, 并返回编码数据
        return abi.encodeWithSelector(this.func1.selector);
    }

    // 返回调用 func2 函数所需的编码数据
    function getFunc2Data() external pure returns (bytes memory) {
        // 使用 abi.encodeWithSelector 编码 func2 函数的选择器, 并返回编码数据
        return abi.encodeWithSelector(this.func2.selector);
    }
}

contract MultiCall {
    function aggregate(
        address[] calldata targets, // 要调用的目标合约地址
        bytes[] calldata data // 每个目标合约的调用数据
    ) external view returns (bytes[] memory) {
        require(targets.length == data.length, "MultiCall: invalid input");
        bytes[] memory results = new bytes[](targets.length);
        for (uint i = 0; i < targets.length; i++) {
            (bool success, bytes memory result) = targets[i].staticcall(
                data[i]
            );
            require(success, "MultiCall: staticcall failed");
            results[i] = result;
        }
        return results;
    }
}
```

1. 部署 TestMultiCall、MultiCall 合约

2. 调用 TestMultiCall 的 getFunc1Data、getFunc2Data 方法，获取调用 func1、func2 函数所需的编码数据

3. 调用 MultiCall 的 aggregate 方法，传入 `["TestMultiCall 合约地址", "TestMultiCall 合约地址"]` 和 `["getFunc1Data 返回的编码数据", "getFunc2Data 返回的编码数据"]`，获取的调用结果应该为 `[bytes 格式的 func1 的返回值, bytes 格式的 func2 的返回值]`

4. 观察返回结果，可以看到 func1、func2 函数返回相同的时间戳

<br><br>

# Multi Delegate Call

Multi Delegate Call 允许在单个交易中调用多个合约函数，并在调用过程中共享调用者的上下文。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiDelegateCall {
    function multiDelegateCall(
        bytes[] calldata data
    ) external payable returns (bytes[] memory results) {
        results = new bytes[](data.length);
        for (uint i = 0; i < data.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(
                data[i]
            );
            require(success, "Delegate call failed");
            results[i] = result;
        }
    }
}

contract TestMultiDelegateCall is MultiDelegateCall {
    event Log(address caller, string funcName, uint value);

    function func1(uint x, uint y) external {
        emit Log(msg.sender, "func1", x + y);
    }

    function func2() external returns (uint) {
        emit Log(msg.sender, "func2", 123);
        return 123;
    }
}

contract Helper {
    function getFunc1Data(uint x, uint y) external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegateCall.func1.selector, x, y);
    }

    function getFunc2Data() external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegateCall.func2.selector);
    }
}
```

1. 部署 Helper、TestMultiDelegateCall 合约

2. 调用 Helper 的 getFunc1Data、getFunc2Data 方法，获取调用 func1、func2 函数所需的编码数据 func1Data、func2Data

3. 调用 TestMultiDelegateCall 继承的 multiDelegateCall 方法，传入 `["func1Data", "func2Data"]`，获取调用结果，应该返回 `[bytes 格式的 func1 的返回值, bytes 格式的 func2 的返回值]`

4. 观察返回结果，可以看到 `bytes 格式的 func1 的返回值` 为 `0x`，这是因为 func1 函数没有返回值

5. 查看 TestMultiDelegateCall 的事件日志，可以看到 func1、func2 函数的调用者是编辑器地址

<br>

在传输以太时需要注意传输的数量，以免出现不合预期的情况：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiDelegateCall {
    function multiDelegateCall(
        bytes[] calldata data
    ) external payable returns (bytes[] memory results) {
        results = new bytes[](data.length);
        for (uint i = 0; i < data.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(
                data[i]
            );
            require(success, "Delegate call failed");
            results[i] = result;
        }
    }
}

contract TestMultiDelegateCall is MultiDelegateCall {
    mapping(address => uint) public balanceOf;

    function mint() external payable {
        balanceOf[msg.sender] += msg.value;
    }
}

contract Helper {
    function getMintData() external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegateCall.mint.selector);
    }
}
```

1. 部署 Helper、TestMultiDelegateCall 合约

2. 调用 Helper 的 getMintData 方法，获取调用 mint 函数所需的编码数据 mintData

3. 调用 TestMultiDelegateCall 继承的 multiDelegateCall 方法，传入 `["mintData", "mintData", "mintData"]`，设置以太数为 1 wei

4. 用编辑器地址查看 TestMultiDelegateCall 合约的 balanceOf，可以看到以太数为 3 wei

<br><br>

# 新建合约

我们可以编写一个工厂合约，用于创建其他合约：

```solidity
contract Account {
    address public caller;
    address public creator;
    uint public value;

    constructor(address _creator) payable {
        caller = msg.sender;
        value = msg.value;
        creator = _creator;
    }
}

contract AccountFactory {
    Account[] public accounts;

    function createAccount(address _creator) public payable {
        // 创建合约并传输以太币;  要求 msg.value >= 111
        Account newAccount = new Account{value: 111}(_creator);
        accounts.push(newAccount);
    }
}
```

1.  部署 AccountFactory 合约

2.  传入编辑器地址，设置以太币数量，调用 AccountFactory 合约的 createAccount 方法；查看 accounts 的第 1 个元素，可以看到新创建的 Account 合约地址

3.  通过 Account 合约地址，将 Account 合约添加到 Remix 中

4.  点开新创建的 Account 合约，可以看到 creator 为编辑器地址、caller 为 AccountFactory 合约地址、value 为设置的以太币数量

<br><br>

# interface

```solidity
contract Counter {
    uint public count;

    function increment() public {
        count += 1;
    }
}

contract MyContract {
    // 通过地址调用 Counter 合约的 increment 方法
    function incrementCounter(address _counter) public {
        Counter(_counter).increment();
    }

    // 通过地址获取 Counter 合约的状态变量 count
    function getCount(address _counter) public view returns (uint) {
        return Counter(_counter).count();
    }
}
```

如果我们不知道 Counter 里面的代码，我们就需要使用接口：

```solidity
interface ICounter {
    function increment() external;

    function count() external view returns (uint);
}

contract MyContract {
    function incrementCounter(address _counter) public {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) public view returns (uint) {
        return ICounter(_counter).count();
    }
}
```

<br><br>

# library

1.  library 不能拥有自己的状态变量

2.  推荐使用 internal 修饰 library 的方法，这样 我们在部署合约时，library 的方法就能内嵌到合约中；如果使用 public 修饰 library 的方法，则需要单独部署 library；如果使用 private / external 修饰 library 的方法，则无法在合约中调用 library 的方法

使用方式 1：

```solidity
library Math {
    function max(uint a, uint b) internal pure returns (uint) {
        return a >= b ? a : b;
    }
}

contract Test {
    function test() public pure returns (uint) {
        return Math.max(1, 2); // 通过库名 Math 调用里面的方法 max
    }
}
```

使用方式 2：

```solidity
library ArrayLib {
    function findIndex(
        uint[] memory arr,
        uint value
    ) internal pure returns (int) {
        for (uint i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return int(i);
            }
        }
        return -1;
    }
}

contract Test {
    using ArrayLib for uint[]; // 通过库名 ArrayLib 增强类型 uint[]

    uint[] public arr = [1, 2, 3, 4, 5];

    function findIndex(uint value) public view returns (int) {
        return arr.findIndex(value); // uint[] 类型的变量可直接调用 ArrayLib 里面的方法 findIndex
    }
}
```

<br>
