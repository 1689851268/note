# 继承

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Father {
    function getNumber() public pure returns (uint) {
        return 10;
    }

    function getNumber2() public pure virtual returns (uint) {
        return 20;
    }
}

contract Son is Father {}
```

现在 Son 就可以调用 Father 的 getNumber、getNumber2 方法啦

<br><br>

# 函数重写

对于父合约中用 virtual 修饰的方法，可以在子合约中改用 override 修饰 并重写方法的内容：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Father {
    function getNumber() public pure returns (uint) {
        return 10;
    }

    function getNumber2() public pure virtual returns (uint) {
        return 20;
    }
}

contract Son is Father {
    function getNumber2() public pure override returns (uint) {
        return 40;
    }
}
```

<br><br>

# 多级继承

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Father {
    function getNumber() public pure returns (uint) {
        return 10;
    }

    function getNumber2() public pure virtual returns (uint) {
        return 20;
    }

    function getNumber3() public pure virtual returns (uint) {
        return 30;
    }
}

contract Son is Father {
    function getNumber2() public pure override returns (uint) {
        return 40;
    }

    // 用 virtual override 修饰方法
    function getNumber3() public pure virtual override returns (uint) {
        return 50;
    }
}

contract GrandSon is Son {
    function getNumber3() public pure override returns (uint) {
        return 60;
    }
}
```

<br><br>

# 多重继承

分析继承顺序的原则：优先最上层

```
   X
 / |
Y  |
 \ |
   Z

```

分析：X 在最上层，所以最优先；Y 继承 X，而 Z 既继承 X 又继承 Y，所以 Y 的优先级高于 Z

继承顺序：X、Y、Z

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract X {
    function foo() public pure virtual returns (string memory) {
        return "X";
    }

    function bar() public pure virtual returns (string memory) {
        return "X";
    }

    function x() public pure returns (string memory) {
        return "X";
    }
}

contract Y is X {
    function foo() public pure virtual override returns (string memory) {
        return "Y";
    }

    function bar() public pure virtual override returns (string memory) {
        return "Y";
    }

    function y() public pure returns (string memory) {
        return "Y";
    }
}

contract Z is X, Y {
    // 根据继承顺序, 先 X 后 Y;  若遇平级, 则顺序随意

    // override 里面的顺序无所谓
    function foo() public pure override(X, Y) returns (string memory) {
        return "Z";
    }

    function bar() public pure override(Y, X) returns (string memory) {
        return "Z";
    }
}
```

<br>

```
  X
 / \
Y   A
|   |
|   B
 \ /
  Z
```

分析：X 在最上层，所以最优先；Y A 都继承 X，但 A 被更多的合约继承，所以 Y 的优先级高于 A；B 继承 A，Z 继承 Y 和 B，所以 Y 的优先级高于 Z

顺序：X、Y、A、B、Z

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract X {
    function func() public pure virtual returns (string memory) {
        return "X";
    }

    function x() public pure returns (string memory) {
        return "X";
    }
}

contract Y is X {
    function func() public pure virtual override returns (string memory) {
        return "Y";
    }

    function y() public pure returns (string memory) {
        return "Y";
    }
}

contract A is X {
    function func() public pure virtual override returns (string memory) {
        return "A";
    }

    function a() public pure returns (string memory) {
        return "A";
    }
}

contract B is A {
    function func() public pure virtual override returns (string memory) {
        return "B";
    }

    function b() public pure returns (string memory) {
        return "B";
    }
}

contract Z is Y, B {
	// 根据继承顺序, 先 Y 后 B

    function func() public pure override(Y, B) returns (string memory) {
        return "Z";
    }

    function z() public pure returns (string memory) {
        return "Z";
    }
}
```

<br><br>

# 调用父合约的构造函数

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract A {
    string public name;

    constructor(string memory _name) {
        name = _name;
    }
}

contract B {
    uint public number;

    constructor(uint _number) {
        number = _number;
    }
}

// demo 1 - 在构造函数后面调用基类构造函数
contract C is A, B {
    constructor(string memory _name, uint _number) A(_name) B(_number) {}
}

// demo 2 - 在合约定义时调用基类构造函数
contract D is A("Hello"), B(42) {}

// demo 3 - 混合使用方法 1 和方法 2
contract E is A("Hello"), B {
    constructor(uint _number) B(_number) {}
}
```

构造函数的调用顺序：先继承的父合约 → 后继承的父合约 → 当前合约

demo 1 是 A → B → C、 demo 2 是 A → B → D、 demo 3 是 A → B → E

<br><br>

# 调用父合约的方法

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract A {
    event Log(string message);

    function func() public virtual {
        emit Log("A.func");
    }
}

contract B is A {
    function func() public virtual override {
        emit Log("B.func");
        // 方法 1 - 通过 super 调用
        super.func(); // A
    }
}

contract C is A {
    function func() public virtual override {
        emit Log("C.func");
        // 方法 2 - 通过合约调用
        A.func(); // A
    }
}

contract D is B, C {
	// 方法 1 和方法 2 的区别

    function func() public override(B, C) {
        C.func(); // C - A
        B.func(); // B - A
        A.func(); // A
    }

    function funcD() public {
        super.func(); // C - B - A
    }
}
```

<br>
