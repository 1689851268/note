# 数据的编码与解码

1. `abi.encode`：将给定的参数按照 ABI（应用二进制接口）规则编码成字节数组。编码后的数据总是 32 字节的倍数，不足 32 字节的部分会自动填充。适用于合约调用和数据传输。
2. `abi.encodePacked`：与 `abi.encode` 类似。不同的是，它生成的字节数组是压缩过的，不会自动填充到 32 字节的倍数。适用于生成紧凑数据和哈希计算。
3. `abi.decode`：将 `abi.encode` 返回的字节数组解码成原始数据。需要提供数据的类型信息。适用于解析从其他合约接收到的数据。

```solidity
contract ABIExample {
    uint num = 1;
    address addr = 0x1234567890123456789012345678901234567890;
    string str = "Hello, World!";

    function encodeData() external view returns (bytes memory) {
        return abi.encode(num, addr, str);
    }

    function decodePackedData() external view returns (bytes memory) {
        return abi.encodePacked(num, addr, str);
    }

    function decodeData(
        bytes memory data
    ) external pure returns (uint, address, string memory) {
        (uint a, address b, string memory c) = abi.decode(
            data,
            (uint, address, string)
        );
        return (a, b, c);
    }
}
```

1. 部署 ABIExample 合约

2. 调用 encodeData 方法，获取 num、addr、str 的编码数据

3. 调用 decodePackedData 方法，获取 num、addr、str 的压缩编码数据，可以看到数据是紧凑的

4. 传入步骤 2 中获取的编码数据，调用 decodeData 方法，解码数据，可以看到 num、addr、str 的原始数据

<br><br>

# 函数指针、函数签名、函数选择器

函数指针、函数签名、函数选择器均用于标识函数。

<br>

**函数指针**：指向函数的指针变量，可以用来调用函数

```solidity
contract Demo {
    uint public num;
    string public str;

    function update(
        uint _num,
        string calldata _str
    ) public returns (uint, string memory) {
        num += _num;
        str = _str;
        return (num, str);
    }
}

contract Test {
    event Log(uint num, string str);

    function callDemoUpdate(
        address _demo,
        uint _num,
        string calldata _str
    ) public {
        // 通过函数指针调用 Demo 合约的 update 函数
        (uint num, string memory str) = Demo(_demo).update(_num, _str);
        emit Log(num, str);
    }
}
```

1. 部署 Demo 合约、Test 合约

2. 传入 Demo 合约的地址、数字、字符串（这里设置为 10 和 "Hello"），调用 Test 合约的 callDemoUpdate 方法

3. 查看 Demo 合约的 num、str 值，可以看到 num 值加 10、str 值为 "Hello"

4. 查看 Log 事件，可以看到 Demo 合约的 num、str 值

<br>

**函数签名**：由函数名称和参数类型组成的字符串

上例的函数签名为 `update(uint256,string)`，不能有空格、不能用简写。

<br>

**函数选择器**：函数签名的前 4 个字节

获取方法 1：`bytes4(keccak256("update(uint256,string)"))`
获取方法 2：`Demo(_demo).update.selector`

<br><br>

# call 方法 & 函数调用数据

`call` 方法是一个低级函数，能通过 "函数调用数据" 与其他合约进行交互。

有 3 个方法获取 "函数调用数据"：

1. `abi.encodeCall` 将**函数指针**和参数编码成字节数组，并进行参数类型检查
2. `abi.encodeWithSignature`：将**函数签名**和参数编码成字节数组
3. `abi.encodeWithSelector`：将**函数选择器**和参数编码成字节数组

以上 3 种方法返回的字节数组即 "函数调用数据"。

```solidity
contract Demo {
    uint public num;
    string public str;

    function update(
        uint _count,
        string calldata _str
    ) public returns (uint, string memory) {
        num += _count;
        str = _str;
        return (num, str);
    }
}

contract Test {
    event Log(uint num, string str);

    function callDemoUpdateByPointer(
        address _demo,
        uint _count,
        string calldata _str
    ) public {
    	// call 搭配 encodeCall 调用 Demo 合约的 update 函数
        (bool success, bytes memory data) = _demo.call(
            abi.encodeCall(Demo(_demo).update, (_count, _str))
        );
        require(success, "call failed");
        (uint num, string memory str) = abi.decode(data, (uint, string));
        emit Log(num, str);
    }

    function callDemoUpdateBySignature(
        address _demo,
        uint _count,
        string calldata _str
    ) public {
        // call 搭配 encodeWithSignature 调用 Demo 合约的 update 函数
        (bool success, bytes memory data) = _demo.call(
            abi.encodeWithSignature("update(uint256,string)", _count, _str)
        );
        require(success, "call failed");
        (uint num, string memory str) = abi.decode(data, (uint, string));
        emit Log(num, str);
    }

    function callDemoUpdateBySelector(
        address _demo,
        uint _count,
        string calldata _str
    ) public {
        bytes4 selector1 = bytes4(keccak256("update(uint256,string)"));
        bytes4 selector2 = Demo(_demo).update.selector;
        // call 搭配 encodeWithSelector 调用 Demo 合约的 update 函数
        (bool success, bytes memory data) = _demo.call(
            abi.encodeWithSelector(selector1, _count, _str)
        );
        require(success, "call failed");
        (uint num, string memory str) = abi.decode(data, (uint, string));
        emit Log(num, str);
    }
}
```

1.  部署 Demo 合约、Test 合约

2.  传入 Demo 合约的地址、数字、字符串（这里设置为 10 和 "Hello"），调用 Test 合约的 callDemoUpdateByPointer / callDemoUpdateBySignature / callDemoUpdateBySelector 方法

3.  查看 Demo 合约的 num、str 值，可以看到 num 值加 10、str 值为 "Hello"

4.  查看 Log 事件，可以看到 Demo 合约的 num、str 值

<br><br>

# 调用函数并传输以太

现有如下合约：

```solidity
contract Demo {
    uint public balance;
    uint public num;
    string public str;

    function update(
        uint _num,
        string calldata _str
    ) public payable returns (uint, string memory) {
        balance += msg.value;
        num += _num;
        str = _str;
        return (num, str);
    }
}
```

<br>

用**函数指针**调用方法时：

```solidity
contract Test {
    event Log(uint num, string str);

    function callDemoUpdate(
        address _demo,
        uint _num,
        string calldata _str
    ) public payable {
        // 通过函数指针调用 Demo 合约的 update 函数并传输以太币
        // 配置项 value 为传输的以太币数量下限，这里设置为 msg.value
        (uint num, string memory str) = Demo(_demo).update{value: msg.value}(
            _num,
            _str
        );
        emit Log(num, str);
    }
}
```

1.  部署 Demo 合约、Test 合约

2.  传入 Demo 合约的地址、数字、字符串（这里设置为 10 和 "Hello"），设置以太币数量（这里设置为 100），调用 Test 合约的 callDemoUpdate 方法

3.  查看 Demo 合约的 balance、num、str 值，可以看到 balance 值加 100、num 值加 10、str 值为 "Hello"

4.  查看 Log 事件，可以看到 Demo 合约的 num、str 值

<br>

用 **call** 调用方法时：

```solidity
contract Test {
    event Log(uint num, string str);

    function callDemoUpdateBySignature(
        address _demo,
        uint _num,
        string calldata _str
    ) public payable {
        // 通过 call 调用 Demo 合约的 update 函数并传输以太币
        (bool success, bytes memory data) = _demo.call{
            value: 200, // 配置项 value 为传输的以太币数量下限，这里设置为 200
            gas: 500000 // 配置项 gas 为消耗的 gas 上限，这里设置为 500000
        }(abi.encodeWithSignature("update(uint256,string)", _num, _str));
        require(success, "call failed");
        (uint num, string memory str) = abi.decode(data, (uint, string));
        emit Log(num, str);
    }
}
```

1.  部署 Demo 合约、Test 合约

2.  传入 Demo 合约的地址、数字、字符串（这里设置为 10 和 "Hello"），设置以太币数量（这里设置为 200），调用 Test 合约的 callDemoUpdateBySignature 方法

3.  查看 Demo 合约的 balance、num、str 值，可以看到 balance 值加 200、num 值加 10、str 值为 "Hello"

4.  查看 Log 事件，可以看到 Demo 合约的 num、str 值

<br><br>

# Interface

接口（Interface）用于定义合约之间的交互标准，确保不同合约之间可以互操作。

1.  接口不能定义状态变量
2.  接口只声明函数的签名，而不包含函数的实现；所有函数必须声明为 `external`；不能包含构造函数
3.  接口可以继承其他接口，但不能继承合约。

现有如下合约交互：

```solidity
contract Counter {
    uint public count;

    function increment() public {
        count += 1;
    }
}

contract MyContract {
    // 通过地址调用 Counter 合约的 increment 方法
    function incrementCounter(address _counter) public {
        Counter(_counter).increment();
    }

    // 通过地址获取 Counter 合约的状态变量 count
    function getCount(address _counter) public view returns (uint) {
        return Counter(_counter).count();
    }
}
```

使用接口：

```solidity
interface ICounter {
    function increment() external;

    function count() external view returns (uint);
}

contract MyContract {
    function incrementCounter(address _counter) public {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) public view returns (uint) {
        return ICounter(_counter).count();
    }
}
```

<br><br>
