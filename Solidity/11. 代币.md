# ERC20

ERC-20 是以太坊区块链上的一种代币标准，全称为 "Ethereum Request for Comment 20"。ERC-20 标准定义了一组通用的接口，使得代币可以在不同的应用程序和平台之间互操作。

ERC-20 标准包括以下核心方法：

```solidity
interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}
```

ERC-20 标准还定义了两个重要的事件：

-   `Transfer(address indexed from, address indexed to, uint value)`: 记录代币转移操作。
-   `Approval(address indexed owner, address indexed spender, uint value)`: 记录授权操作。

以下是一个简单的 ERC-20 代币合约示例：

```solidity
contract ERC20 is IERC20 {
    // 存储代币的名称、符号和小数位数
    string public name = "TestToken";
    string public symbol = "TTK";
    uint8 public decimals = 18; // 10^decimals 表示一个 "TestToken" 代币

    // 存储代币的总供应量
    uint public totalSupply;

    // 存储每个地址的代币余额; owner => balance
    mapping(address => uint) public balanceOf;

    // 存储每个地址对其他地址的授权额度; owner => spender => amount
    mapping(address => mapping(address => uint)) public allowance;

    // 定义两个事件，用于记录代币转移和授权操作
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint value
    );

    // 将 amount 数量的代币从调用者的账户转移到 recipient 账户
    function transfer(
        address recipient,
        uint amount
    ) external override returns (bool) {
        require(
            balanceOf[msg.sender] >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    // 授权 spender 可以从调用者的账户中转移最多 amount 数量的代币
    function approve(
        address spender,
        uint amount
    ) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 从 sender 账户转移 amount 数量的代币到 recipient 账户
    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external override returns (bool) {
        require(
            balanceOf[sender] >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        require(
            allowance[sender][msg.sender] >= amount,
            "ERC20: transfer amount exceeds allowance"
        );
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        allowance[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
}
```

除了上述核心方法，你可能还听过 mint、burn 等方法，这些方法是 ERC-20 标准之外的扩展方法，用于增发和销毁代币。

```solidity
contract ERC20 is IERC20 {
    // ...

    // 增发 amount 数量的代币
    function mint(uint amount) external {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
    }

    // 销毁 amount 数量的代币
    function burn(uint amount) external {
        require(
            balanceOf[msg.sender] >= amount,
            "ERC20: burn amount exceeds balance"
        );
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}
```

如果 mint 方法没有适当的权限控制，可能会导致无限制地创建代币，进而引发通货膨胀和代币价值下降。如果 burn 方法没有适当的检查，可能会导致用户意外销毁大量代币，造成经济损失。为了防止这些风险，通常会在合约中加入权限控制和严格的检查机制。例如，只有合约所有者或经过授权的账户才能调用 mint 方法。

<br><br>

# 多签钱包

多签钱包（Multisig Wallet）是一种需要多个密钥持有者共同授权才能执行交易的数字钱包。常见的签名模式包括 2/3、3/5 等。例如，在 2/3 签名模式中，三个密钥中至少需要两个签名才能执行交易。

在创建多签钱包时，需要指定多个密钥持有者和最少签名数。例如，可以设置三个密钥持有者，并要求至少两个签名才能执行交易。任何一个密钥持有者可以提交交易请求，其他密钥持有者需要对交易进行签名和确认，当达到最少签名数时，交易将被执行。

以下是一个简单的多签钱包智能合约示例：

1. 先定义一些事件：

```solidity
contract MultiSigWallet {
    // 当 sender 把 amount 存入合约时触发
    event Deposit(address indexed sender, uint amount);

    // 当 txIndex 被提交时触发
    event Submit(uint indexed txIndex);

    // 当 owner 批准 txIndex 时触发
    event Approve(address indexed owner, uint indexed txIndex);

    // 当 owner 撤销 txIndex 时触发
    event Revoke(address indexed owner, uint indexed txIndex);

    // 当 txIndex 被执行时触发
    event Execute(uint indexed txIndex);
}
```

2. 定义交易的结构体：

```solidity
contract MultiSigWallet {
    // 交易的结构体
    struct Transaction {
        address to; // 接收地址
        uint value; // 金额
        bytes data; // 数据
        bool executed; // 是否已执行
    }
}
```

3. 定义一些状态变量：

```solidity
contract MultiSigWallet {
    // 交易
    Transaction[] public transactions;

    // owner 们
    address[] public owners;

    // owner => 是否为 owner
    mapping(address => bool) public isOwner;

    // 需要多少个 owner 批准, 交易才能被执行
    uint public numApprovalsRequired;

    // 交易被 owner 批准的情况; txIndex => owner => 是否批准
    mapping(uint => mapping(address => bool)) public isApproved;
}
```

4. 实现构造函数：

```solidity
contract MultiSigWallet {
    constructor(address[] memory _owners, uint _numApprovalsRequired) {
        require(_owners.length > 0, "owners required");
        require(
            _numApprovalsRequired > 0 &&
                _numApprovalsRequired <= _owners.length,
            "invalid number of required approvals"
        );

        for (uint i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "invalid owner");
            require(!isOwner[owner], "owner not unique");
            isOwner[owner] = true;
            owners.push(owner);
        }

        numApprovalsRequired = _numApprovalsRequired;
    }
}
```

5. 实现一些函数装饰器：

```solidity
contract MultiSigWallet {
    // 函数装饰器; 检查调用者是否为 owner, 是则继续
    modifier onlyOwner() {
        require(isOwner[msg.sender], "not owner");
        _;
    }

    // 函数装饰器; 检查交易是否存在, 存在则继续
    modifier txExists(uint _txIndex) {
        require(_txIndex < transactions.length, "tx does not exist");
        _;
    }

    // 函数装饰器; 检查交易是否已执行, 未执行则继续
    modifier notExecuted(uint _txIndex) {
        require(!transactions[_txIndex].executed, "tx already executed");
        _;
    }

    // 函数装饰器; 检查交易是否被 owner 批准, 未批准则继续
    modifier notApproved(uint _txIndex) {
        require(!isApproved[_txIndex][msg.sender], "tx already approved");
        _;
    }
}
```

6. 实现函数接收以太币：

```solidity
contract MultiSigWallet {
    // 接收以太币
    receive() external payable {
        emit Deposit(msg.sender, msg.value);
    }
}
```

7. 实现函数提交交易：

```solidity
contract MultiSigWallet {
    // 提交交易
    function submitTransaction(
        address _to,
        uint _value,
        bytes calldata _data
    ) external onlyOwner {
        uint txIndex = transactions.length;
        transactions.push(
            Transaction({to: _to, value: _value, data: _data, executed: false})
        );
        emit Submit(txIndex);
    }
}
```

8. 实现函数批准交易：

```solidity
contract MultiSigWallet {
    // 批准交易
    function approveTransaction(
        uint _txIndex
    )
        external
        onlyOwner
        txExists(_txIndex)
        notExecuted(_txIndex)
        notApproved(_txIndex)
    {
        isApproved[_txIndex][msg.sender] = true;
        emit Approve(msg.sender, _txIndex);
    }
}
```

9. 实现函数撤销批准：

```solidity
contract MultiSigWallet {
    // 撤销批准
    function revokeTransaction(
        uint _txIndex
    ) external onlyOwner txExists(_txIndex) notExecuted(_txIndex) {
        require(isApproved[_txIndex][msg.sender], "tx not approved");
        isApproved[_txIndex][msg.sender] = false;
        emit Revoke(msg.sender, _txIndex);
    }
}
```

10. 实现函数执行交易：

```solidity
contract MultiSigWallet {
    // helper function; 获取已批准的 owner 数量
    function _getApprovals(uint _txIndex) private view returns (uint) {
        uint approvals = 0;
        for (uint i = 0; i < owners.length; i++) {
            if (isApproved[_txIndex][owners[i]]) {
                approvals++;
            }
        }
        return approvals;
    }

    // 执行交易
    function executeTransaction(
        uint _txIndex
    ) external onlyOwner txExists(_txIndex) notExecuted(_txIndex) {
        require(
            _getApprovals(_txIndex) >= numApprovalsRequired,
            "cannot execute tx"
        );

        Transaction storage transaction = transactions[_txIndex];
        transaction.executed = true;

        (bool success, ) = transaction.to.call{value: transaction.value}(
            transaction.data
        );
        require(success, "tx failed");

        emit Execute(_txIndex);
    }
}
```

<br><br>

# WETH

包装以太币（Wrapped Ether，简称 WETH）是一种将原生的以太币（ETH）转换为 ERC-20 代币的机制。由于以太坊网络上的许多去中心化应用（DApps）和智能合约主要与 ERC-20 代币交互，WETH 使得 ETH 可以与这些应用和合约无缝集成。

WETH 的价值与 ETH 1:1 锚定。包装和解包过程涉及将 ETH 存入或从智能合约中提取。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract WETH {
    // 代币名称
    string public name = "Wrapped Ether";

    // 代币符号
    string public symbol = "WETH";

    // 代币的小数位数, 通常为 18
    uint8 public decimals = 18;

    // 记录每个地址的 WETH 余额
    mapping(address => uint) public balanceOf;

    // 记录存入 ETH 的事件
    event Deposit(address indexed account, uint amount);

    // 记录提取 ETH 的事件
    event Withdrawal(address indexed account, uint amount);

    // 使合约可以接受 ETH
    receive() external payable {
        deposit();
    }

    // 接受 ETH 并将其转换为 WETH
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    // 将 WETH 转换回 ETH 并提取到调用者的地址
    function withdraw(uint amount) public {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    // 返回合约中存储的 ETH 总量
    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }
}
```

我们可以直接使用 OpenZeppelin 的 ERC20 合约库来实现 WETH 合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract WETH is ERC20 {
    // 记录存入 ETH 的事件
    event Deposit(address indexed account, uint amount);

    // 记录提取 ETH 的事件
    event Withdrawal(address indexed account, uint amount);

    // 初始化 WETH 合约
    constructor() ERC20("Wrapped Ether", "WETH") {}

    // 使合约可以接受 ETH
    receive() external payable {
        deposit();
    }

    // 接受 ETH 并将其转换为 WETH
    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    // 将 WETH 转换回 ETH 并提取到调用者的地址
    function withdraw(uint amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }
}
```

1. 部署 WETH 合约

2. 调用 WETH 合约的 deposit 函数，设置传入的 ETH 数量，这里以 1 ETH 为例

3. 调用 WETH 合约继承的 balanceOf 函数，传入部署 WETH 合约的地址，查看 WETH 余额

4. 调用 WETH 合约继承的 totalSupply 函数，查看合约中存储的 ETH 总量

5. 调用 WETH 合约的 withdraw 函数，传入提取的 WETH 数量，提取 ETH

6. 调用 WETH 合约继承的 balanceOf 函数，查看 WETH 余额

7. 调用 WETH 合约继承的 totalSupply 函数，查看合约中存储的 ETH 总量

<br>
