# 调用其他合约的方法

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Demo {
    // 方法 1
    function setDemo2X(address _demo2, uint _x) public returns (uint) {
        Demo2 demo2 = Demo2(_demo2);
        return demo2.setX(_x);
    }

    // 方法 2
    function setDemo2X2(Demo2 _demo2, uint _x) public returns (uint) {
        return _demo2.setX(_x);
    }
}

contract Demo2 {
    uint public x;

    function setX(uint _x) public returns (uint) {
        x = _x;
        return x;
    }
}
```

调用的同时传输以太币：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Demo {
    function setDemo2(Demo2 _demo2) public payable returns (uint) {
        return _demo2.getEther{value: msg.value}();
    }
}

contract Demo2 {
    uint public value;

    function getEther() public payable returns (uint) {
        value = msg.value;
        return value;
    }
}
```

处理多返回值：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Demo {
    function getDemo2(Demo2 demo2) public pure returns (uint x, uint y) {
        (x, y) = demo2.getMulNum();
    }
}

contract Demo2 {
    function getMulNum() public pure returns (uint, uint) {
        return (1, 2);
    }
}
```

综合 demo：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MyTargetContract {
    uint public x;
    uint public value;

    function setX(uint _x) public {
        x = _x;
    }

    function getX() public view returns (uint) {
        return x;
    }

    function setXAndReceiveEther(uint _x) public payable {
        x = _x;
        value = msg.value;
    }

    function getXAndValue() public view returns (uint, uint) {
        return (x, value);
    }
}

contract MyCallerContract {
    MyTargetContract public target;

    constructor(MyTargetContract _target) {
        target = _target;
    }

    function setTargetX(uint _x) public {
        target.setX(_x);
    }

    function getTargetX() public view returns (uint) {
        return target.getX();
    }

    function setXWithEther(uint _x) public payable {
        target.setXAndReceiveEther{value: msg.value}(_x);
    }

    function getXAndValueFromTarget() public view returns (uint x, uint value) {
        (x, value) = target.getXAndValue();
    }
}
```

<br><br>

# 接口

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Counter {
    uint public count;

    function increment() public {
        count += 1;
    }
}

contract MyContract {
    function incrementCounter(address _counter) public {
        Counter(_counter).increment();
    }

    function getCount(address _counter) public view returns (uint) {
        return Counter(_counter).count();
    }
}
```

如果我们不知道 Counter 里面的代码，我们就需要使用接口：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface ICounter {
    function increment() external;

    function count() external view returns (uint);
}

contract MyContract {
    function incrementCounter(address _counter) public {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) public view returns (uint) {
        return ICounter(_counter).count();
    }
}
```

<br><br>

# call 方法

call 是一个比较底层的方法，除了可以用来发送以太，还能用来调用其他合约的函数。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestCall {
    event Log(string message, uint value);

    function foo(
        string calldata _str,
        uint _num
    ) external payable returns (bool, uint) {
        emit Log(_str, msg.value);
        return (true, _num);
    }
}

contract Call {
    bytes public data;

    function testCall(address _addr) public payable {
        (bool success, bytes memory _data) = _addr.call{
            // 传输的以太数量; 若设置的以太数量小于该下限, 会报错
            value: 100,
            // gas 上限; 若消耗的 gas 大于该上限, 会报错
            gas: 500000
            // 调用其他合约的方法, 并传入参数; 第 1 参数是方法签名, 不能有空格, 不能用简写
        }(abi.encodeWithSignature("foo(string,uint256)", "call foo", 123));
        require(success, "call failed");
        data = _data; // 返回值 _data 是被调用合约的方法的返回值
    }
}
```

demo：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestContract {
    string public message;
    uint256 public number;

    function foo(string memory _msg, uint256 _num) public {
        message = _msg;
        number = _num;
    }

    fallback() external {
        emit Log("Fallback was called");
    }

    event Log(string msg);
}

contract Caller {
    function callFoo(
        address _testContract,
        string memory _msg,
        uint256 _num
    ) public {
        (bool success, ) = _testContract.call(
            abi.encodeWithSignature("foo(string,uint256)", _msg, _num)
        );
        require(success, "call foo failed");
    }

    function callNonExistentFunction(address _testContract) public {
        (bool success, ) = _testContract.call(
            abi.encodeWithSignature("nonExistentFunction()")
        );
        require(success, "call nonExistentFunction failed");
    }
}
```

<br><br>

# 委托调用

Delegate Call：在当前合约调用其他合约的方法，更新当前合约的状态变量

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract B {
    uint256 public num;
    address public sender;
    uint256 public value;

    function setVars(uint256 _num) public payable {
        num = _num;
        sender = msg.sender;
        value = msg.value;
    }
}

contract A {
    uint256 public num;
    address public sender;
    uint256 public value;

    function setVars(address _contract, uint256 _num) public payable {
        // 方法 1 - 用 encodeWithSignature
        (bool success1, ) = _contract.delegatecall(
            abi.encodeWithSignature("setVars(uint256)", _num)
        );
        require(success1, "1 delegatecall failed");

        // 方法 2 - 用 encodeWithSelector;  不是通过硬编码调用, 更灵活
        (bool success2, ) = _contract.delegatecall(
            abi.encodeWithSelector(B.setVars.selector, _num)
        );
        require(success2, "2 delegatecall failed");
    }
}
```

先部署 B 再部署 A，将 B 的合约地址作为 \_contract 参数传入 A 合约的 setVars 方法，设置 \_num 参数值、设置以太数，执行 A 合约的 setVars 方法，可以发现 A 合约中的状态变量被更新了，而 B 合约中的状态变量仍未被改变。这就是 Delegate Call 。

需要注意，B 中的状态变量需要与 A 保持一致，如需再为 B 添加新的状态变量，只能在原状态变量后加，否则会出错：

```solidity
contract B {
	// address public owner; // 不好使, 会出错
    uint256 public num;
    address public sender;
    uint256 public value;
    address public owner; // 好使

    function setVars(uint256 _num) public payable {
        num = _num;
        sender = msg.sender;
        value = msg.value;
    }
}
```

使用 delegate call 后，只要 B 合约更新、升级了，A 合约就能跟着升级 而无需更新代码，非常方便~

<br><br>

# 新建合约

我们可以编写一个工厂合约，用于创建其他合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Account {
    address public owner;
    address public caller;
    uint public value;

    constructor(address _caller) payable {
        owner = msg.sender;
        value = msg.value;
        caller = _caller;
    }
}

contract AccountFactory {
    Account[] public accounts;

    function createAccount(address _caller) public payable {
        // 创建合约并传输 111 以太币
        Account newAccount = new Account{value: 111}(_caller);
        accounts.push(newAccount);
    }
}
```

1.  在 Remix 中部署 AccountFactory 合约
2.  复制编辑器的地址作为参数传入 AccountFactory 合约的 createAccount 方法，设置以太数量 (设置的以太数量需大于等于 111)，调用 createAccount 方法
3.  访问 accounts 的第 1 个元素，获取新创建的 Account 合约地址
4.  通过 Account 合约地址，将 Account 合约添加到 Remix 中
5.  点开新创建的 Account 合约，查看 owner 是否为 AccountFactory 的合约地址、caller 是否为编辑器地址、value 是否为 111

<br><br>

# library

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

library Math {
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }
}

contract Test {
    function test() public pure returns (uint256) {
        return Math.max(1, 2);
    }
}
```

注意：① library 不能拥有自己的状态变量、② 推荐使用 internal 修饰 library 的方法，这样 我们在部署合约时，library 的方法就能内嵌到合约中；如果使用 public 修饰 library 的方法，则需要单独部署 library；如果使用 private / external 修饰 library 的方法，则无法在合约中调用 library 的方法。

<br>

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

library ArrayLib {
    function findIndex(
        uint256[] memory arr,
        uint256 value
    ) internal pure returns (int256) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return int256(i);
            }
        }
        return -1;
    }
}

contract Test {
    using ArrayLib for uint256[]; // 使用 ArrayLib 库增强 uint256[] 数组的功能

    uint256[] public arr = [1, 2, 3, 4, 5];

    function findIndex(uint256 value) public view returns (int256) {
        return arr.findIndex(value); // 直接通过数组调用 findIndex 方法
    }
}
```

<br>
