# Time Lock

时间锁（TimeLock）是一种机制，用于将智能合约中的某些操作延迟执行，以提高安全性和透明度。时间锁通常用于去中心化金融（DeFi）和去中心化自治组织（DAO）中，以防止恶意操作和提供足够的时间进行审查和反应。

时间锁合约允许用户创建一个交易，并将其放入一个队列中。该交易在指定的延迟时间后才能执行。

主要功能：

1.  创建交易：将交易加入时间锁队列。

2.  执行交易：在锁定期满后执行交易。

3.  取消交易：在锁定期内取消交易。

```solidity
contract TimeLock {
    // 管理员地址
    address public immutable admin;

    // 最小锁定时间
    uint public constant MIN_DELAY = 60; // 生产环境常用 1 days ~ 2 days

    // 最大锁定时间
    uint public constant MAX_DELAY = 120; // 生产环境常用 7 days ~ 30 days

    // 到期执行的宽限时间
    uint public constant GRACE_PERIOD = 60; // 生产环境常用 1 days ~ 7 days

    // 记录所有在时间锁队列中的交易
    mapping(bytes32 => bool) public queuedTransactions;

    // 交易创建并进入时间锁队列的事件
    event QueueTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 锁定期满后交易执行的事件
    event ExecuteTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 交易取消事件
    event CancelTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 初始化管理员地址
    constructor() {
        admin = msg.sender;
    }

    // 让合约可以接收以太币
    receive() external payable {}

    // 限制只有管理员才能调用的函数
    modifier onlyAdmin() {
        require(msg.sender == admin, "TimeLock: Caller is not admin");
        _;
    }

    // 创建交易并添加到时间锁队列中
    function queueTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin returns (bytes32) {
        require(
            executeTime >= block.timestamp + MIN_DELAY &&
                executeTime <= block.timestamp + MAX_DELAY,
            "TimeLock: Invalid execution time"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            !queuedTransactions[txHash],
            "TimeLock: Transaction already queued"
        );

        queuedTransactions[txHash] = true;
        emit QueueTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return txHash;
    }

    // 取消交易
    function cancelTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin {
        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        emit CancelTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
    }

    // 执行交易
    function executeTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public payable onlyAdmin returns (bytes memory) {
        require(
            block.timestamp >= executeTime,
            "TimeLock: Transaction hasn't surpassed time lock"
        );
        require(
            block.timestamp <= executeTime + GRACE_PERIOD,
            "TimeLock: Transaction is stale"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        bytes memory callData = bytes(signature).length == 0
            ? data
            : abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        (bool success, bytes memory returnData) = target.call{value: value}(
            callData
        );
        require(success, "TimeLock: Transaction execution reverted");

        emit ExecuteTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return returnData;
    }
}
```

编写测试合约：

```solidity
contract TestTimeLock {
    address public timeLock;

    event Log(string message);

    constructor(address _timeLock) {
        timeLock = _timeLock;
    }

    // 测试函数
    function test() public {
        require(msg.sender == timeLock, "Only timeLock can call");
        emit Log("Test");
    }

    // 辅助函数, 获取测试函数的执行时间
    function getExecutedTime() public view returns (uint) {
        return block.timestamp + 30;
    }
}
```

1. 部署 TimeLock 合约

2. 部署 TestTimeLock 合约，构造函数传入 `TimeLock 合约地址`

3. 调用 TestTimeLock 合约的 getExecutedTime 函数，获取执行时间 `executeTime`

4. 调用 TimeLock 合约的 queueTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，将 TestTimeLock 合约的 test 函数添加到时间锁队列中

5. 等待 `executeTime` 时间到达，调用 TimeLock 合约的 executeTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，执行 TestTimeLock 合约的 test 函数

6. 在未到达 `executeTime` 之前，可调用 TimeLock 合约的 cancelTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，取消 TestTimeLock 合约的 test 函数

<br><br>

# CSAMM

恒和自动市场制造商 (Constant Sum Automated Market Maker) 是一种去中心化交易协议，用于在区块链上实现自动化的代币交易。与常见的恒积自动市场制造商（如 Uniswap）不同，CSAMM 使用恒和公式来确定交易价格。

在 CSAMM 中，交易价格由以下公式决定：`x + y = k`，其中 `x` 和 `y` 分别代表池中的两种代币数量，`k` 是一个常数，表示池中两种代币数量的总和。

由于使用恒定和公式，CSAMM 在价格波动较小时表现较好，适用于稳定币之间的交易。

```solidity
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ConstantSumAMM {
    // 合约中两种代币的实例
    IERC20 public immutable tokenX;
    IERC20 public immutable tokenY;

    // 两种代币的供应量
    uint public supplyX;
    uint public supplyY;

    // 流动池中的总供应量
    uint public totalSupply;

    // 每个用户的流动份额
    mapping(address => uint) public balanceOf;

    constructor(address _tokenX, address _tokenY) {
        tokenX = IERC20(_tokenX);
        tokenY = IERC20(_tokenY);
    }

    // 发行 amount 数量的 token 到 to 账户
    function _mint(address to, uint amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    // 从 from 账户销毁 amount 数量的 token
    function _burn(address from, uint amount) internal {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }

    // 用一种 token 换取另一种 token
    function swap(
        address _tokenIn,
        uint _amountIn
    ) external returns (uint amountOut) {
        require(
            _tokenIn == address(tokenX) || _tokenIn == address(tokenY),
            "Invalid token"
        );

        // 确定传入的代币为 tokenX 还是 tokenY
        bool isX = _tokenIn == address(tokenX);

        // 根据传入的代币确定输入和输出的代币及其供应量
        (IERC20 tokenIn, IERC20 tokenOut, uint supplyIn, uint supplyOut) = isX
            ? (tokenX, tokenY, supplyX, supplyY)
            : (tokenY, tokenX, supplyY, supplyX);

        // 用户将代币转移到合约中
        tokenIn.transferFrom(msg.sender, address(this), _amountIn);

        // 计算用户实际转移的代币数量
        uint amountIn = tokenIn.balanceOf(address(this)) - supplyIn;

        // 计算用户可以获得的代币数量
        amountOut = (amountIn * 997) / 1000; // 0.3% 手续费

        // 更新两种代币的总供应量
        if (isX) {
            supplyX = supplyIn + amountIn;
            supplyY = supplyOut - amountOut;
        } else {
            supplyY = supplyIn + amountIn;
            supplyX = supplyOut - amountOut;
        }

        // 将代币转移给用户
        tokenOut.transfer(msg.sender, amountOut);
    }

    // 向池中添加流动性，获得相应的份额
    function addLiquidity(
        uint amountX,
        uint amountY
    ) external returns (uint shares) {
        // 用户将代币转移到合约中
        tokenX.transferFrom(msg.sender, address(this), amountX);
        tokenY.transferFrom(msg.sender, address(this), amountY);

        // 计算用户实际转移的代币数量
        uint _amountX = tokenX.balanceOf(address(this)) - supplyX;
        uint _amountY = tokenY.balanceOf(address(this)) - supplyY;

        // 计算用户可以获得的份额
        // a - amount in
        // L - total liquidity
        // s - shares to mint
        // T - total supply
        // 需满足 (a + L) / L = (s + T) / T
        // 所以 s = a * T / L
        if (totalSupply == 0) {
            // 对于第一次添加流动性的用户, 直接按照转移的代币数量计算份额
            shares = _amountX + _amountY;
        } else {
            shares =
                ((_amountX + _amountY) * totalSupply) /
                (supplyX + supplyY);
        }

        // 发行份额给用户
        require(shares > 0, "Invalid shares");
        _mint(msg.sender, shares);

        // 更新两种代币的总供应量
        supplyX += _amountX;
        supplyY += _amountY;
    }

    // 根据持有的份额提取流动性
    function removeLiquidity(
        uint shares
    ) external returns (uint amountX, uint amountY) {
        // 计算用户可以获得的代币数量
        // a - amount out
        // L - total liquidity
        // s - shares
        // T - total supply
        // 需满足 a / L = s / T
        // 所以 a = s * L / T
        amountX = (shares * supplyX) / totalSupply;
        amountY = (shares * supplyY) / totalSupply;

        // 销毁用户的份额
        _burn(msg.sender, shares);

        // 更新两种代币的总供应量
        supplyX -= amountX;
        supplyY -= amountY;

        // 将代币转移给用户
        require(amountX > 0 && amountY > 0, "Invalid amount");
        tokenX.transfer(msg.sender, amountX);
        tokenY.transfer(msg.sender, amountY);
    }
}
```

编写测试合约：

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint amount) external {
        _mint(to, amount);
    }
}
```

1. 部署两次 MyToken 合约，分别作为两种代币，这里分别命名为 `tokenX` 和 `tokenY`，符号分别为 `X` 和 `Y`

2. 传入 `tokenX` 和 `tokenY` 的地址，部署 ConstantSumAMM 合约

3. 传入编辑器地址和 `1000`，调用 `tokenX` 合约的 mint 函数，表示在 `tokenX` 合约中发行 `1000` 个代币到编辑器地址

4. 传入编辑器地址和 `1000`，调用 `tokenY` 合约的 mint 函数，表示在 `tokenY` 合约中发行 `1000` 个代币到编辑器地址

5. 传入 ConstantSumAMM 合约的地址和 `1000`，调用 `tokenX` 合约的 approve 函数，表示授权 ConstantSumAMM 合约可以从编辑器地址转移 `1000` 个 `tokenX` 代币

6. 传入 ConstantSumAMM 合约的地址和 `1000`，调用 `tokenY` 合约的 approve 函数，表示授权 ConstantSumAMM 合约可以从编辑器地址转移 `1000` 个 `tokenY` 代币

**测试 addLiquidity**：

1. 传入 `1000` 和 `1000`，调用 ConstantSumAMM 合约的 addLiquidity 函数，表示编辑器地址向 ConstantSumAMM 合约添加 `1000` 个 `tokenX` 和 `1000` 个 `tokenY`，获取响应的流动性份额

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `2000`、两种代币的总供应量 supplyX、supplyY 均为 `1000`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `2000`

3. 查看 `tokenX` 和 `tokenY` 合约中编辑器地址的余额，可以看到编辑器地址的 `tokenX`、`tokenY` 的余额均变成了 `0`

**测试 swap**：

1. 切换编辑器地址 2

2. 传入编辑器地址 2 和 `1000`，调用 `tokenX` 合约的 mint 函数，表示在 `tokenX` 合约中发行 `1000` 个代币到编辑器地址 2

3. 传入 ConstantSumAMM 合约的地址和 `1000`，调用 `tokenX` 合约的 approve 函数，表示授权 ConstantSumAMM 合约可以从编辑器地址 2 转移 `1000` 个 `tokenX` 代币

4. 查看 `tokenX` 合约中编辑器地址 2 的余额，可以看到编辑器地址 2 的 `tokenX` 余额为 `1000`

5. 传入 `tokenX` 的地址和 `1000`，调用 ConstantSumAMM 合约的 swap 函数，表示编辑器地址 2 用 `1000` 个 `tokenX` 交换 `tokenY`

6. 查看 `tokenX` 和 `tokenY` 合约中编辑器地址 2 的余额，可以看到编辑器地址 2 的 `tokenX` 余额变成了 `0`、`tokenY` 余额变成了 `997`，表示编辑器地址 2 用 `1000` 个 `tokenX` 交换了 `997` 个 `tokenY`

7. 查看 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 仍为 `2000`、两种代币的总供应量 supplyX 为 `2000`、supplyY 为 `3`

**测试 removeLiquidity**：

1. 切换回编辑器地址 1

2. 传入 `2000`，调用 ConstantSumAMM 合约的 removeLiquidity 函数，表示编辑器地址提取 `2000` 份额的流动性，获得相应的代币数量

3. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `0`、两种代币的总供应量 supplyX 为 `0`、supplyY 为 `0`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `0`

4. 查看 `tokenX` 和 `tokenY` 合约中编辑器地址的余额，可以看到用户的 `tokenX` 余额变成了 `2000`、`tokenY` 余额变成了 `3`

<br><br>
