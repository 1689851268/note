# storage

storage 声明的变量：

1.  能用于状态变量、函数内部变量，但不能用于函数参数/返回值
2.  会永久存储在区块链上
3.  可被修改

```solidity
contract StorageExample {
    uint256 public data; // 默认是 storage 类型
}
```

<br><br>

# memory

memory 声明的变量：

1.  能用于函数内部变量、函数参数/返回值，但不能用于状态变量
2.  会暂时存储在内存中，函数执行完后会释放内存
3.  可被修改

```solidity
contract MemoryExample {
    function concatenate(
        string memory _a,
        string memory _b
    ) public pure returns (string memory) {
        return string(abi.encodePacked(_a, _b));
    }
}
```

<br><br>

# calldata

calldata 声明的变量：

-   能用于函数参数/返回值，但不能用于状态变量、函数内部变量
-   会暂时存储在内存中，函数执行完后会释放内存
-   只能读取，不能修改

```solidity
contract CalldataExample {
    function processCalldata(
        string calldata _input
    ) public pure returns (string calldata) {
        return _input;
    }
}
```

<br><br>

# Demo

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    struct Student {
        uint256 id;
        string name;
    }

    mapping(address => Student) public students;

    function addStudent(uint256 _id, string calldata _name) public {
        students[msg.sender] = Student(_id, _name);

        // storage 会告诉编译器, 这个变量是一个引用
        Student storage student = students[msg.sender];
        // 修改 storage 修饰的变量, 会影响区块链上的数据, 这里是 students[msg.sender].name 的值
        student.name = string(abi.encodePacked(student.name, "~"));

        // memory 会告诉编译器, 变量值存储在内存中; 函数执行完后, 会释放内存
        Student memory student2 = students[msg.sender];
        // 修改 memory 修饰的变量, 不会影响区块链上的数据
        student2.name = string(abi.encodePacked(student2.name, "!"));
    }
}
```

<br>

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    struct ToDo {
        string text;
        bool completed;
    }

    ToDo[] public todos;

    function create(string calldata _text) public {
        todos.push(ToDo({text: _text, completed: false}));
    }

    function updateText(uint _index, string calldata _text) public {
        require(_index < todos.length && _index >= 0, "Index out of range");

        // 方法 1 - 直接修改, 修改的属性较少时 会消耗更少的 gas
        todos[_index].text = _text;

        // 方法 2 - 重新赋值, 修改的属性较多时 会消耗更少的 gas
        // ToDo storage todo = todos[_index];
        // todo.text = _text;
    }

    function toggleCompleted(uint _index) public {
        require(_index < todos.length && _index >= 0, "Index out of range");
        todos[_index].completed = !todos[_index].completed;
    }
}
```

<br>
