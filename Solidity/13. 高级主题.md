# 群众筹资

1. 定义接口：

```solidity
interface IERC20 {
    function transfer(address, uint) external returns (bool);

    function transferFrom(address, address, uint) external returns (bool);
}
```

2. 定义事件：

```solidity
contract CrowdFunding {
    // 发起众筹时触发
    event Launch(
        uint id,
        address indexed creator,
        uint goal,
        uint balance,
        uint32 startTime,
        uint32 endTime
    );

    // 取消众筹时触发
    event Cancel(uint id);

    // 用户参与众筹时触发
    event Donate(uint indexed id, address indexed donor, uint amount);

    // 用户取消参与众筹时触发
    event CancelDonation(uint indexed id, address indexed donor, uint amount);

    // 发起人提取众筹资金时触发
    event Claim(uint id);

    // 退还未达标的众筹资金时触发
    event Refund(uint indexed id, address indexed donor, uint amount);
}
```

3. 定义结构体：

```solidity
contract CrowdFunding {
    // 众筹项目的数据结构
    struct Campaign {
        // 众筹发起人
        address creator;
        // 众筹目标金额
        uint goal;
        // 众筹已筹金额
        uint balance;
        // 众筹开始时间
        uint32 startTime;
        // 众筹结束时间
        uint32 endTime;
        // 众筹是否已被提取
        bool claimed;
    }
}
```

4. 定义状态变量：

```solidity
contract CrowdFunding {
    // 众筹代币
    IERC20 public immutable token;

    // 众筹项目数量
    uint public count;

    // 众筹项目
    mapping(uint => Campaign) public campaigns;

    // 用户对众筹项目的捐赠
    mapping(uint => mapping(address => uint)) public donations;
}
```

5. 实现构造函数：

```solidity
contract CrowdFunding {
    constructor(IERC20 _token) {
        token = _token;
    }
}
```

6. 实现发起众筹方法：

```solidity
contract CrowdFunding {
    // 发起众筹
    function launch(uint _goal, uint32 _startTime, uint32 _endTime) external {
        require(_goal > 0, "invalid goal");
        require(_startTime > block.timestamp, "invalid start time");
        require(_endTime > _startTime, "invalid end time");

        count++;
        campaigns[count] = Campaign(
            msg.sender,
            _goal,
            0,
            _startTime,
            _endTime,
            false
        );

        emit Launch(count, msg.sender, _goal, 0, _startTime, _endTime);
    }
}
```

7. 实现取消众筹方法：

```solidity
contract CrowdFunding {
    // 取消众筹
    function cancel(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(msg.sender == campaign.creator, "not creator");
        require(block.timestamp < campaign.startTime, "crowdfunding started");

        delete campaigns[_id];

        emit Cancel(_id);
    }
}
```

8. 实现用户参与众筹方法：

```solidity
contract CrowdFunding {
    // 用户参与众筹
    function donate(uint _id, uint _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator != address(0), "invalid campaign");
        require(
            block.timestamp >= campaign.startTime,
            "crowdfunding not started"
        );
        require(block.timestamp < campaign.endTime, "crowdfunding ended");
        require(_amount > 0, "invalid amount");

        campaign.balance += _amount;
        donations[_id][msg.sender] += _amount;
        token.transferFrom(msg.sender, address(this), _amount);

        emit Donate(_id, msg.sender, _amount);
    }
}
```

9. 实现用户取消参与众筹方法：

```solidity
contract CrowdFunding {
    // 用户取消参与众筹
    function cancelDonation(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(
            block.timestamp >= campaign.startTime,
            "crowdfunding not started"
        );
        require(block.timestamp < campaign.endTime, "crowdfunding ended");
        require(donations[_id][msg.sender] > 0, "invalid donation");

        uint amount = donations[_id][msg.sender];
        campaign.balance -= amount;
        donations[_id][msg.sender] = 0;
        token.transfer(msg.sender, amount);

        emit CancelDonation(_id, msg.sender, amount);
    }
}
```

10. 实现发起人提取众筹资金方法：

```solidity
contract CrowdFunding {
    // 发起人提取众筹资金
    function claim(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator");
        require(block.timestamp >= campaign.endTime, "crowdfunding not ended");
        require(campaign.balance >= campaign.goal, "not reach goal");
        require(!campaign.claimed, "claimed");

        campaign.claimed = true;
        token.transfer(msg.sender, campaign.balance);

        emit Claim(_id);
    }
}
```

11. 实现退还未达标的众筹资金方法：

```solidity
contract CrowdFunding {
    // 退还未达标的众筹资金
    function refund(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator != address(0), "invalid campaign");
        require(block.timestamp >= campaign.endTime, "crowdfunding not ended");
        require(campaign.balance < campaign.goal, "reach goal");
        require(!campaign.claimed, "claimed");

        uint amount = donations[_id][msg.sender];
        donations[_id][msg.sender] = 0;
        token.transfer(msg.sender, amount);

        emit Refund(_id, msg.sender, amount);
    }
}
```

<br><br>

# CREATE2

CREATE2 是以太坊虚拟机（EVM）中的一个操作码，用于创建智能合约。与传统的 CREATE 操作码不同，CREATE2 允许开发者在部署合约之前预测其地址。

CREATE2 通过以下公式计算合约地址：`address = keccak256(0xff + sender + salt + keccak256(bytecode))`，其中：`0xff` 是一个常量，用于区分 CREATE2 和 CREATE；`sender` 是创建合约的合约地址；`salt` 是一个 32 字节的随机值，由开发者提供；`bytecode` 是要部署的合约的字节码。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract DeployWithCreate2 {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }
}

contract Create2Factory {
    event Deploy(address addr);

    // 使用 CREATE2 操作码部署 DeployWithCreate2 合约
    function deploy(uint _salt) external {
        DeployWithCreate2 _contract = new DeployWithCreate2{
            salt: bytes32(_salt)
        }(msg.sender);
        emit Deploy(address(_contract));
    }

    // 获取 DeployWithCreate2 合约的字节码
    function getBytecode(address _owner) public pure returns (bytes memory) {
        // 获取 DeployWithCreate2 合约的创建字节码
        // 创建字节码包含了合约的所有代码, 但不包括构造函数参数
        bytes memory bytecode = type(DeployWithCreate2).creationCode;
        // 将创建字节码和编码后的构造函数参数打包在一起, 并返回
        return abi.encodePacked(bytecode, abi.encode(_owner));
    }

    // 计算合约地址
    function getAddress(
        bytes memory bytecode,
        uint _salt
    ) public view returns (address) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(bytecode)
            )
        );
        // 将 hash 转为 uint 再转为 uint160, 表示取最后 20 个字节, 因为以太坊地址是 20 字节长
        return address(uint160(uint(hash)));
    }
}
```

1. 部署 Create2Factory 合约

2. 将编辑器的地址作为参数传入 getBytecode 方法并调用，获取 DeployWithCreate2 合约的字节码

3. 将获取到的字节码和随机值作为参数传入 getAddress 方法并调用，计算合约地址；随机值这里以 123 为例

4. 调用 deploy 方法，传入随机值 123，部署 DeployWithCreate2 合约

5. 查看 DeployWithCreate2 合约地址，与计算的合约地址比对，两者应该相等

<br><br>
