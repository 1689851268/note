# 群众筹资

1. 定义接口：

```solidity
interface IERC20 {
    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);
}
```

2. 定义事件：

```solidity
contract CrowdFunding {
    // 发起众筹时触发
    event Launch(
        uint id,
        address indexed creator,
        uint goal,
        uint balance,
        uint32 startTime,
        uint32 endTime
    );

    // 取消众筹时触发
    event Cancel(uint id);

    // 用户参与众筹时触发
    event Donate(uint indexed id, address indexed donor, uint amount);

    // 用户取消参与众筹时触发
    event CancelDonation(uint indexed id, address indexed donor, uint amount);

    // 发起人提取众筹资金时触发
    event Claim(uint id);

    // 退还未达标的众筹资金时触发
    event Refund(uint indexed id, address indexed donor, uint amount);
}
```

3. 定义结构体：

```solidity
contract CrowdFunding {
    // 众筹项目的数据结构
    struct Campaign {
        // 众筹发起人
        address creator;
        // 众筹目标金额
        uint goal;
        // 众筹已筹金额
        uint balance;
        // 众筹开始时间
        uint32 startTime;
        // 众筹结束时间
        uint32 endTime;
        // 众筹是否已被提取
        bool claimed;
    }
}
```

4. 定义状态变量：

```solidity
contract CrowdFunding {
    // 众筹代币
    IERC20 public immutable token;

    // 众筹项目数量
    uint public count;

    // 众筹项目
    mapping(uint => Campaign) public campaigns;

    // 用户对众筹项目的捐赠
    mapping(uint => mapping(address => uint)) public donations;
}
```

5. 实现构造函数：

```solidity
contract CrowdFunding {
    constructor(IERC20 _token) {
        token = _token;
    }
}
```

6. 实现发起众筹方法：

```solidity
contract CrowdFunding {
    // 发起众筹
    function launch(uint _goal, uint32 _startTime, uint32 _endTime) external {
        require(_goal > 0, "invalid goal");
        require(_startTime > block.timestamp, "invalid start time");
        require(_endTime > _startTime, "invalid end time");

        count++;
        campaigns[count] = Campaign(
            msg.sender,
            _goal,
            0,
            _startTime,
            _endTime,
            false
        );

        emit Launch(count, msg.sender, _goal, 0, _startTime, _endTime);
    }
}
```

7. 实现取消众筹方法：

```solidity
contract CrowdFunding {
    // 取消众筹
    function cancel(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(msg.sender == campaign.creator, "not creator");
        require(block.timestamp < campaign.startTime, "crowdfunding started");

        delete campaigns[_id];

        emit Cancel(_id);
    }
}
```

8. 实现用户参与众筹方法：

```solidity
contract CrowdFunding {
    // 用户参与众筹
    function donate(uint _id, uint _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator != address(0), "invalid campaign");
        require(
            block.timestamp >= campaign.startTime,
            "crowdfunding not started"
        );
        require(block.timestamp < campaign.endTime, "crowdfunding ended");
        require(_amount > 0, "invalid amount");

        campaign.balance += _amount;
        donations[_id][msg.sender] += _amount;
        token.transferFrom(msg.sender, address(this), _amount);

        emit Donate(_id, msg.sender, _amount);
    }
}
```

9. 实现用户取消参与众筹方法：

```solidity
contract CrowdFunding {
    // 用户取消参与众筹
    function cancelDonation(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(
            block.timestamp >= campaign.startTime,
            "crowdfunding not started"
        );
        require(block.timestamp < campaign.endTime, "crowdfunding ended");
        require(donations[_id][msg.sender] > 0, "invalid donation");

        uint amount = donations[_id][msg.sender];
        campaign.balance -= amount;
        donations[_id][msg.sender] = 0;
        token.transfer(msg.sender, amount);

        emit CancelDonation(_id, msg.sender, amount);
    }
}
```

10. 实现发起人提取众筹资金方法：

```solidity
contract CrowdFunding {
    // 发起人提取众筹资金
    function claim(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator == msg.sender, "not creator");
        require(block.timestamp >= campaign.endTime, "crowdfunding not ended");
        require(campaign.balance >= campaign.goal, "not reach goal");
        require(!campaign.claimed, "claimed");

        campaign.claimed = true;
        token.transfer(msg.sender, campaign.balance);

        emit Claim(_id);
    }
}
```

11. 实现退还未达标的众筹资金方法：

```solidity
contract CrowdFunding {
    // 退还未达标的众筹资金
    function refund(uint _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator != address(0), "invalid campaign");
        require(block.timestamp >= campaign.endTime, "crowdfunding not ended");
        require(campaign.balance < campaign.goal, "reach goal");
        require(!campaign.claimed, "claimed");

        uint amount = donations[_id][msg.sender];
        donations[_id][msg.sender] = 0;
        token.transfer(msg.sender, amount);

        emit Refund(_id, msg.sender, amount);
    }
}
```

<br><br>

# CREATE2

CREATE2 是以太坊虚拟机（EVM）中的一个操作码，用于创建智能合约。与传统的 CREATE 操作码不同，CREATE2 允许开发者在部署合约之前预测其地址。

CREATE2 通过以下公式计算合约地址：`address = keccak256(0xff + sender + salt + keccak256(bytecode))`，其中：`0xff` 是一个常量，用于区分 CREATE2 和 CREATE；`sender` 是创建合约的合约地址；`salt` 是一个 32 字节的随机值，由开发者提供；`bytecode` 是要部署的合约的字节码。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract DeployWithCreate2 {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }
}

contract Create2Factory {
    event Deploy(address addr);

    // 使用 CREATE2 操作码部署 DeployWithCreate2 合约
    function deploy(uint _salt) external {
        DeployWithCreate2 _contract = new DeployWithCreate2{
            salt: bytes32(_salt)
        }(msg.sender);
        emit Deploy(address(_contract));
    }

    // 获取 DeployWithCreate2 合约的字节码
    function getBytecode(address _owner) public pure returns (bytes memory) {
        // 获取 DeployWithCreate2 合约的创建字节码
        // 创建字节码包含了合约的所有代码, 但不包括构造函数参数
        bytes memory bytecode = type(DeployWithCreate2).creationCode;
        // 将创建字节码和编码后的构造函数参数打包在一起, 并返回
        return abi.encodePacked(bytecode, abi.encode(_owner));
    }

    // 计算合约地址
    function getAddress(
        bytes memory bytecode,
        uint _salt
    ) public view returns (address) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(bytecode)
            )
        );
        // 将 hash 转为 uint256 再转为 uint160, 表示取最后 20 个字节, 因为以太坊地址是 20 字节长
        return address(uint160(uint256(hash)));
    }
}
```

1. 部署 Create2Factory 合约

2. 将编辑器的地址作为参数传入 getBytecode 方法并调用，获取 DeployWithCreate2 合约的字节码

3. 将获取到的字节码和随机值作为参数传入 getAddress 方法并调用，计算合约地址；随机值这里以 123 为例

4. 调用 deploy 方法，传入随机值 123，部署 DeployWithCreate2 合约

5. 查看 DeployWithCreate2 合约地址，与计算的合约地址比对，两者应该相等

<br><br>

# Multi Call

Multi Call 表示在单个交易中调用多个合约函数。

Multi Call 合约通过循环调用多个目标合约的函数，并将结果聚合返回。每个函数调用使用 staticcall，这是一种低级调用方式，不会改变区块链状态。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestMultiCall {
    function func1() external view returns (uint256, uint256) {
        return (1, block.timestamp);
    }

    function func2() external view returns (uint256, uint256) {
        return (2, block.timestamp);
    }

    // 返回调用 func1 函数所需的编码数据
    function getFunc1Data() external pure returns (bytes memory) {
        // 使用 abi.encodeWithSelector 编码 func1 函数的选择器, 并返回编码数据
        return abi.encodeWithSelector(this.func1.selector);
    }

    // 返回调用 func2 函数所需的编码数据
    function getFunc2Data() external pure returns (bytes memory) {
        // 使用 abi.encodeWithSelector 编码 func2 函数的选择器, 并返回编码数据
        return abi.encodeWithSelector(this.func2.selector);
    }
}

contract MultiCall {
    function aggregate(
        address[] calldata targets, // 要调用的目标合约地址
        bytes[] calldata data // 每个目标合约的调用数据
    ) external view returns (bytes[] memory) {
        require(targets.length == data.length, "MultiCall: invalid input");
        bytes[] memory results = new bytes[](targets.length);
        for (uint256 i = 0; i < targets.length; i++) {
            (bool success, bytes memory result) = targets[i].staticcall(
                data[i]
            );
            require(success, "MultiCall: staticcall failed");
            results[i] = result;
        }
        return results;
    }
}
```

1. 部署 TestMultiCall、MultiCall 合约

2. 调用 TestMultiCall 的 getFunc1Data、getFunc2Data 方法，获取调用 func1、func2 函数所需的编码数据

3. 调用 MultiCall 的 aggregate 方法，传入 `["TestMultiCall 合约地址", "TestMultiCall 合约地址"]` 和 `["getFunc1Data 返回的编码数据", "getFunc2Data 返回的编码数据"]`，获取的调用结果应该为 `[bytes 格式的 func1 的返回值, bytes 格式的 func2 的返回值]`

4. 观察返回结果，可以看到 func1、func2 函数返回相同的时间戳

<br><br>

# Multi Delegate Call

Multi Delegate Call 允许在单个交易中调用多个合约函数，并在调用过程中共享调用者的上下文。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiDelegateCall {
    function multiDelegateCall(
        bytes[] calldata data
    ) external payable returns (bytes[] memory results) {
        results = new bytes[](data.length);
        for (uint i = 0; i < data.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(
                data[i]
            );
            require(success, "Delegate call failed");
            results[i] = result;
        }
    }
}

contract TestMultiDelegateCall is MultiDelegateCall {
    event Log(address caller, string funcName, uint value);

    function func1(uint x, uint y) external {
        emit Log(msg.sender, "func1", x + y);
    }

    function func2() external returns (uint) {
        emit Log(msg.sender, "func2", 123);
        return 123;
    }
}

contract Helper {
    function getFunc1Data(uint x, uint y) external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegateCall.func1.selector, x, y);
    }

    function getFunc2Data() external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegateCall.func2.selector);
    }
}
```

1. 部署 Helper、TestMultiDelegateCall 合约

2. 调用 Helper 的 getFunc1Data、getFunc2Data 方法，获取调用 func1、func2 函数所需的编码数据 func1Data、func2Data

3. 调用 TestMultiDelegateCall 继承的 multiDelegateCall 方法，传入 `["func1Data", "func2Data"]`，获取调用结果，应该返回 `[bytes 格式的 func1 的返回值, bytes 格式的 func2 的返回值]`

4. 观察返回结果，可以看到 `bytes 格式的 func1 的返回值` 为 `0x`，这是因为 func1 函数没有返回值

5. 查看 TestMultiDelegateCall 的事件日志，可以看到 func1、func2 函数的调用者是编辑器地址

<br>

在传输以太时需要注意传输的数量，以免出现不合预期的情况：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiDelegateCall {
    function multiDelegateCall(
        bytes[] calldata data
    ) external payable returns (bytes[] memory results) {
        results = new bytes[](data.length);
        for (uint i = 0; i < data.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(
                data[i]
            );
            require(success, "Delegate call failed");
            results[i] = result;
        }
    }
}

contract TestMultiDelegateCall is MultiDelegateCall {
    mapping(address => uint256) public balanceOf;

    function mint() external payable {
        balanceOf[msg.sender] += msg.value;
    }
}

contract Helper {
    function getMintData() external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegateCall.mint.selector);
    }
}
```

1. 部署 Helper、TestMultiDelegateCall 合约

2. 调用 Helper 的 getMintData 方法，获取调用 mint 函数所需的编码数据 mintData

3. 调用 TestMultiDelegateCall 继承的 multiDelegateCall 方法，传入 `["mintData", "mintData", "mintData"]`，设置以太数为 1 wei

4. 用编辑器地址查看 TestMultiDelegateCall 合约的 balanceOf，可以看到以太数为 3 wei

<br><br>

# ABI 解码

ABI 编码将函数调用和参数转换为字节数据，以便在以太坊网络上传输。解码则是将这些字节数据还原为原始类型。

数据编码：用于与智能合约交互时的参数编码。

1. abi.encode：每个参数都会被填充为 32 字节的数据，并拼接在一起

2. abi.encodePacked：类似 abi.encode，但会省略其中填充的零

函数编码：用于调用其他合约的函数。

1. abi.encodeWithSignature：第一个参数为函数签名，后面的参数为函数参数

2. abi.encodeWithSelector：第一个参数为函数选择器，后面的参数为函数参数

解码：

1. abi.decode：接受两个参数：编码后的数据和类型列表

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract ABIDecodeExample {
    function encodeData() external pure returns (bytes memory) {
        uint256 a = 1;
        address b = 0x1234567890123456789012345678901234567890;
        string memory c = "Hello, World!";
        return abi.encode(a, b, c);
    }

    function decodeData(
        bytes memory data
    ) external pure returns (uint256, address, string memory) {
        (uint256 a, address b, string memory c) = abi.decode(
            data,
            (uint256, address, string)
        );
        return (a, b, c);
    }
}
```

<br>
