# Gas Golf

Gas Golf 是一种优化智能合约以减少 Gas 消耗的技术。

Gas 是以太坊网络上执行交易和智能合约所需的计算资源的度量单位。通过优化代码，可以显著降低交易成本，提高合约的效率。

以下是一些常见的 Gas 优化技巧：

1. 使用 calldata 代替 memory

calldata 是一种只读数据位置，适用于函数参数。

```solidity
function example(uint[] calldata nums) external {
    // 使用 calldata 代替 memory
}
```

2. 将状态变量加载到内存中

频繁访问状态变量会消耗大量 Gas。将状态变量加载到内存中可以减少重复访问的开销。

```solidity
uint public total;

function example() external {
    uint _total = total;
    // 使用 _total 代替 total
    total = _total;
}
```

3. 使用前置递增运算符

在循环中，使用 ++i 代替 i++ 可以节省 Gas，因为前置递增运算符更高效。

```solidity
for (uint i = 0; i < nums.length; ++i) {
    // 使用 ++i 代替 i++
}
```

4. 缓存数组长度

在循环中，频繁访问数组的长度会消耗 Gas。将数组长度缓存到局部变量中可以减少开销。

```solidity
uint len = nums.length;
for (uint i = 0; i < len; ++i) {
    // 使用缓存的 len 代替 nums.length
}
```

5. 短路求值

在逻辑运算中，使用短路求值可以避免不必要的计算，从而节省 Gas。

```solidity
if (condition1 && condition2) {
    // 如果 condition1 为 false，则不会计算 condition2
}
```

6. 使用 unchecked 块

在某些情况下，可以使用 unchecked 块来避免溢出检查，从而节省 Gas。

```solidity
unchecked {
    ++i;
}
```

7. 将常访问的值缓存到内存中

在循环中，将常访问的值缓存到内存中可以减少重复访问的开销。

```solidity
for (uint i = 0; i < nums.length; i++) {
    uint num = nums[i];
    // 使用 num 代替 nums[i]
}
```

demo：

```solidity
// 未优化的代码
function sumIfEvenAndLessThan99(uint[] memory nums) external {
    for (uint i = 0; i < nums.length; i++) {
        bool isEven = nums[i] % 2 == 0;
        bool isLessThan99 = nums[i] < 99;
        if (isEven && isLessThan99) {
            total += nums[i];
        }
    }
}

// 优化后的代码
function sumIfEvenAndLessThan99(uint[] calldata nums) external {
    uint _total = total;
    uint len = nums.length;
    for (uint i = 0; i < len;) {
        uint num = nums[i];
        if (num % 2 == 0 && num < 99) {
            _total += num;
        }
        unchecked {
            ++i;
        }
    }
    total = _total;
}
```

<br><br>

# Time Lock

时间锁（TimeLock）是一种机制，用于将智能合约中的某些操作延迟执行，以提高安全性和透明度。时间锁通常用于去中心化金融（DeFi）和去中心化自治组织（DAO）中，以防止恶意操作和提供足够的时间进行审查和反应。

时间锁合约允许用户创建一个交易，并将其放入一个队列中。该交易在指定的延迟时间后才能执行。

主要功能：

1.  创建交易：将交易加入时间锁队列。

2.  执行交易：在锁定期满后执行交易。

3.  取消交易：在锁定期内取消交易。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TimeLock {
    // 管理员地址
    address public immutable admin;

    // 最小锁定时间
    uint public constant MIN_DELAY = 60; // 生产环境常用 1 days ~ 2 days

    // 最大锁定时间
    uint public constant MAX_DELAY = 120; // 生产环境常用 7 days ~ 30 days

    // 到期执行的宽限时间
    uint public constant GRACE_PERIOD = 60; // 生产环境常用 1 days ~ 7 days

    // 记录所有在时间锁队列中的交易
    mapping(bytes32 => bool) public queuedTransactions;

    // 交易创建并进入时间锁队列的事件
    event QueueTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 锁定期满后交易执行的事件
    event ExecuteTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 交易取消事件
    event CancelTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 初始化管理员地址
    constructor() {
        admin = msg.sender;
    }

    // 让合约可以接收以太币
    receive() external payable {}

    // 限制只有管理员才能调用的函数
    modifier onlyAdmin() {
        require(msg.sender == admin, "TimeLock: Caller is not admin");
        _;
    }

    // 创建交易并添加到时间锁队列中
    function queueTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin returns (bytes32) {
        require(
            executeTime >= block.timestamp + MIN_DELAY &&
                executeTime <= block.timestamp + MAX_DELAY,
            "TimeLock: Invalid execution time"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            !queuedTransactions[txHash],
            "TimeLock: Transaction already queued"
        );

        queuedTransactions[txHash] = true;
        emit QueueTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return txHash;
    }

    // 取消交易
    function cancelTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin {
        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        emit CancelTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
    }

    // 执行交易
    function executeTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public payable onlyAdmin returns (bytes memory) {
        require(
            block.timestamp >= executeTime,
            "TimeLock: Transaction hasn't surpassed time lock"
        );
        require(
            block.timestamp <= executeTime + GRACE_PERIOD,
            "TimeLock: Transaction is stale"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        bytes memory callData = bytes(signature).length == 0
            ? data
            : abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        (bool success, bytes memory returnData) = target.call{value: value}(
            callData
        );
        require(success, "TimeLock: Transaction execution reverted");

        emit ExecuteTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return returnData;
    }
}
```

编写测试合约：

```solidity
contract TestTimeLock {
    address public timeLock;

    event Log(string message);

    constructor(address _timeLock) {
        timeLock = _timeLock;
    }

    // 测试函数
    function test() public {
        require(msg.sender == timeLock, "Only timeLock can call");
        emit Log("Test");
    }

    // 辅助函数, 获取测试函数的执行时间
    function getExecutedTime() public view returns (uint) {
        return block.timestamp + 30;
    }
}
```

1. 部署 TimeLock 合约

2. 部署 TestTimeLock 合约，构造函数传入 `TimeLock 合约地址`

3. 调用 TestTimeLock 合约的 getExecutedTime 函数，获取执行时间 `executeTime`

4. 调用 TimeLock 合约的 queueTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，将 TestTimeLock 合约的 test 函数添加到时间锁队列中

5. 等待 `executeTime` 时间到达，调用 TimeLock 合约的 executeTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，执行 TestTimeLock 合约的 test 函数

6. 在未到达 `executeTime` 之前，可调用 TimeLock 合约的 cancelTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，取消 TestTimeLock 合约的 test 函数

<br><br>

# Oracle

预言机（Oracle）是一种机制，用于将外部世界的数据引入区块链。由于智能合约本身无法直接访问链外数据，预言机充当了区块链与外部数据源之间的桥梁，使得智能合约能够获取和验证与区块链无关的数据。

预言机通过监听智能合约中的事件或直接调用合约函数，将外部数据传递给智能合约。

预言机的类型：

1. 软件预言机：从在线数据源获取信息，如 API、网站等。

2. 硬件预言机：从物理设备获取数据，如传感器等。

3. 共识预言机：通过多个数据源和节点的共识来提供数据，确保数据的准确性和去中心化。

4. 输入预言机：将外部数据输入到智能合约中。

5. 输出预言机：从智能合约中获取数据并传递给外部系统。

<br><br>

# WETH

包装以太币（Wrapped Ether，简称 WETH）是一种将原生的以太币（ETH）转换为 ERC-20 代币的机制。由于以太坊网络上的许多去中心化应用（DApps）和智能合约主要与 ERC-20 代币交互，WETH 使得 ETH 可以与这些应用和合约无缝集成。

WETH 的价值与 ETH 1:1 锚定。包装和解包过程涉及将 ETH 存入或从智能合约中提取。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract WETH {
    // 代币名称
    string public name = "Wrapped Ether";

    // 代币符号
    string public symbol = "WETH";

    // 代币的小数位数, 通常为 18
    uint8 public decimals = 18;

    // 记录每个地址的 WETH 余额
    mapping(address => uint) public balanceOf;

    // 记录存入 ETH 的事件
    event Deposit(address indexed account, uint amount);

    // 记录提取 ETH 的事件
    event Withdrawal(address indexed account, uint amount);

    // 使合约可以接受 ETH
    receive() external payable {
        deposit();
    }

    // 接受 ETH 并将其转换为 WETH
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    // 将 WETH 转换回 ETH 并提取到调用者的地址
    function withdraw(uint amount) public {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    // 返回合约中存储的 ETH 总量
    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }
}
```

我们可以直接使用 OpenZeppelin 的 ERC20 合约库来实现 WETH 合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract WETH is ERC20 {
    // 记录存入 ETH 的事件
    event Deposit(address indexed account, uint amount);

    // 记录提取 ETH 的事件
    event Withdrawal(address indexed account, uint amount);

    // 初始化 WETH 合约
    constructor() ERC20("Wrapped Ether", "WETH") {}

    // 使合约可以接受 ETH
    receive() external payable {
        deposit();
    }

    // 接受 ETH 并将其转换为 WETH
    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    // 将 WETH 转换回 ETH 并提取到调用者的地址
    function withdraw(uint amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }
}
```

1. 部署 WETH 合约

2. 调用 WETH 合约的 deposit 函数，设置传入的 ETH 数量，这里以 1 ETH 为例

3. 调用 WETH 合约继承的 balanceOf 函数，传入部署 WETH 合约的地址，查看 WETH 余额

4. 调用 WETH 合约继承的 totalSupply 函数，查看合约中存储的 ETH 总量

5. 调用 WETH 合约的 withdraw 函数，传入提取的 WETH 数量，提取 ETH

6. 调用 WETH 合约继承的 balanceOf 函数，查看 WETH 余额

7. 调用 WETH 合约继承的 totalSupply 函数，查看合约中存储的 ETH 总量

<br><br>

# Awesome Project

当然可以！以下是包括 OpenZeppelin 在内的一些主要开源项目，它们提供智能合约开发、部署和管理的工具和库：

1. **OpenZeppelin**

-   简介：OpenZeppelin 提供了一系列用于开发、部署和管理智能合约的工具和库，专注于区块链安全。
-   特点：经过审计和社区验证的智能合约库，涵盖常见的 ERC 标准和其他实用合约。
-   用途：广泛应用于 DeFi、DAO 和代币发行等领域。

2. **Solmate**

-   简介：Solmate 提供了一组用于 Solidity 智能合约开发的开源构建模块，注重 Gas 优化。
-   特点：轻量级、高效、易于集成。
-   用途：适用于需要高效执行的智能合约开发。

3. **Solady**

-   简介：Solady 是 Solmate 的一个分支，专注于 Gas 优化的 Solidity 代码片段。
-   特点：进一步优化了 Gas 消耗，适用于需要极致性能的场景。
-   用途：适用于高频交易和复杂计算的智能合约。

4. **Solbase**

-   简介：Solbase 提供了一个现代化且 Gas 优化的智能合约开发基础库。
-   特点：模块化设计，易于扩展和维护。
-   用途：适用于各种智能合约开发需求。

5. **Gnosis Safe**

-   简介：Gnosis Safe 是一个多签名钱包解决方案，提供了安全的资产管理工具。
-   特点：支持多签名、模块化扩展、高度安全。
-   用途：适用于需要多方签名和高安全性的资产管理。

6. **Truffle Suite**

-   简介：Truffle 是一个开发框架，提供了智能合约编译、部署和测试工具。
-   特点：集成了 Ganache 和 Drizzle，支持全面的开发和测试流程。
-   用途：适用于全栈区块链开发，特别是以太坊生态系统。

7. **Hardhat**

-   简介：Hardhat 是一个以太坊开发环境，提供了智能合约编译、部署和调试工具。
-   特点：支持插件扩展、内置调试工具、与 Ethers.js 和 Waffle 集成。
-   用途：适用于需要灵活开发环境和高级调试功能的开发者。

8. **CertiK**

-   简介：CertiK 提供智能合约的安全审计和验证服务，确保合约的安全性和正确性。
-   特点：专业的安全审计团队、自动化验证工具。
-   用途：适用于需要高安全性和合约审计的项目。

9. **Quantstamp**

-   简介：Quantstamp 提供智能合约的自动化安全审计服务，帮助发现和修复潜在漏洞。
-   特点：自动化审计、详细的安全报告。
-   用途：适用于需要快速和全面安全审计的项目。

这些项目各有其特点和优势，开发者可以根据具体需求选择合适的工具和库。

<br><br>

# Constant Sum Automated Market Maker

恒和自动市场制造商 (CSAMM) 是一种去中心化交易协议，用于在区块链上实现自动化的代币交易。与常见的恒定乘积做市商（如 Uniswap）不同，CSAMM 使用恒定和公式来确定交易价格。

在 CSAMM 中，交易价格由以下公式决定：`x + y = k`，其中 `x` 和 `y` 分别代表池中的两种代币数量，`k` 是一个常数，表示池中两种代币数量的总和。

由于使用恒定和公式，CSAMM 在价格波动较小时表现较好，适用于稳定币之间的交易。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ConstantSumAMM {
    // 合约中两种代币的实例
    IERC20 public immutable tokenX;
    IERC20 public immutable tokenY;

    // 两种代币的总供应量
    uint public totalSupplyX;
    uint public totalSupplyY;

    // 池中总的流动性份额
    uint public totalSupply;

    // 记录每个用户的流动性份额
    mapping(address => uint) public balanceOf;

    // 初始化两种代币的实例
    constructor(address _tokenX, address _tokenY) {
        tokenX = IERC20(_tokenX);
        tokenY = IERC20(_tokenY);
    }

    // 发行新的代币
    function _mint(address to, uint amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    // 销毁代币
    function _burn(address from, uint amount) internal {
        totalSupply -= amount;
        balanceOf[from] -= amount;
    }

    // 在两种代币之间进行交换
    function swap(
        address _tokenIn,
        uint _amountIn
    ) external returns (uint amountOut) {
        require(
            _tokenIn == address(tokenX) || _tokenIn == address(tokenY),
            "Invalid token"
        );

        // 确定传入的代币为 tokenX 还是 tokenY
        bool isX = _tokenIn == address(tokenX);

        // 根据传入的代币确定两种代币的实例和总供应量
        (
            IERC20 tokenIn,
            IERC20 tokenOut,
            uint totalSupplyIn,
            uint totalSupplyOut
        ) = isX
                ? (tokenX, tokenY, totalSupplyX, totalSupplyY)
                : (tokenY, tokenX, totalSupplyY, totalSupplyX);

        // 用户将代币转移到合约中
        tokenIn.transferFrom(msg.sender, address(this), _amountIn);

        // 计算用户实际转移的代币数量
        uint amountIn = tokenIn.balanceOf(address(this)) - totalSupplyIn;

        // 计算用户可以获得的代币数量
        amountOut = (amountIn * 997) / 1000; // 0.3% 手续费

        // 更新两种代币的总供应量
        totalSupplyIn += amountIn;
        totalSupplyOut -= amountOut;

        // 将代币转移给用户
        tokenOut.transfer(msg.sender, amountOut);
    }

    // 向池中添加流动性，获得相应的份额
    function addLiquidity(
        uint amountX,
        uint amountY
    ) external returns (uint shares) {
        // 用户将代币转移到合约中
        tokenX.transferFrom(msg.sender, address(this), amountX);
        tokenY.transferFrom(msg.sender, address(this), amountY);

        // 计算用户实际转移的代币数量
        uint _amountX = tokenX.balanceOf(address(this)) - totalSupplyX;
        uint _amountY = tokenY.balanceOf(address(this)) - totalSupplyY;

        // 计算用户可以获得的份额
        if (totalSupply == 0) {
            // 对于第一次添加流动性的用户，直接按照转移的代币数量计算份额
            shares = _amountX + _amountY;
        } else {
            shares =
                ((_amountX + _amountY) * totalSupply) /
                (totalSupplyX + totalSupplyY);
        }

        // 发行份额给用户
        require(shares > 0, "Invalid shares");
        _mint(msg.sender, shares);

        // 更新两种代币的总供应量
        totalSupplyX += _amountX;
        totalSupplyY += _amountY;
    }

    // 根据持有的份额提取流动性
    function removeLiquidity(
        uint shares
    ) external returns (uint amountX, uint amountY) {
        // 计算用户可以获得的代币数量
        amountX = (shares * totalSupplyX) / totalSupply;
        amountY = (shares * totalSupplyY) / totalSupply;

        // 销毁用户的份额
        _burn(msg.sender, shares);

        // 更新两种代币的总供应量
        totalSupplyX -= amountX;
        totalSupplyY -= amountY;

        // 将代币转移给用户
        require(amountX > 0 && amountY > 0, "Invalid amount");
        tokenX.transfer(msg.sender, amountX);
        tokenY.transfer(msg.sender, amountY);
    }
}
```

编写测试合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint amount) external {
        _mint(to, amount);
    }
}
```

1. 部署两次 MyToken 合约，分别作为两种代币，这里分别命名为 `tokenX` 和 `tokenY`，符号分别为 `X` 和 `Y`

2. 部署 ConstantSumAMM 合约，传入 `tokenX` 和 `tokenY` 的地址

3. 调用 `tokenX` 合约的 mint 函数，传入编辑器地址和 `1000`，表示在 `tokenX` 合约中发行 `1000` 个代币

4. 调用 `tokenY` 合约的 mint 函数，传入编辑器地址和 `1000`，表示在 `tokenY` 合约中发行 `1000` 个代币

5. 调用 `tokenX` 合约的 approve 函数，传入 ConstantSumAMM 合约的地址和 `500`，表示授权 ConstantSumAMM 合约从 `tokenX` 合约中转移 `500` 个代币

6. 调用 `tokenY` 合约的 approve 函数，传入 ConstantSumAMM 合约的地址和 `800`，表示授权 ConstantSumAMM 合约从 `tokenY` 合约中转移 `800` 个代币

测试 addLiquidity：

1. 调用 ConstantSumAMM 合约的 addLiquidity 函数，传入 `400` 和 `600`，表示向 ConstantSumAMM 合约中添加 `400` 个 `tokenX` 和 `600` 个 `tokenY`，获得相应的份额

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `1000`、两种代币的总供应量 totalSupplyX 为 `400`、totalSupplyY 为 `600`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `1000`

3. 查看 `tokenX` 和 `tokenY` 合约的余额，可以看到用户的 `tokenX` 余额变成了 `600`、`tokenY` 余额变成了 `400`

测试 swap：

1. 调用 ConstantSumAMM 合约的 swap 函数，传入 `tokenX` 的地址和 `100`，表示用户用 `100` 个 `tokenX` 交换 `tokenY`，获得相应的代币数量

2. 查看 `tokenX` 和 `tokenY` 合约的余额，可以看到用户的 `tokenX` 余额变成了 `500`、`tokenY` 余额变成了 `499`，表示用户用 `100` 个 `tokenX` 交换了 `99` 个 `tokenY`

测试 removeLiquidity：

1. 调用 ConstantSumAMM 合约的 removeLiquidity 函数，传入 `500`，表示用户提取 `500` 份额的流动性，获得相应的代币数量

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `500`、两种代币的总供应量 totalSupplyX 为 `200`、totalSupplyY 为 `300`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `500`

3. 查看 `tokenX` 和 `tokenY` 合约的余额，可以看到用户的 `tokenX` 余额变成了 `700`、`tokenY` 余额变成了 `799`

<br><br>
