# ABI 解码

ABI 编码将函数调用和参数转换为字节数据，以便在以太坊网络上传输。解码则是将这些字节数据还原为原始类型。

数据编码：用于与智能合约交互时的参数编码。

1. abi.encode：每个参数都会被填充为 32 字节的数据，并拼接在一起

2. abi.encodePacked：类似 abi.encode，但会省略其中填充的零

函数编码：用于调用其他合约的函数。

1. abi.encodeWithSignature：第一个参数为函数签名，后面的参数为函数参数

2. abi.encodeWithSelector：第一个参数为函数选择器，后面的参数为函数参数

解码：

1. abi.decode：接受两个参数：编码后的数据和类型列表

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract ABIDecodeExample {
    function encodeData() external pure returns (bytes memory) {
        uint a = 1;
        address b = 0x1234567890123456789012345678901234567890;
        string memory c = "Hello, World!";
        return abi.encode(a, b, c);
    }

    function decodeData(
        bytes memory data
    ) external pure returns (uint, address, string memory) {
        (uint a, address b, string memory c) = abi.decode(
            data,
            (uint, address, string)
        );
        return (a, b, c);
    }
}
```

<br><br>

# 函数选择器

函数选择器（Function Selector）可以标识智能合约中的特定函数。主要用于智能合约的调用和交互。

<br>

## 函数选择器的生成

函数选择器通过对函数签名进行 Keccak-256 哈希计算得到的前 4 个字节。

函数签名由函数名称和参数类型组成，中间没有空格。例如，对于以下函数：

```solidity
function transfer(address recipient, uint amount) external returns (bool);
```

其函数签名为：

```
transfer(address,uint)
```

通过 Keccak-256 哈希计算得到的前 4 个字节就是该函数的选择器。

<br>

## 计算函数选择器

可以使用 Solidity 内置的 `selector` 属性或手动计算函数选择器。以下是两种方法的示例：

```solidity
bytes4 selector = this.transfer.selector;
bytes4 selector = bytes4(keccak256("transfer(address,uint)"));
```

<br>

## Demo

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Receiver {
    event Log(bytes data);

    function transfer(
        address to,
        uint amount
    ) public returns (address, uint) {
        emit Log(msg.data);
        return (to, amount);
    }
}

contract FunctionSelector {
    // 传入函数签名 transfer(address,uint)
    function getSelector(string memory signature) public pure returns (bytes4) {
        return bytes4(keccak256(bytes(signature)));
    }
}
```

1. 部署 Receiver、FunctionSelector 合约

2. 调用 Receiver 合约的 transfer 方法，这里我传入的参数是 `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` 和 `123`：

3. 查看 Log 事件，可以看到打印了：

```
0xa9059cbb0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000007b
```

4. 调用 FunctionSelector 合约的 getSelector 方法，传入函数签名 `transfer(address,uint)`，可以得到函数选择器：

```
0xa9059cbb // 可以看到和上面 Log 的前 4 个字节是一样的
```

5. 上面的 Log 中，剩下的部分是参数 `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` 和 `123` 的 16 进制转换结果。

<br><br>

# Gas Golf

Gas Golf 是一种优化智能合约以减少 Gas 消耗的技术。

Gas 是以太坊网络上执行交易和智能合约所需的计算资源的度量单位。通过优化代码，可以显著降低交易成本，提高合约的效率。

以下是一些常见的 Gas 优化技巧：

1. 使用 calldata 代替 memory

calldata 是一种只读数据位置，适用于函数参数。

```solidity
function example(uint[] calldata nums) external {
    // 使用 calldata 代替 memory
}
```

2. 将状态变量加载到内存中

频繁访问状态变量会消耗大量 Gas。将状态变量加载到内存中可以减少重复访问的开销。

```solidity
uint public total;

function example() external {
    uint _total = total;
    // 使用 _total 代替 total
    total = _total;
}
```

3. 使用前置递增运算符

在循环中，使用 ++i 代替 i++ 可以节省 Gas，因为前置递增运算符更高效。

```solidity
for (uint i = 0; i < nums.length; ++i) {
    // 使用 ++i 代替 i++
}
```

4. 缓存数组长度

在循环中，频繁访问数组的长度会消耗 Gas。将数组长度缓存到局部变量中可以减少开销。

```solidity
uint len = nums.length;
for (uint i = 0; i < len; ++i) {
    // 使用缓存的 len 代替 nums.length
}
```

5. 短路求值

在逻辑运算中，使用短路求值可以避免不必要的计算，从而节省 Gas。

```solidity
if (condition1 && condition2) {
    // 如果 condition1 为 false，则不会计算 condition2
}
```

6. 使用 unchecked 块

在某些情况下，可以使用 unchecked 块来避免溢出检查，从而节省 Gas。

```solidity
unchecked {
    ++i;
}
```

7. 将常访问的值缓存到内存中

在循环中，将常访问的值缓存到内存中可以减少重复访问的开销。

```solidity
for (uint i = 0; i < nums.length; i++) {
    uint num = nums[i];
    // 使用 num 代替 nums[i]
}
```

demo：

```solidity
// 未优化的代码
function sumIfEvenAndLessThan99(uint[] memory nums) external {
    for (uint i = 0; i < nums.length; i++) {
        bool isEven = nums[i] % 2 == 0;
        bool isLessThan99 = nums[i] < 99;
        if (isEven && isLessThan99) {
            total += nums[i];
        }
    }
}

// 优化后的代码
function sumIfEvenAndLessThan99(uint[] calldata nums) external {
    uint _total = total;
    uint len = nums.length;
    for (uint i = 0; i < len;) {
        uint num = nums[i];
        if (num % 2 == 0 && num < 99) {
            _total += num;
        }
        unchecked {
            ++i;
        }
    }
    total = _total;
}
```

<br>
