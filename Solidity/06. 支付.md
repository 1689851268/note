# 单位

wei、gwei、finney 和 ether 是以太币（Ether）的不同单位

1. wei 是以太币的最小单位，1 ether = 10^18 wei；这是 Solidity 中的默认单位

```solidity
uint public oneWei = 1 wei;
```

2. gwei 是 wei 的 10^9 倍，1 ether = 10^9 gwei；常用于表示交易费用 (gas price)

```solidity
uint public oneGwei = 1 gwei;
```

3. finney 是 wei 的 10^15 倍，1 ether = 10^3 finney

```solidity
uint public oneFinney = 1 finney;
```

4. ether 是 wei 的 10^18 倍，1 ether = 1 ether；是以太坊的基本单位

```solidity
uint public oneEther = 1 ether;
```

<br><br>

# payable

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 用 payable 修饰符修饰 owner 变量
    address payable public owner;

    constructor() {
        // 使用 payable() 函数将 msg.sender 转换为 payable 的 address 类型
        owner = payable(msg.sender);
    }

    // 用 payable 修饰符修饰 deposit 函数
    function deposit() public payable {}

    function getBalance() public view returns (uint) {
        // 获取 owner 的余额并返回
        return address(this).balance;
    }
}
```

<br><br>

# receive & fallback

在 Solidity 中，receive & fallback 是一种特殊的函数。声明形式为 `receive/fallback() external payable { ... }`。它不需要 `function` 关键字，没有参数，也没有返回值。

**特性**：

-   唯一性：一个合约最多只能有一个 receive & fallback 方法。
-   可见性：必须声明为 `external`，表示只能通过外部调用来触发。
-   支付能力：receive 必须使用 `payable` 修饰符；fallback 可以使用 `payable` 修饰符。

**receive & fallback 的区别**：

-   receive：专门用于处理没有附加数据的以太币转账。
-   fallback：用于处理所有其他情况，包括调用不存在的函数或接收带有附加数据的以太币转账。如果合约没有定义 `receive` 方法，但定义了 `payable` 的 `fallback` 方法，那么在接收以太币时会调用 `fallback` 方法。

**demo1**：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract ReceiveExample {
    event Log(string message, address sender, uint256 value, bytes data);

    // 定义 receive 方法
    receive() external payable {
        emit Log("receive", msg.sender, msg.value, "");
    }

    // 定义 fallback 方法
    fallback() external payable {
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }
}
```

**demo2**：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract ReceiveExample {
    // 声明一个变量，用于存储接收到的以太币数量
    uint256 private receivedAmount;

    // 定义 receive 方法
    receive() external payable {
        receivedAmount += msg.value; // 更新接收到的以太币数量
    }

    // 定义 fallback 方法
    fallback() external payable {
        revert("fallback");
    }

    // 获取合约的余额
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
```

<br><br>

# 以太币的发送与接收

在 Solidity 中，有 3 种方法发送以太币：

1.  transfer：消耗 2300 gas；如果发送失败，会回退交易
2.  send：消耗 2300 gas；会返回一个布尔值，表示发送成功/失败（较少使用）
3.  call：消耗所有 gas；会返回一个布尔值，表示发送成功/失败、还会返回一些数据（推荐使用）

有 2 种方法接收以太币：

1. 用 payable 修饰 constructor，接收部署时传入的以太币
2. 编写 receive 或 fallback 方法，接收以太币

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract SendEther {
    // 使用 transfer 方法发送以太币
    function sendViaTransfer(address payable _to) public payable {
        _to.transfer(msg.value);
    }

    // 使用 send 方法发送以太币
    function sendViaSend(address payable _to) public payable {
        bool sent = _to.send(msg.value);
        require(sent, "Send failed");
    }

    // 使用 call 方法发送以太币
    function sendViaCall(address payable _to) public payable {
        (bool success, ) = _to.call{value: msg.value}("");
        require(success, "Call failed");
    }
}

contract ReceiveEther {
    // 接收部署时传入的以太币
    constructor() payable {}

    event Received(address, uint, uint);

    // 接收以太币
    receive() external payable {
        // 打印发送者、接收的以太币数量、剩余的 gas
        emit Received(msg.sender, msg.value, gasleft());
    }
}
```

<br>

demo：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract EtherDemo {
    address payable public owner;

    constructor() {
        owner = payable(msg.sender);
    }

    function withdraw(uint _amount) public {
        require(msg.sender == owner, "You are not the owner");

        // 1. transfer (使用内存里面的 msg.sender 会节省一些 gas)
        payable(msg.sender).transfer(_amount);

        // 2. call (使用内存里面的 msg.sender 会节省一些 gas)
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed.");

        // 3. send (使用内存里面的 msg.sender 会节省一些 gas)
        bool sent = payable(msg.sender).send(_amount);
        require(sent, "Failed to send Ether");
    }

    receive() external payable {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
```

<br>
