# 部署合约

我们可以通过合约的 creation code 部署合约，并获取合约地址。creation code = 合约代码 code 的长度 (占 32 byte) + 合约代码 code

实现合约部署功能需要在 Solidity 的内联汇编 `assembly { ... }` 里面调用 create 方法。

create 方法：`create(v, p, n)`；`v` 表示要发送的以太数量、`p` 是合约代码 code 的起始指针，用于告诉 Solidity 编译器合约代码 code 的起始位置、`n` 表示合约代码 code 的长度；create 方法会部署合约并返回合约地址。

注意 ①：在 Solidity 中 发送的以太数量用 `msg.value` 表示，但在汇编中 用 `callvalue()` 表示；注意 ②：deployDemo 方法的入参 `_creationCode` = 合约代码 code 的长度 (占 32 byte) + 合约代码 code，所以传入 `p` 时要跳过 32 byte，在汇编中可以通过 `add(_creationCode, 0x20)` 实现；注意 ③：合约代码 code 的长度 `n` 在汇编中可以用 `mload(_creationCode)` 获取。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner = msg.sender;
}

contract Proxy {
    function deployDemo(
        bytes memory _code // 合约的 creation code
    ) public payable returns (address addr) {
        assembly {
            // 部署合约, 获取合约地址并返回
            addr := create(callvalue(), add(_code, 0x20), mload(_code))
        }
        // 检查合约地址的有效性
        require(addr != address(0), "Failed to deploy contract");
    }
}

contract Helper {
    function getByteCode() public pure returns (bytes memory) {
        return type(Demo).creationCode; // 获取 Demo 级二月的 creation code 并返回
    }
}
```

这里的 Helper 合约仅作演示，日常开发中可以使用 Web3.js、Ether.js 等工具库获取合约的 creation code ~

<br>

**操作 Remix 部署合约**：

1. 部署 Helper 合约、Proxy 合约

<img src="./picture/image-20240811164544282.png" alt="image-20240811164544282" style="zoom:33%;" />

2.  执行 Helper 合约的 getByteCode 方法，得到 Demo 合约的 creation code

<img src="./picture/image-20240811164625043.png" alt="image-20240811164625043" style="zoom:33%;" />

3.  将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

<img src="./picture/image-20240811164810560.png" alt="image-20240811164810560" style="zoom:33%;" />

4.  通过 Demo 合约的地址添加 Demo 合约到 Remix

<img src="./picture/image-20240811164929764.png" alt="image-20240811164929764" style="zoom:33%;" />

5.  检查 Demo 合约的 owner 是否为 Proxy 合约的地址

<img src="./picture/image-20240811165014364.png" alt="image-20240811165014364" style="zoom:33%;" />

<br><br>

# 部署合约并传入参数

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner = msg.sender;
    uint public count;

    constructor(uint _count) {
        count = _count;
    }
}

contract Proxy {
    function deployDemo(
        bytes memory _code
    ) public returns (address addr) {
        assembly {
            addr := create(callvalue(), add(_code, 0x20), mload(_code))
        }
        require(addr != address(0), "Failed to deploy contract");
    }
}

contract Helper {
    function getByteCode(uint256 _count) public pure returns (bytes memory) {
        return abi.encodePacked(type(Demo).creationCode, abi.encode(_count));
        // 传入参数 _count, 获取 Demo 合约的 creation code 并返回
    }
}
```

<br>

**操作 Remix 部署合约**：

1. 部署 Helper 合约、Proxy 合约

2. 传入参数 \_count 到 Helper 合约的 getByteCode 方法并执行，得到 Demo 合约的 creation code

<img src="./picture/image-20240811165438575.png" alt="image-20240811165438575" style="zoom:33%;" />

3.  将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

4.  通过 Demo 合约的地址添加 Demo 合约到 Remix

5.  检查 Demo 合约的 owner 是否为 Proxy 合约的地址、count 是否为步骤 2 中传入的参数

<img src="./picture/image-20240811165523249.png" alt="image-20240811165523249" style="zoom:33%;" />

<br><br>

# 部署合约并传输以太

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner = msg.sender;
    uint public value = msg.value;

    constructor() payable {} // 使用 payable 修饰构造方法, 以支持以太的传输
}

contract Proxy {
    function deployDemo(
        bytes memory _code
    ) public payable returns (address addr) {
    	// 使用 payable 修饰方法, 以支持以太的传输
        assembly {
            addr := create(callvalue(), add(_code, 0x20), mload(_code))
        }
        require(addr != address(0), "Failed to deploy contract");
    }
}

contract Helper {
    function getByteCode() public pure returns (bytes memory) {
        return type(Demo).creationCode;
    }
}
```

<br>

**操作 Remix 部署合约**：

1. 部署 Helper 合约、Proxy 合约

2. 执行 Helper 合约的 getByteCode 方法，得到 Demo 合约的 creation code

3. 设置以太数量、将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

<img src="./picture/image-20240811165632847.png" alt="image-20240811165632847" style="zoom:33%;" />

4.  通过 Demo 合约的地址添加 Demo 合约到 Remix

5.  检查 Demo 合约的 owner 是否为 Proxy 合约的地址、value 是否为步骤 3 中传输的以太数量

<br><br>

# 调用合约方法并传入参数

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner = msg.sender;

    function setOwner(address _owner) external {
        require(msg.sender == owner, "Only owner can change owner");
        owner = _owner;
    }
}

contract Proxy {
    function deployDemo(bytes memory _code) public returns (address addr) {
        assembly {
            addr := create(callvalue(), add(_code, 0x20), mload(_code))
        }
        require(addr != address(0), "Failed to deploy contract");
    }

    function executeDemo(
        address _addr, // 合约的地址
        bytes memory _data // 想调用的方法的 calldata
    ) public returns (bytes memory result) {
        // 通过 call 方法可以调用 _addr 表示的合约中 calldata 表示的方法, 并获取调用结果
        (bool success, bytes memory data) = _addr.call(_data);
        require(success, "Failed to execute contract");
        return data;
    }
}

contract Helper {
    function getByteCode() public pure returns (bytes memory) {
        return type(Demo).creationCode;
    }

    function getCallData(address _addr) public pure returns (bytes memory) {
        return abi.encodeWithSignature("setOwner(address)", _addr);
        // 传入参数 _addr, 获取 "setOwner(address)" 方法的 calldata 并返回
    }
}
```

<br>

**操作 Remix 部署合约**：

1. 部署 Helper 合约、Proxy 合约

2. 执行 Helper 合约的 getByteCode 方法，得到 Demo 合约的 creation code

3. 将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

4. 通过 Demo 合约的地址添加 Demo 合约到 Remix

5. 检查 Demo 合约的 owner 是否为 Proxy 合约的地址

<br>

**操作 Remix 调用方法**：

1.  将编辑器地址作为参数传入 Helper 合约的 getCallData 方法，得到 "setOwner(address)" 的 calldata

<img src="./picture/image-20240811171616644.png" alt="image-20240811171616644" style="zoom:33%;" />

2.  将 Demo 合约的地址和 "setOwner(address)" 的 calldata 作为参数传入 Proxy 合约的 executeDemo 方法，以更新 Demo 合约的 owner

<img src="./picture/image-20240811171706459.png" alt="image-20240811171706459" style="zoom:33%;" />

3.  检查 Demo 合约的 owner 是否为编辑器地址

<img src="./picture/image-20240811171731127.png" alt="image-20240811171731127" style="zoom:33%;" />

<br><br>

# 调用合约方法并传输以太

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner = msg.sender;
    uint public value = msg.value;

    function updateValue() external payable {
        require(msg.sender == owner, "Only owner can update value");
        value = msg.value;
    }
}

contract Proxy {
    function deployDemo(bytes memory _code) public payable returns (address addr) {
        assembly {
            addr := create(callvalue(), add(_code, 0x20), mload(_code))
        }
        require(addr != address(0), "Failed to deploy contract");
    }

    function executeDemo(
        address _addr,
        bytes memory _data
    ) public payable returns (bytes memory result) {
    	// 使用 payable 修饰方法, 以支持以太的传输; 调用 call 方法时传入 msg.value
        (bool success, bytes memory data) = _addr.call{value: msg.value}(_data);
        require(success, "Failed to execute contract");
        return data;
    }
}

contract Helper {
    function getByteCode() public pure returns (bytes memory) {
        return type(Demo).creationCode;
    }

    function getCallData() public pure returns (bytes memory) {
        return abi.encodeWithSignature("updateValue()");
        // 获取 "updateValue()" 方法的 calldata 并返回
    }
}
```

<br>

**操作 Remix 部署合约**：

1. 部署 Helper 合约、Proxy 合约

2. 执行 Helper 合约的 getByteCode 方法，得到 Demo 合约的 creation code

3. 将 Demo 合约的 creation code 作为参数传入 Proxy 合约的 deployDemo 方法并执行，部署 Demo 合约并得到其地址

4. 通过 Demo 合约的地址添加 Demo 合约到 Remix

5. 检查 Demo 合约的 owner 是否为 Proxy 合约的地址

<br>

**操作 Remix 调用方法**：

1.  执行 Helper 合约的 getCallData 方法，得到 "updateValue()" 的 calldata

2.  设置以太数量、将 Demo 合约的地址和 "updateValue()" 的 calldata 作为参数传入 Proxy 合约的 executeDemo 方法，以更新 Demo 合约的 value

3.  检查 Demo 合约的 value 是否为步骤 2 中传输的以太数量

<br>
