# Hello World

1.  进入在线编辑器 https://remix.ethereum.org
2.  创建并编写 HelloWorld.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract HelloWorld {
	// public: 可以被合约内部和外部调用
    string public myStr = "Hello World";
}
```

3.  编译 HelloWorld.sol

确保编辑器使用的 Solidity 版本与你代码中声明的一样：

<img src="./picture/image-20240804131447522.png" alt="image-20240804131447522" style="zoom:50%;" />

点击按钮开始编译：

<img src="./picture/image-20240804131625275.png" alt="image-20240804131625275" style="zoom:50%;" />

4.  部署 HelloWorld.sol

<img src="./picture/image-20240804132027565.png" alt="image-20240804132027565" style="zoom:50%;" />

现在 HelloWorld 就部署到本地啦~

<img src="./picture/image-20240804132130495.png" alt="image-20240804132130495" style="zoom:50%;" />

<br><br>

# 数据类型

常用数据类型：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Type {
    string public s;

    bool public b;

    address public addr;

    uint public ui; // uint is an alias for uint256; 0 ~ 2^256-1
    // uint8, uint16, uint32, ... uint256

    int public i; // int is an alias for int256; -2^255 ~ 2^255-1
    // int8, int16, int32, ... int256

    bytes public bys; // bytes is an alias for bytes1; 0x00 ~ 0xff
    // bytes1, bytes2, bytes3, ... bytes32
}
```

可以在 Remix 中部署并查看对应类型的默认值：

<img src="./picture/image-20240804154438613.png" alt="image-20240804154438613" style="zoom: 80%;" />

在 Solidity 中可以直接通过 API 获取指定数字类型的最大最小值：

```solidity
contract MaxAndMinInt {
    uint public max = type(uint).max; // 2^256-1
    uint public min = type(uint).min; // 0

    int public maxInt = type(int).max; // 2^255-1
    int public minInt = type(int).min; // -2^255
}
```

<br><br>

# 函数

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Function {
    uint public num = 10;

    function add(uint x, uint y) external pure returns (uint) {
        // external: 只能被合约外部调用, 不能被合约内部调用
        // pure: 既不读取也不修改合约状态
        return x + y;
    }

    function getNum() external view returns (uint) {
        // view: 读取合约状态但不修改状态
        return num;
    }
}
```

<br><br>

# 变量

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Variable {
    uint public stateVariable = 0; // 状态变量, 会把数据存储在区块链上

    function getLocalVariable() external pure returns (uint) {
        uint localVariable = 0; // 局部变量
        return localVariable;
    }
}
```

<br><br>

# 全局变量

全局变量主要用于提供 [关于区块链的信息] / [工具函数]：

1. 区块属性：

    - `block.basefee (uint)`：当前区块的基础费用。
    - `block.chainid (uint)`：当前链的 ID。
    - `block.coinbase (address)`：当前区块的矿工地址。
    - `block.difficulty (uint)`：当前区块的难度。
    - `block.gaslimit (uint)`：当前区块的 gas 限额。
    - `block.number (uint)`：当前区块号。
    - `block.timestamp (uint)`：当前区块的时间戳。

2. 交易属性：

    - `tx.gasprice (uint)`：交易的 gas 价格。
    - `tx.origin (address)`：交易发起者的地址。

3. 消息属性：

    - `msg.data (bytes)`：完整的 calldata。
    - `msg.sender (address)`：消息发送者的地址（当前调用者）。
    - `msg.sig (bytes4)`：calldata 的前 4 字节（函数选择器）。
    - `msg.value (uint)`：随消息发送的 wei 数量。

4. 工具函数：
    - `gasleft() returns (uint256)`：返回当前剩余的 gas 数量。
    - `abi.encode(...) returns (bytes)`：对给定的参数进行 ABI 编码。
    - `abi.decode(bytes memory encodedData, (...)) returns (...)`：对给定的数据进行 ABI 解码。
    - `blockhash(uint blockNumber) returns (bytes32)`：返回指定区块的哈希值（仅适用于最近的 256 个区块）。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract GlobalVariables {
    function getGlobalVariables() public view returns (address, uint, uint) {
        address sender = msg.sender; // 调用者地址
        uint blockNumber = block.number; // 区块号
        uint timestamp = block.timestamp; // 调用该函数时的时间戳
        return (sender, blockNumber, timestamp);
    }
}
```

<br><br>

# pure & view

-   pure：不修改状态变量、不读取状态变量
-   view：不修改状态变量、读取状态变量

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint public x = 10;

    function pureFunc(uint a, uint b) public pure returns (uint) {
        return a * b;
    }

    function viewFunc() public view returns (uint) {
        return x;
    }
}
```

会修改状态变量的函数不需要关键字修饰：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Counter {
    uint public count;

    function increment() external {
        count++;
    }

    function decrement() external {
        count--;
    }
}
```

<br><br>

# constant

constant 用于声明常量：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint256 public constant NUM = 100;
    uint256 public num = 100;
}
```

常量会比变量消耗更少的 gas ~

<br><br>

# 条件判断

Solidity 的条件判断语法与 JS 一样：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 条件判断
    function testIf(uint256 a, uint256 b) public pure returns (uint256) {
        if (a > b) {
            return a;
        } else {
            return b;
        }
    }

    // 三元运算符
    function testTernary(uint256 a, uint256 b) public pure returns (uint256) {
        return a > b ? a : b;
    }
}
```

需要注意的是，Solidity 中不支持 switch case 语法。

<br><br>

# 循环

for 循环：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    function forLoop() public pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < 10; i++) {
            if (i == 3) continue;
            if (i == 5) break;
            sum += i;
        }
        return sum;
    }
}
```

while 循环：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    function whileLoop() public pure returns (uint256) {
        uint256 sum = 0;
        uint256 i = 0;
        while (i < 10) {
            if (i == 3) {
                i++;
                continue;
            }
            if (i == 5) break;
            sum += i;
            i++;
        }
        return sum;
    }
}
```

do while 循环：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    function doWhileLoop() public pure returns (uint256) {
        uint256 sum = 0;
        uint256 i = 0;
        do {
            if (i == 3) {
                i++;
                continue;
            }
            if (i == 5) break;
            sum += i;
            i++;
        } while (i < 10);
        return sum;
    }
}
```

需要注意的是，在 Solidity 中需要控制好循环的次数，因为循环得越多 消耗的 gas 就越多~

<br><br>

# 异常处理

在 Solidity 中，有 3 种方法抛出异常：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 1. require
    function testRequire(uint256 a) public pure returns (uint256) {
        require(a > 10, "a must be greater than 10"); // 若条件不满足, 则会触发异常, 并抛出异常信息
        return a;
    }

    // 2. revert
    function testRevert(uint256 a) public pure returns (uint256) {
        if (a <= 10) {
            revert("a must be greater than 10"); // 触发异常, 并抛出异常信息
        }
        return a;
    }

    // 3. assert
    function testAssert(uint256 a) public pure returns (uint256) {
        assert(a > 10); // 若条件不满足, 则会触发异常
        return a;
    }
}
```

自定义异常 - 用于自定义异常信息：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    error MyError(address sender, uint256 value);

    function testCustomError(uint256 a) public view returns (uint256) {
        if (a <= 10) {
            revert MyError(msg.sender, a); // 触发异常, 并抛出自定义的异常信息
        }
        return a;
    }
}
```

try catch - 适用于处理外部合约调用失败的情况：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

// 外部合约, 用于示例
contract ExternalContract {
    function mayFail(bool _fail) public pure returns (string memory) {
        require(!_fail, "External call failed");
        return "Success";
    }
}

// 主合约, 使用 try/catch 处理外部调用
contract MainContract {
    event Success(string message);
    event Failure(string reason);

    ExternalContract externalContract;

    constructor() {
        externalContract = new ExternalContract();
    }

    function callExternal(bool _fail) public {
        try externalContract.mayFail(_fail) returns (string memory result) {
            emit Success(result);
        } catch Error(string memory reason) {
        	// 处理函数抛出的错误
            emit Failure(reason);
        } catch (bytes memory) {
           // 处理更底层的错误, 比如: out-of-gas、invalid opcode
            emit Failure("Unknown error");
        }
    }
}
```

在 Solidity 中，抛出异常会退还剩余的 gas，并恢复状态变量值。

<br><br>

# 函数装饰器

函数装饰器可以在函数执行之前或之后插入代码逻辑，用于改变函数的行为，比如检查条件、限制访问权限等。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义一个修饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 使用修饰器
    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}
```

修饰器可以接收参数 & 函数可以同时使用多个装饰器：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义一个修饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 定义一个带参数的修饰器
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        // address(0) is often used to represent an invalid or uninitialized address.
        _;
    }

    // 同时使用多个修饰器
    function changeOwner(
        address newOwner
    ) public onlyOwner validAddress(newOwner) {
        owner = newOwner;
    }
}
```

三明治装饰器 demo - 防止重入攻击，这是智能合约安全性的重要方面：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    bool private locked = false;

    // 定义一个防重入攻击的修饰器
    modifier noReentrant() {
        require(!locked, "No Reentrant");
        locked = true;
        _;
        locked = false;
    }

    // 使用防重入攻击的修饰器
    function withdraw() public noReentrant {
        // 提现逻辑
    }
}
```

<br><br>

# 构造函数

构造函数仅在部署合约的时候调用一次，它的作用主要是初始化一些状态变量。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;
    uint public num;

    constructor(uint _num) {
        owner = msg.sender;
        num = _num;
    }
}
```

<br><br>

# 函数输出

在 Solidity 中，函数可以拥有多个输出，且可以为输出命名。在其他函数获取该函数的输出值时，可以使用解构赋值。

demo - 函数拥有多个输出：

```solidity
contract Demo {
    function multipleReturns() public pure returns (uint, bool, string memory) {
        // In Solidity, complex types like string, bytes, and arrays
        // require a data location to be specified. This tells the compiler where the data is stored.
        // data location: memory 会告诉编译器, 变量值存储在内存中; 函数执行完后, 会释放内存
        //                修改 memory 修饰的变量, 不会影响区块链上的数据
        // data location: storage 会告诉编译器, 这个变量是一个引用
        //                修改 storage 修饰的变量, 会影响区块链上的数据
        return (1, true, "Hello, World!");
    }
}
```

demo - 为输出命名：

```solidity
contract Demo {
    function namedReturns1()
        public
        pure
        returns (uint x, bool y, string memory z)
    {
        // 显式返回
        return (1, true, "Hello, World!");
    }

    function namedReturns2()
        public
        pure
        returns (uint x, bool y, string memory z)
    {
        // 隐式返回
        x = 1;
        y = true;
        z = "Hello, World!";
    }
}
```

demo - 解构赋值：

```solidity
contract Demo {
    function get() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = multipleReturns();
        return (a, b, c);
    }

    function getNamed1() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = namedReturns1();
        return (a, b, c);
    }

    function getNamed2() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = namedReturns2();
        return (a, b, c);
    }
}
```

<br><br>

# Array

在 Solidity 中，Array 的 length 可以是动态/固定的。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 固定长度的数组
    uint256[5] public fixedArray = [1, 2, 3, 4, 5];

    // 动态长度的数组
    uint256[] public dynamicArray = [1, 2, 3, 4, 5];
}
```

对动态数组的增删改查：

```solidity
    // 添加元素到动态数组
    function addDynamicArray(uint256 _value) public {
        dynamicArray.push(_value);
    }

    // 获取动态数组的长度
    function getDynamicArrayLength() public view returns (uint256) {
        return dynamicArray.length;
    }

    // 获取动态数组的元素
    function getDynamicArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return dynamicArray[_index];
    }

    // 更新动态数组的元素
    function updateDynamicArrayElement(uint256 _index, uint256 _value) public {
        dynamicArray[_index] = _value;
    }

    // 删除动态数组的元素
    function deleteDynamicArrayElement(uint256 _index) public {
        delete dynamicArray[_index]; // 注意: 这里是将该元素重置为默认值了, 不会改变数组的长度
    }
    // 若想删除指定元素 后面的元素往前移 (eg: [1, 2, 3] 👉 [1, 3]), 可这么实现:
    function deleteNum(uint256 _index) public {
        for (uint i = _index; i < dynamicArray.length - 1; i++) {
            dynamicArray[i] = dynamicArray[i + 1];
        }
        dynamicArray.pop();
    }

    // 删除动态数组的最后一个元素
    function popDynamicArray() public {
        dynamicArray.pop();
    }

    // 删除动态数组的所有元素
    function deleteAllDynamicArray() public {
        delete dynamicArray; // 这里是将数组重置为空数组了, 数组长度变为 0
    }
```

对固定数组的增删改查：

```solidity
    // 添加元素到固定数组
    function addFixedArray(uint256 _value) public {
        // fixedArray.push(_value); // 固定数组不能使用 push 方法
    }

    // 获取固定数组的长度
    function getFixedArrayLength() public view returns (uint256) {
        return fixedArray.length;
    }

    // 获取固定数组的元素
    function getFixedArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return fixedArray[_index];
    }

    // 更新固定数组的元素
    function updateFixedArrayElement(uint256 _index, uint256 _value) public {
        fixedArray[_index] = _value;
    }

    // 删除固定数组的元素
    function deleteFixedArrayElement(uint256 _index) public {
        delete fixedArray[_index]; // 注意: 这里是将该元素重置为默认值了, 不会改变数组的长度
    }

    // 删除动态数组的最后一个元素
    function popFixedArray() public {
        // fixedArray.pop(); // 固定数组不能使用 pop 方法
    }

    // 删除固定数组的所有元素
    function deleteAllFixedArray() public {
        delete fixedArray; // 注意: 这里是将该元素重置为默认值了, 不会改变数组的长度
    }
```

在内存中创建数组：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = new uint[](3); // [0, 0, 0]

    function getArr() public view returns (uint[] memory) {
        return arr;
    }
}
```

注意：① 只能在内存中创建定长数组； ② 在 Solidity 中，我们尽量不要返回一个数组，数组的长度越大 消耗的 gas 就越多。

函数 demo - 接受一个整数数组和一个索引作为参数，移除索引指定的元素并返回新数组：

```solidity
function removeAtIndex(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(arr.length > 0, "Array is empty");
    require(index < arr.length && index >= 0, "Index out of bounds");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < arr.length; i++) {
        if (i < index) {
            newArr[i] = arr[i];
        } else if (i > index) {
            newArr[i - 1] = arr[i];
        }
    }

    return newArr;
}
```

```solidity
function removeAtIndex2(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(index < arr.length && index >= 0, "Index out of bounds");
    require(arr.length > 0, "Array is empty");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < index; i++) {
        newArr[i] = arr[i];
    }

    for (uint i = index; i < arr.length - 1; i++) {
        newArr[i] = arr[i + 1];
    }

    return newArr;
}
```

如果可以打乱数组的顺序，某些情况下可以考虑将想删除的元素与数组最后一位元素交换，然后调用 pop 方法：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = [1, 2, 3, 4, 5];

    function removeAtIndex(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        for (uint i = _index; i < arr.length - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr.pop();
    }

    function removeAtIndex2(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        arr[_index] = arr[arr.length - 1];
        arr.pop();
    }
}
```

<br><br>

# Mapping

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 定义一个 address => uint256 的 mapping
    mapping(address => uint256) public myBalance;

    // 获取 mapping 值
    function getMyBalance() public view returns (uint256) {
        return myBalance[msg.sender]; // 返回调用者的余额; 如果没有设置过, 则返回 uint256 的默认值 0
    }

    // 添加/修改 mapping 值
    function setMyBalance(uint256 _amount) public {
        myBalance[msg.sender] += _amount; // 增加调用者的余额; 如果没有设置过, 则基于 uint256 的默认值 0 进行更新
    }

    // 删除 mapping 值
    function deleteMyBalance() public {
        delete myBalance[msg.sender]; // 删除调用者的余额; 会将调用者的余额设置为 uint256 的默认值 0
    }
}
```

mapping 可以嵌套：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 定义一个嵌套的 mapping
    mapping(address => mapping(address => uint256)) public allowance;

    // 获取嵌套 mapping 值
    function getAllowance(
        address _owner,
        address _spender
    ) public view returns (uint256) {
        return allowance[_owner][_spender]; // 返回 _owner 对 _spender 的授权额度
    }

    // 新增/修改嵌套 mapping 值
    function setAllowance(address _spender, uint256 _amount) public {
        allowance[msg.sender][_spender] = _amount; // 设置调用者对 _spender 的授权额度
    }

    // 删除嵌套 mapping 值
    function deleteAllowance(address _spender) public {
        delete allowance[msg.sender][_spender]; // 删除调用者对 _spender 的授权额度
    }
}
```

demo - 简单的银行账户系统：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract SimpleBank {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        // payable() is a function that converts an address to an address payable
        // transfer() is a function that sends ether to an address
    }

    function checkBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}
```

实现可迭代映射：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    mapping(address => uint) public balance;
    mapping(address => bool) public isCustomer;
    address[] public customers;

    function deposit(address _customer, uint _amount) public {
        balance[_customer] += _amount;
        if (!isCustomer[_customer]) {
            customers.push(_customer);
            isCustomer[_customer] = true;
        }
    }

    function getCustomerBalance(address _customer) public view returns (uint) {
        require(isCustomer[_customer], "Customer does not exist");
        return balance[_customer];
    }

    function getCustomerBalanceByIndex(uint _index) public view returns (uint) {
        require(_index < customers.length && _index >= 0, "Index out of bounds");
        return balance[customers[_index]];
    }
}
```

<br><br>

# Struct

创建 Struct 实例：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    struct Student {
        uint256 id;
        string name;
    }

    Student[] public students;

    function addStudent1(string memory _name) public {
        // 按属性顺序创建 Struct 实例, 并添加到数组
        students.push(Student(students.length, _name));
    }

    function addStudent2(string memory _name) public {
        // 按属性名创建 Struct 实例, 并添加到数组
        students.push(Student({id: students.length, name: _name}));
    }

    function addStudent3(string memory _name) public {
        // 创建 Struct 实例, 但不指定属性值, 会使用默认值
        Student memory student;
        // 设置属性值
        student.id = students.length;
        student.name = _name;
        // 添加到数组
        students.push(student);
    }
}
```

访问 Struct 实例属性：

```solidity
function getStudentInfoByIndex(
    uint256 _index
) public view returns (uint256, string memory) {
    Student memory student = students[_index];
    // memory 会告诉编译器, 变量值存储在内存中; 函数执行完后, 会释放内存
    // 修改 memory 修饰的变量, 不会影响数组的值
    return (student.id, student.name);
}
```

修改 Struct 实例属性：

```solidity
function updateStudentNameByIndex(
    uint256 _index,
    string memory _name
) public {
    Student storage student = students[_index];
    // storage 会告诉编译器, 这个变量是一个引用
    // 修改 storage 修饰的变量, 会影响数组的值
    student.name = _name;
}
```

删除 Struct 实例属性 & 删除 Struct 实例：

```solidity
function deleteStudentNameByIndex(uint256 _index) public {
    Student storage student = students[_index];
    // storage 会告诉编译器, 这个变量是一个引用
    // 修改 storage 修饰的变量, 会影响数组的值
    delete student.name; // 该 delete 会将该属性值重置为默认值
}

function deleteStudentByIndex(uint256 _index) public {
    delete students[_index]; // 该 delete 会将该 Struct 实例的属性值都重置为默认值
}
```

<br><br>
