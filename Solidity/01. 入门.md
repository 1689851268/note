# Hello World

1.  è¿›å…¥åœ¨çº¿ç¼–è¾‘å™¨ https://remix.ethereum.org
2.  åˆ›å»ºå¹¶ç¼–å†™ HelloWorld.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract HelloWorld {
	// public: å¯ä»¥è¢«åˆçº¦å†…éƒ¨å’Œå¤–éƒ¨è°ƒç”¨
    string public myStr = "Hello World";
}
```

3.  ç¼–è¯‘ HelloWorld.sol

ç¡®ä¿ç¼–è¾‘å™¨ä½¿ç”¨çš„ Solidity ç‰ˆæœ¬ä¸ä½ ä»£ç ä¸­å£°æ˜çš„ä¸€æ ·ï¼š

<img src="./picture/image-20240804131447522.png" alt="image-20240804131447522" style="zoom:50%;" />

ç‚¹å‡»æŒ‰é’®å¼€å§‹ç¼–è¯‘ï¼š

<img src="./picture/image-20240804131625275.png" alt="image-20240804131625275" style="zoom:50%;" />

4.  éƒ¨ç½² HelloWorld.sol

<img src="./picture/image-20240804132027565.png" alt="image-20240804132027565" style="zoom:50%;" />

ç°åœ¨ HelloWorld å°±éƒ¨ç½²åˆ°æœ¬åœ°å•¦~

<img src="./picture/image-20240804132130495.png" alt="image-20240804132130495" style="zoom:50%;" />

<br><br>

# æ•°æ®ç±»å‹

å¸¸ç”¨æ•°æ®ç±»å‹ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Type {
    string public s;

    bool public b;

    address public addr;

    uint public ui; // uint is an alias for uint256; 0 ~ 2^256-1
    // uint8, uint16, uint32, ... uint256

    int public i; // int is an alias for int256; -2^255 ~ 2^255-1
    // int8, int16, int32, ... int256

    bytes public bys; // bytes is an alias for bytes1; 0x00 ~ 0xff
    // bytes1, bytes2, bytes3, ... bytes32
}
```

å¯ä»¥åœ¨ Remix ä¸­éƒ¨ç½²å¹¶æŸ¥çœ‹å¯¹åº”ç±»å‹çš„é»˜è®¤å€¼ï¼š

<img src="./picture/image-20240804154438613.png" alt="image-20240804154438613" style="zoom: 80%;" />

åœ¨ Solidity ä¸­å¯ä»¥ç›´æ¥é€šè¿‡ API è·å–æŒ‡å®šæ•°å­—ç±»å‹çš„æœ€å¤§æœ€å°å€¼ï¼š

```solidity
contract MaxAndMinInt {
    uint public max = type(uint).max; // 2^256-1
    uint public min = type(uint).min; // 0

    int public maxInt = type(int).max; // 2^255-1
    int public minInt = type(int).min; // -2^255
}
```

<br><br>

# å‡½æ•°

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Function {
    uint public num = 10;

    function add(uint x, uint y) external pure returns (uint) {
        // external: åªèƒ½è¢«åˆçº¦å¤–éƒ¨è°ƒç”¨, ä¸èƒ½è¢«åˆçº¦å†…éƒ¨è°ƒç”¨
        // pure: æ—¢ä¸è¯»å–ä¹Ÿä¸ä¿®æ”¹åˆçº¦çŠ¶æ€
        return x + y;
    }

    function getNum() external view returns (uint) {
        // view: è¯»å–åˆçº¦çŠ¶æ€ä½†ä¸ä¿®æ”¹çŠ¶æ€
        return num;
    }
}
```

<br><br>

# å˜é‡

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Variable {
    uint public stateVariable = 0; // çŠ¶æ€å˜é‡, ä¼šæŠŠæ•°æ®å­˜å‚¨åœ¨åŒºå—é“¾ä¸Š

    function getLocalVariable() external pure returns (uint) {
        uint localVariable = 0; // å±€éƒ¨å˜é‡
        return localVariable;
    }
}
```

<br><br>

# å…¨å±€å˜é‡

å…¨å±€å˜é‡ä¸»è¦ç”¨äºæä¾› [å…³äºåŒºå—é“¾çš„ä¿¡æ¯] / [å·¥å…·å‡½æ•°]ï¼š

1. åŒºå—å±æ€§ï¼š

    - `block.basefee (uint)`ï¼šå½“å‰åŒºå—çš„åŸºç¡€è´¹ç”¨ã€‚
    - `block.chainid (uint)`ï¼šå½“å‰é“¾çš„ IDã€‚
    - `block.coinbase (address)`ï¼šå½“å‰åŒºå—çš„çŸ¿å·¥åœ°å€ã€‚
    - `block.difficulty (uint)`ï¼šå½“å‰åŒºå—çš„éš¾åº¦ã€‚
    - `block.gaslimit (uint)`ï¼šå½“å‰åŒºå—çš„ gas é™é¢ã€‚
    - `block.number (uint)`ï¼šå½“å‰åŒºå—å·ã€‚
    - `block.timestamp (uint)`ï¼šå½“å‰åŒºå—çš„æ—¶é—´æˆ³ã€‚

2. äº¤æ˜“å±æ€§ï¼š

    - `tx.gasprice (uint)`ï¼šäº¤æ˜“çš„ gas ä»·æ ¼ã€‚
    - `tx.origin (address)`ï¼šäº¤æ˜“å‘èµ·è€…çš„åœ°å€ã€‚

3. æ¶ˆæ¯å±æ€§ï¼š

    - `msg.data (bytes)`ï¼šå®Œæ•´çš„ calldataã€‚
    - `msg.sender (address)`ï¼šæ¶ˆæ¯å‘é€è€…çš„åœ°å€ï¼ˆå½“å‰è°ƒç”¨è€…ï¼‰ã€‚
    - `msg.sig (bytes4)`ï¼šcalldata çš„å‰ 4 å­—èŠ‚ï¼ˆå‡½æ•°é€‰æ‹©å™¨ï¼‰ã€‚
    - `msg.value (uint)`ï¼šéšæ¶ˆæ¯å‘é€çš„ wei æ•°é‡ã€‚

4. å·¥å…·å‡½æ•°ï¼š
    - `gasleft() returns (uint256)`ï¼šè¿”å›å½“å‰å‰©ä½™çš„ gas æ•°é‡ã€‚
    - `abi.encode(...) returns (bytes)`ï¼šå¯¹ç»™å®šçš„å‚æ•°è¿›è¡Œ ABI ç¼–ç ã€‚
    - `abi.decode(bytes memory encodedData, (...)) returns (...)`ï¼šå¯¹ç»™å®šçš„æ•°æ®è¿›è¡Œ ABI è§£ç ã€‚
    - `blockhash(uint blockNumber) returns (bytes32)`ï¼šè¿”å›æŒ‡å®šåŒºå—çš„å“ˆå¸Œå€¼ï¼ˆä»…é€‚ç”¨äºæœ€è¿‘çš„ 256 ä¸ªåŒºå—ï¼‰ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract GlobalVariables {
    function getGlobalVariables() public view returns (address, uint, uint) {
        address sender = msg.sender; // è°ƒç”¨è€…åœ°å€
        uint blockNumber = block.number; // åŒºå—å·
        uint timestamp = block.timestamp; // è°ƒç”¨è¯¥å‡½æ•°æ—¶çš„æ—¶é—´æˆ³
        return (sender, blockNumber, timestamp);
    }
}
```

<br><br>

# pure & view

-   pureï¼šä¸ä¿®æ”¹çŠ¶æ€å˜é‡ã€ä¸è¯»å–çŠ¶æ€å˜é‡
-   viewï¼šä¸ä¿®æ”¹çŠ¶æ€å˜é‡ã€è¯»å–çŠ¶æ€å˜é‡

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint public x = 10;

    function pureFunc(uint a, uint b) public pure returns (uint) {
        return a * b;
    }

    function viewFunc() public view returns (uint) {
        return x;
    }
}
```

ä¼šä¿®æ”¹çŠ¶æ€å˜é‡çš„å‡½æ•°ä¸éœ€è¦å…³é”®å­—ä¿®é¥°ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Counter {
    uint public count;

    function increment() external {
        count++;
    }

    function decrement() external {
        count--;
    }
}
```

<br><br>

# constant

constant ç”¨äºå£°æ˜å¸¸é‡ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint256 public constant NUM = 100;
    uint256 public num = 100;
}
```

å¸¸é‡ä¼šæ¯”å˜é‡æ¶ˆè€—æ›´å°‘çš„ gas ~

<br><br>

# æ¡ä»¶åˆ¤æ–­

Solidity çš„æ¡ä»¶åˆ¤æ–­è¯­æ³•ä¸ JS ä¸€æ ·ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // æ¡ä»¶åˆ¤æ–­
    function testIf(uint256 a, uint256 b) public pure returns (uint256) {
        if (a > b) {
            return a;
        } else {
            return b;
        }
    }

    // ä¸‰å…ƒè¿ç®—ç¬¦
    function testTernary(uint256 a, uint256 b) public pure returns (uint256) {
        return a > b ? a : b;
    }
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒSolidity ä¸­ä¸æ”¯æŒ switch case è¯­æ³•ã€‚

<br><br>

# å¾ªç¯

for å¾ªç¯ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    function forLoop() public pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < 10; i++) {
            if (i == 3) continue;
            if (i == 5) break;
            sum += i;
        }
        return sum;
    }
}
```

while å¾ªç¯ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    function whileLoop() public pure returns (uint256) {
        uint256 sum = 0;
        uint256 i = 0;
        while (i < 10) {
            if (i == 3) {
                i++;
                continue;
            }
            if (i == 5) break;
            sum += i;
            i++;
        }
        return sum;
    }
}
```

do while å¾ªç¯ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    function doWhileLoop() public pure returns (uint256) {
        uint256 sum = 0;
        uint256 i = 0;
        do {
            if (i == 3) {
                i++;
                continue;
            }
            if (i == 5) break;
            sum += i;
            i++;
        } while (i < 10);
        return sum;
    }
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ Solidity ä¸­éœ€è¦æ§åˆ¶å¥½å¾ªç¯çš„æ¬¡æ•°ï¼Œå› ä¸ºå¾ªç¯å¾—è¶Šå¤š æ¶ˆè€—çš„ gas å°±è¶Šå¤š~

<br><br>

# å¼‚å¸¸å¤„ç†

åœ¨ Solidity ä¸­ï¼Œæœ‰ 3 ç§æ–¹æ³•æŠ›å‡ºå¼‚å¸¸ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // 1. require
    function testRequire(uint256 a) public pure returns (uint256) {
        require(a > 10, "a must be greater than 10"); // è‹¥æ¡ä»¶ä¸æ»¡è¶³, åˆ™ä¼šè§¦å‘å¼‚å¸¸, å¹¶æŠ›å‡ºå¼‚å¸¸ä¿¡æ¯
        return a;
    }

    // 2. revert
    function testRevert(uint256 a) public pure returns (uint256) {
        if (a <= 10) {
            revert("a must be greater than 10"); // è§¦å‘å¼‚å¸¸, å¹¶æŠ›å‡ºå¼‚å¸¸ä¿¡æ¯
        }
        return a;
    }

    // 3. assert
    function testAssert(uint256 a) public pure returns (uint256) {
        assert(a > 10); // è‹¥æ¡ä»¶ä¸æ»¡è¶³, åˆ™ä¼šè§¦å‘å¼‚å¸¸
        return a;
    }
}
```

è‡ªå®šä¹‰å¼‚å¸¸ - ç”¨äºè‡ªå®šä¹‰å¼‚å¸¸ä¿¡æ¯ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    error MyError(address sender, uint256 value);

    function testCustomError(uint256 a) public view returns (uint256) {
        if (a <= 10) {
            revert MyError(msg.sender, a); // è§¦å‘å¼‚å¸¸, å¹¶æŠ›å‡ºè‡ªå®šä¹‰çš„å¼‚å¸¸ä¿¡æ¯
        }
        return a;
    }
}
```

try catch - é€‚ç”¨äºå¤„ç†å¤–éƒ¨åˆçº¦è°ƒç”¨å¤±è´¥çš„æƒ…å†µï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

// å¤–éƒ¨åˆçº¦, ç”¨äºç¤ºä¾‹
contract ExternalContract {
    function mayFail(bool _fail) public pure returns (string memory) {
        require(!_fail, "External call failed");
        return "Success";
    }
}

// ä¸»åˆçº¦, ä½¿ç”¨ try/catch å¤„ç†å¤–éƒ¨è°ƒç”¨
contract MainContract {
    event Success(string message);
    event Failure(string reason);

    ExternalContract externalContract;

    constructor() {
        externalContract = new ExternalContract();
    }

    function callExternal(bool _fail) public {
        try externalContract.mayFail(_fail) returns (string memory result) {
            emit Success(result);
        } catch Error(string memory reason) {
        	// å¤„ç†å‡½æ•°æŠ›å‡ºçš„é”™è¯¯
            emit Failure(reason);
        } catch (bytes memory) {
           // å¤„ç†æ›´åº•å±‚çš„é”™è¯¯, æ¯”å¦‚: out-of-gasã€invalid opcode
            emit Failure("Unknown error");
        }
    }
}
```

åœ¨ Solidity ä¸­ï¼ŒæŠ›å‡ºå¼‚å¸¸ä¼šé€€è¿˜å‰©ä½™çš„ gasï¼Œå¹¶æ¢å¤çŠ¶æ€å˜é‡å€¼ã€‚

<br><br>

# å‡½æ•°è£…é¥°å™¨

å‡½æ•°è£…é¥°å™¨å¯ä»¥åœ¨å‡½æ•°æ‰§è¡Œä¹‹å‰æˆ–ä¹‹åæ’å…¥ä»£ç é€»è¾‘ï¼Œç”¨äºæ”¹å˜å‡½æ•°çš„è¡Œä¸ºï¼Œæ¯”å¦‚æ£€æŸ¥æ¡ä»¶ã€é™åˆ¶è®¿é—®æƒé™ç­‰ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // å®šä¹‰ä¸€ä¸ªä¿®é¥°å™¨
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // ä½¿ç”¨ä¿®é¥°å™¨
    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}
```

ä¿®é¥°å™¨å¯ä»¥æ¥æ”¶å‚æ•° & å‡½æ•°å¯ä»¥åŒæ—¶ä½¿ç”¨å¤šä¸ªè£…é¥°å™¨ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // å®šä¹‰ä¸€ä¸ªä¿®é¥°å™¨
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // å®šä¹‰ä¸€ä¸ªå¸¦å‚æ•°çš„ä¿®é¥°å™¨
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        // address(0) is often used to represent an invalid or uninitialized address.
        _;
    }

    // åŒæ—¶ä½¿ç”¨å¤šä¸ªä¿®é¥°å™¨
    function changeOwner(
        address newOwner
    ) public onlyOwner validAddress(newOwner) {
        owner = newOwner;
    }
}
```

ä¸‰æ˜æ²»è£…é¥°å™¨ demo - é˜²æ­¢é‡å…¥æ”»å‡»ï¼Œè¿™æ˜¯æ™ºèƒ½åˆçº¦å®‰å…¨æ€§çš„é‡è¦æ–¹é¢ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    bool private locked = false;

    // å®šä¹‰ä¸€ä¸ªé˜²é‡å…¥æ”»å‡»çš„ä¿®é¥°å™¨
    modifier noReentrant() {
        require(!locked, "No Reentrant");
        locked = true;
        _;
        locked = false;
    }

    // ä½¿ç”¨é˜²é‡å…¥æ”»å‡»çš„ä¿®é¥°å™¨
    function withdraw() public noReentrant {
        // æç°é€»è¾‘
    }
}
```

<br><br>

# æ„é€ å‡½æ•°

æ„é€ å‡½æ•°ä»…åœ¨éƒ¨ç½²åˆçº¦çš„æ—¶å€™è°ƒç”¨ä¸€æ¬¡ï¼Œå®ƒçš„ä½œç”¨ä¸»è¦æ˜¯åˆå§‹åŒ–ä¸€äº›çŠ¶æ€å˜é‡ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    address public owner;
    uint public num;

    constructor(uint _num) {
        owner = msg.sender;
        num = _num;
    }
}
```

<br><br>

# å‡½æ•°è¾“å‡º

åœ¨ Solidity ä¸­ï¼Œå‡½æ•°å¯ä»¥æ‹¥æœ‰å¤šä¸ªè¾“å‡ºï¼Œä¸”å¯ä»¥ä¸ºè¾“å‡ºå‘½åã€‚åœ¨å…¶ä»–å‡½æ•°è·å–è¯¥å‡½æ•°çš„è¾“å‡ºå€¼æ—¶ï¼Œå¯ä»¥ä½¿ç”¨è§£æ„èµ‹å€¼ã€‚

demo - å‡½æ•°æ‹¥æœ‰å¤šä¸ªè¾“å‡ºï¼š

```solidity
contract Demo {
    function multipleReturns() public pure returns (uint, bool, string memory) {
        // In Solidity, complex types like string, bytes, and arrays
        // require a data location to be specified. This tells the compiler where the data is stored.
        // data location: memory ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, å˜é‡å€¼å­˜å‚¨åœ¨å†…å­˜ä¸­; å‡½æ•°æ‰§è¡Œå®Œå, ä¼šé‡Šæ”¾å†…å­˜
        //                ä¿®æ”¹ memory ä¿®é¥°çš„å˜é‡, ä¸ä¼šå½±å“åŒºå—é“¾ä¸Šçš„æ•°æ®
        // data location: storage ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, è¿™ä¸ªå˜é‡æ˜¯ä¸€ä¸ªå¼•ç”¨
        //                ä¿®æ”¹ storage ä¿®é¥°çš„å˜é‡, ä¼šå½±å“åŒºå—é“¾ä¸Šçš„æ•°æ®
        return (1, true, "Hello, World!");
    }
}
```

demo - ä¸ºè¾“å‡ºå‘½åï¼š

```solidity
contract Demo {
    function namedReturns1()
        public
        pure
        returns (uint x, bool y, string memory z)
    {
        // æ˜¾å¼è¿”å›
        return (1, true, "Hello, World!");
    }

    function namedReturns2()
        public
        pure
        returns (uint x, bool y, string memory z)
    {
        // éšå¼è¿”å›
        x = 1;
        y = true;
        z = "Hello, World!";
    }
}
```

demo - è§£æ„èµ‹å€¼ï¼š

```solidity
contract Demo {
    function get() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = multipleReturns();
        return (a, b, c);
    }

    function getNamed1() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = namedReturns1();
        return (a, b, c);
    }

    function getNamed2() public pure returns (uint, bool, string memory) {
        (uint a, bool b, string memory c) = namedReturns2();
        return (a, b, c);
    }
}
```

<br><br>

# Array

åœ¨ Solidity ä¸­ï¼ŒArray çš„ length å¯ä»¥æ˜¯åŠ¨æ€/å›ºå®šçš„ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // å›ºå®šé•¿åº¦çš„æ•°ç»„
    uint256[5] public fixedArray = [1, 2, 3, 4, 5];

    // åŠ¨æ€é•¿åº¦çš„æ•°ç»„
    uint256[] public dynamicArray = [1, 2, 3, 4, 5];
}
```

å¯¹åŠ¨æ€æ•°ç»„çš„å¢åˆ æ”¹æŸ¥ï¼š

```solidity
    // æ·»åŠ å…ƒç´ åˆ°åŠ¨æ€æ•°ç»„
    function addDynamicArray(uint256 _value) public {
        dynamicArray.push(_value);
    }

    // è·å–åŠ¨æ€æ•°ç»„çš„é•¿åº¦
    function getDynamicArrayLength() public view returns (uint256) {
        return dynamicArray.length;
    }

    // è·å–åŠ¨æ€æ•°ç»„çš„å…ƒç´ 
    function getDynamicArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return dynamicArray[_index];
    }

    // æ›´æ–°åŠ¨æ€æ•°ç»„çš„å…ƒç´ 
    function updateDynamicArrayElement(uint256 _index, uint256 _value) public {
        dynamicArray[_index] = _value;
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„å…ƒç´ 
    function deleteDynamicArrayElement(uint256 _index) public {
        delete dynamicArray[_index]; // æ³¨æ„: è¿™é‡Œæ˜¯å°†è¯¥å…ƒç´ é‡ç½®ä¸ºé»˜è®¤å€¼äº†, ä¸ä¼šæ”¹å˜æ•°ç»„çš„é•¿åº¦
    }
    // è‹¥æƒ³åˆ é™¤æŒ‡å®šå…ƒç´  åé¢çš„å…ƒç´ å¾€å‰ç§» (eg: [1, 2, 3] ğŸ‘‰ [1, 3]), å¯è¿™ä¹ˆå®ç°:
    function deleteNum(uint256 _index) public {
        for (uint i = _index; i < dynamicArray.length - 1; i++) {
            dynamicArray[i] = dynamicArray[i + 1];
        }
        dynamicArray.pop();
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    function popDynamicArray() public {
        dynamicArray.pop();
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
    function deleteAllDynamicArray() public {
        delete dynamicArray; // è¿™é‡Œæ˜¯å°†æ•°ç»„é‡ç½®ä¸ºç©ºæ•°ç»„äº†, æ•°ç»„é•¿åº¦å˜ä¸º 0
    }
```

å¯¹å›ºå®šæ•°ç»„çš„å¢åˆ æ”¹æŸ¥ï¼š

```solidity
    // æ·»åŠ å…ƒç´ åˆ°å›ºå®šæ•°ç»„
    function addFixedArray(uint256 _value) public {
        // fixedArray.push(_value); // å›ºå®šæ•°ç»„ä¸èƒ½ä½¿ç”¨ push æ–¹æ³•
    }

    // è·å–å›ºå®šæ•°ç»„çš„é•¿åº¦
    function getFixedArrayLength() public view returns (uint256) {
        return fixedArray.length;
    }

    // è·å–å›ºå®šæ•°ç»„çš„å…ƒç´ 
    function getFixedArrayElement(
        uint256 _index
    ) public view returns (uint256) {
        return fixedArray[_index];
    }

    // æ›´æ–°å›ºå®šæ•°ç»„çš„å…ƒç´ 
    function updateFixedArrayElement(uint256 _index, uint256 _value) public {
        fixedArray[_index] = _value;
    }

    // åˆ é™¤å›ºå®šæ•°ç»„çš„å…ƒç´ 
    function deleteFixedArrayElement(uint256 _index) public {
        delete fixedArray[_index]; // æ³¨æ„: è¿™é‡Œæ˜¯å°†è¯¥å…ƒç´ é‡ç½®ä¸ºé»˜è®¤å€¼äº†, ä¸ä¼šæ”¹å˜æ•°ç»„çš„é•¿åº¦
    }

    // åˆ é™¤åŠ¨æ€æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    function popFixedArray() public {
        // fixedArray.pop(); // å›ºå®šæ•°ç»„ä¸èƒ½ä½¿ç”¨ pop æ–¹æ³•
    }

    // åˆ é™¤å›ºå®šæ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
    function deleteAllFixedArray() public {
        delete fixedArray; // æ³¨æ„: è¿™é‡Œæ˜¯å°†è¯¥å…ƒç´ é‡ç½®ä¸ºé»˜è®¤å€¼äº†, ä¸ä¼šæ”¹å˜æ•°ç»„çš„é•¿åº¦
    }
```

åœ¨å†…å­˜ä¸­åˆ›å»ºæ•°ç»„ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = new uint[](3); // [0, 0, 0]

    function getArr() public view returns (uint[] memory) {
        return arr;
    }
}
```

æ³¨æ„ï¼šâ‘  åªèƒ½åœ¨å†…å­˜ä¸­åˆ›å»ºå®šé•¿æ•°ç»„ï¼› â‘¡ åœ¨ Solidity ä¸­ï¼Œæˆ‘ä»¬å°½é‡ä¸è¦è¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„é•¿åº¦è¶Šå¤§ æ¶ˆè€—çš„ gas å°±è¶Šå¤šã€‚

å‡½æ•° demo - æ¥å—ä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªç´¢å¼•ä½œä¸ºå‚æ•°ï¼Œç§»é™¤ç´¢å¼•æŒ‡å®šçš„å…ƒç´ å¹¶è¿”å›æ–°æ•°ç»„ï¼š

```solidity
function removeAtIndex(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(arr.length > 0, "Array is empty");
    require(index < arr.length && index >= 0, "Index out of bounds");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < arr.length; i++) {
        if (i < index) {
            newArr[i] = arr[i];
        } else if (i > index) {
            newArr[i - 1] = arr[i];
        }
    }

    return newArr;
}
```

```solidity
function removeAtIndex2(
    uint[] memory arr,
    uint index
) public pure returns (uint[] memory) {
    require(index < arr.length && index >= 0, "Index out of bounds");
    require(arr.length > 0, "Array is empty");

    uint[] memory newArr = new uint[](arr.length - 1);

    for (uint i = 0; i < index; i++) {
        newArr[i] = arr[i];
    }

    for (uint i = index; i < arr.length - 1; i++) {
        newArr[i] = arr[i + 1];
    }

    return newArr;
}
```

å¦‚æœå¯ä»¥æ‰“ä¹±æ•°ç»„çš„é¡ºåºï¼ŒæŸäº›æƒ…å†µä¸‹å¯ä»¥è€ƒè™‘å°†æƒ³åˆ é™¤çš„å…ƒç´ ä¸æ•°ç»„æœ€åä¸€ä½å…ƒç´ äº¤æ¢ï¼Œç„¶åè°ƒç”¨ pop æ–¹æ³•ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    uint[] public arr = [1, 2, 3, 4, 5];

    function removeAtIndex(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        for (uint i = _index; i < arr.length - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr.pop();
    }

    function removeAtIndex2(uint _index) public {
        require(arr.length > 0, "Array is empty");
        require(_index < arr.length && _index >= 0, "Index out of bounds");
        arr[_index] = arr[arr.length - 1];
        arr.pop();
    }
}
```

<br><br>

# Mapping

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // å®šä¹‰ä¸€ä¸ª address => uint256 çš„ mapping
    mapping(address => uint256) public myBalance;

    // è·å– mapping å€¼
    function getMyBalance() public view returns (uint256) {
        return myBalance[msg.sender]; // è¿”å›è°ƒç”¨è€…çš„ä½™é¢; å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡, åˆ™è¿”å› uint256 çš„é»˜è®¤å€¼ 0
    }

    // æ·»åŠ /ä¿®æ”¹ mapping å€¼
    function setMyBalance(uint256 _amount) public {
        myBalance[msg.sender] += _amount; // å¢åŠ è°ƒç”¨è€…çš„ä½™é¢; å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡, åˆ™åŸºäº uint256 çš„é»˜è®¤å€¼ 0 è¿›è¡Œæ›´æ–°
    }

    // åˆ é™¤ mapping å€¼
    function deleteMyBalance() public {
        delete myBalance[msg.sender]; // åˆ é™¤è°ƒç”¨è€…çš„ä½™é¢; ä¼šå°†è°ƒç”¨è€…çš„ä½™é¢è®¾ç½®ä¸º uint256 çš„é»˜è®¤å€¼ 0
    }
}
```

mapping å¯ä»¥åµŒå¥—ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    // å®šä¹‰ä¸€ä¸ªåµŒå¥—çš„ mapping
    mapping(address => mapping(address => uint256)) public allowance;

    // è·å–åµŒå¥— mapping å€¼
    function getAllowance(
        address _owner,
        address _spender
    ) public view returns (uint256) {
        return allowance[_owner][_spender]; // è¿”å› _owner å¯¹ _spender çš„æˆæƒé¢åº¦
    }

    // æ–°å¢/ä¿®æ”¹åµŒå¥— mapping å€¼
    function setAllowance(address _spender, uint256 _amount) public {
        allowance[msg.sender][_spender] = _amount; // è®¾ç½®è°ƒç”¨è€…å¯¹ _spender çš„æˆæƒé¢åº¦
    }

    // åˆ é™¤åµŒå¥— mapping å€¼
    function deleteAllowance(address _spender) public {
        delete allowance[msg.sender][_spender]; // åˆ é™¤è°ƒç”¨è€…å¯¹ _spender çš„æˆæƒé¢åº¦
    }
}
```

demo - ç®€å•çš„é“¶è¡Œè´¦æˆ·ç³»ç»Ÿï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract SimpleBank {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        // payable() is a function that converts an address to an address payable
        // transfer() is a function that sends ether to an address
    }

    function checkBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}
```

å®ç°å¯è¿­ä»£æ˜ å°„ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    mapping(address => uint) public balance;
    mapping(address => bool) public isCustomer;
    address[] public customers;

    function deposit(address _customer, uint _amount) public {
        balance[_customer] += _amount;
        if (!isCustomer[_customer]) {
            customers.push(_customer);
            isCustomer[_customer] = true;
        }
    }

    function getCustomerBalance(address _customer) public view returns (uint) {
        require(isCustomer[_customer], "Customer does not exist");
        return balance[_customer];
    }

    function getCustomerBalanceByIndex(uint _index) public view returns (uint) {
        require(_index < customers.length && _index >= 0, "Index out of bounds");
        return balance[customers[_index]];
    }
}
```

<br><br>

# Struct

åˆ›å»º Struct å®ä¾‹ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Demo {
    struct Student {
        uint256 id;
        string name;
    }

    Student[] public students;

    function addStudent1(string memory _name) public {
        // æŒ‰å±æ€§é¡ºåºåˆ›å»º Struct å®ä¾‹, å¹¶æ·»åŠ åˆ°æ•°ç»„
        students.push(Student(students.length, _name));
    }

    function addStudent2(string memory _name) public {
        // æŒ‰å±æ€§ååˆ›å»º Struct å®ä¾‹, å¹¶æ·»åŠ åˆ°æ•°ç»„
        students.push(Student({id: students.length, name: _name}));
    }

    function addStudent3(string memory _name) public {
        // åˆ›å»º Struct å®ä¾‹, ä½†ä¸æŒ‡å®šå±æ€§å€¼, ä¼šä½¿ç”¨é»˜è®¤å€¼
        Student memory student;
        // è®¾ç½®å±æ€§å€¼
        student.id = students.length;
        student.name = _name;
        // æ·»åŠ åˆ°æ•°ç»„
        students.push(student);
    }
}
```

è®¿é—® Struct å®ä¾‹å±æ€§ï¼š

```solidity
function getStudentInfoByIndex(
    uint256 _index
) public view returns (uint256, string memory) {
    Student memory student = students[_index];
    // memory ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, å˜é‡å€¼å­˜å‚¨åœ¨å†…å­˜ä¸­; å‡½æ•°æ‰§è¡Œå®Œå, ä¼šé‡Šæ”¾å†…å­˜
    // ä¿®æ”¹ memory ä¿®é¥°çš„å˜é‡, ä¸ä¼šå½±å“æ•°ç»„çš„å€¼
    return (student.id, student.name);
}
```

ä¿®æ”¹ Struct å®ä¾‹å±æ€§ï¼š

```solidity
function updateStudentNameByIndex(
    uint256 _index,
    string memory _name
) public {
    Student storage student = students[_index];
    // storage ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, è¿™ä¸ªå˜é‡æ˜¯ä¸€ä¸ªå¼•ç”¨
    // ä¿®æ”¹ storage ä¿®é¥°çš„å˜é‡, ä¼šå½±å“æ•°ç»„çš„å€¼
    student.name = _name;
}
```

åˆ é™¤ Struct å®ä¾‹å±æ€§ & åˆ é™¤ Struct å®ä¾‹ï¼š

```solidity
function deleteStudentNameByIndex(uint256 _index) public {
    Student storage student = students[_index];
    // storage ä¼šå‘Šè¯‰ç¼–è¯‘å™¨, è¿™ä¸ªå˜é‡æ˜¯ä¸€ä¸ªå¼•ç”¨
    // ä¿®æ”¹ storage ä¿®é¥°çš„å˜é‡, ä¼šå½±å“æ•°ç»„çš„å€¼
    delete student.name; // è¯¥ delete ä¼šå°†è¯¥å±æ€§å€¼é‡ç½®ä¸ºé»˜è®¤å€¼
}

function deleteStudentByIndex(uint256 _index) public {
    delete students[_index]; // è¯¥ delete ä¼šå°†è¯¥ Struct å®ä¾‹çš„å±æ€§å€¼éƒ½é‡ç½®ä¸ºé»˜è®¤å€¼
}
```

<br><br>
