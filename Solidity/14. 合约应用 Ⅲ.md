# Time Lock

时间锁（TimeLock）是一种机制，用于将智能合约中的某些操作延迟执行，以提高安全性和透明度。时间锁通常用于去中心化金融（DeFi）和去中心化自治组织（DAO）中，以防止恶意操作和提供足够的时间进行审查和反应。

时间锁合约允许用户创建一个交易，并将其放入一个队列中。该交易在指定的延迟时间后才能执行。

主要功能：

1.  创建交易：将交易加入时间锁队列。

2.  执行交易：在锁定期满后执行交易。

3.  取消交易：在锁定期内取消交易。

```solidity
contract TimeLock {
    // 管理员地址
    address public immutable admin;

    // 最小锁定时间
    uint public constant MIN_DELAY = 60; // 生产环境常用 1 days ~ 2 days

    // 最大锁定时间
    uint public constant MAX_DELAY = 120; // 生产环境常用 7 days ~ 30 days

    // 到期执行的宽限时间
    uint public constant GRACE_PERIOD = 60; // 生产环境常用 1 days ~ 7 days

    // 记录所有在时间锁队列中的交易
    mapping(bytes32 => bool) public queuedTransactions;

    // 交易创建并进入时间锁队列的事件
    event QueueTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 锁定期满后交易执行的事件
    event ExecuteTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 交易取消事件
    event CancelTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint value,
        string signature,
        bytes data,
        uint executeTime
    );

    // 初始化管理员地址
    constructor() {
        admin = msg.sender;
    }

    // 让合约可以接收以太币
    receive() external payable {}

    // 限制只有管理员才能调用的函数
    modifier onlyAdmin() {
        require(msg.sender == admin, "TimeLock: Caller is not admin");
        _;
    }

    // 创建交易并添加到时间锁队列中
    function queueTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin returns (bytes32) {
        require(
            executeTime >= block.timestamp + MIN_DELAY &&
                executeTime <= block.timestamp + MAX_DELAY,
            "TimeLock: Invalid execution time"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            !queuedTransactions[txHash],
            "TimeLock: Transaction already queued"
        );

        queuedTransactions[txHash] = true;
        emit QueueTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return txHash;
    }

    // 取消交易
    function cancelTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public onlyAdmin {
        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        emit CancelTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
    }

    // 执行交易
    function executeTransaction(
        address target,
        uint value,
        string memory signature,
        bytes memory data,
        uint executeTime
    ) public payable onlyAdmin returns (bytes memory) {
        require(
            block.timestamp >= executeTime,
            "TimeLock: Transaction hasn't surpassed time lock"
        );
        require(
            block.timestamp <= executeTime + GRACE_PERIOD,
            "TimeLock: Transaction is stale"
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, executeTime)
        );
        require(
            queuedTransactions[txHash],
            "TimeLock: Transaction hasn't been queued"
        );

        queuedTransactions[txHash] = false;
        bytes memory callData = bytes(signature).length == 0
            ? data
            : abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        (bool success, bytes memory returnData) = target.call{value: value}(
            callData
        );
        require(success, "TimeLock: Transaction execution reverted");

        emit ExecuteTransaction(
            txHash,
            target,
            value,
            signature,
            data,
            executeTime
        );
        return returnData;
    }
}
```

编写测试合约：

```solidity
contract TestTimeLock {
    address public timeLock;

    event Log(string message);

    constructor(address _timeLock) {
        timeLock = _timeLock;
    }

    // 测试函数
    function test() public {
        require(msg.sender == timeLock, "Only timeLock can call");
        emit Log("Test");
    }

    // 辅助函数, 获取测试函数的执行时间
    function getExecutedTime() public view returns (uint) {
        return block.timestamp + 30;
    }
}
```

1. 部署 TimeLock 合约

2. 部署 TestTimeLock 合约，构造函数传入 `TimeLock 合约地址`

3. 调用 TestTimeLock 合约的 getExecutedTime 函数，获取执行时间 `executeTime`

4. 调用 TimeLock 合约的 queueTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，将 TestTimeLock 合约的 test 函数添加到时间锁队列中

5. 等待 `executeTime` 时间到达，调用 TimeLock 合约的 executeTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，执行 TestTimeLock 合约的 test 函数

6. 在未到达 `executeTime` 之前，可调用 TimeLock 合约的 cancelTransaction 函数，传入 `TestTimeLock 合约地址`、`0`、`"test()"`、`0x`、`executeTime`，取消 TestTimeLock 合约的 test 函数

<br><br>

# CSAMM

恒和自动市场制造商 (Constant Sum Automated Market Maker) 是一种去中心化交易协议，用于在区块链上实现自动化的代币交易。与常见的恒积自动市场制造商（如 Uniswap）不同，CSAMM 使用恒和公式来确定交易价格。

在 CSAMM 中，交易价格由以下公式决定：`x + y = k`，其中 `x` 和 `y` 分别代表池中的两种代币数量，`k` 是一个常数，表示池中两种代币数量的总和。

由于使用恒定和公式，CSAMM 在价格波动较小时表现较好，适用于稳定币之间的交易。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ConstantSumAMM {
    // 合约中两种代币的实例
    IERC20 public immutable tokenX;
    IERC20 public immutable tokenY;

    // 两种代币的总供应量
    uint public totalSupplyX;
    uint public totalSupplyY;

    // 流动池中的总供应量
    uint public totalSupply;

    // 每个用户的流动份额
    mapping(address => uint) public balanceOf;

    // 初始化两种代币的实例
    constructor(address _tokenX, address _tokenY) {
        tokenX = IERC20(_tokenX);
        tokenY = IERC20(_tokenY);
    }

    // 发行新的代币到 to 账户
    function _mint(address to, uint amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    // 从 from 账户中销毁代币
    function _burn(address from, uint amount) internal {
        totalSupply -= amount;
        balanceOf[from] -= amount;
    }

    // 在两种代币之间进行交换
    function swap(
        address _tokenIn,
        uint _amountIn
    ) external returns (uint amountOut) {
        require(
            _tokenIn == address(tokenX) || _tokenIn == address(tokenY),
            "Invalid token"
        );

        // 确定传入的代币为 tokenX 还是 tokenY
        bool isX = _tokenIn == address(tokenX);

        // 根据传入的代币确定两种代币的实例和总供应量
        (
            IERC20 tokenIn,
            IERC20 tokenOut,
            uint totalSupplyIn,
            uint totalSupplyOut
        ) = isX
                ? (tokenX, tokenY, totalSupplyX, totalSupplyY)
                : (tokenY, tokenX, totalSupplyY, totalSupplyX);

        // 用户将代币转移到合约中
        tokenIn.transferFrom(msg.sender, address(this), _amountIn);

        // 计算用户实际转移的代币数量
        uint amountIn = tokenIn.balanceOf(address(this)) - totalSupplyIn;

        // 计算用户可以获得的代币数量
        amountOut = (amountIn * 997) / 1000; // 0.3% 手续费

        // 更新两种代币的总供应量
        totalSupplyIn += amountIn;
        totalSupplyOut -= amountOut;

        // 将代币转移给用户
        tokenOut.transfer(msg.sender, amountOut);
    }

    // 向池中添加流动性，获得相应的份额
    function addLiquidity(
        uint amountX,
        uint amountY
    ) external returns (uint shares) {
        // 用户将代币转移到合约中
        tokenX.transferFrom(msg.sender, address(this), amountX);
        tokenY.transferFrom(msg.sender, address(this), amountY);

        // 计算用户实际转移的代币数量
        uint _amountX = tokenX.balanceOf(address(this)) - totalSupplyX;
        uint _amountY = tokenY.balanceOf(address(this)) - totalSupplyY;

        // 计算用户可以获得的份额
        if (totalSupply == 0) {
            // 对于第一次添加流动性的用户, 直接按照转移的代币数量计算份额
            shares = _amountX + _amountY;
        } else {
            shares =
                ((_amountX + _amountY) * totalSupply) /
                (totalSupplyX + totalSupplyY);
        }

        // 发行份额给用户
        require(shares > 0, "Invalid shares");
        _mint(msg.sender, shares);

        // 更新两种代币的总供应量
        totalSupplyX += _amountX;
        totalSupplyY += _amountY;
    }

    // 根据持有的份额提取流动性
    function removeLiquidity(
        uint shares
    ) external returns (uint amountX, uint amountY) {
        // 计算用户可以获得的代币数量
        amountX = (shares * totalSupplyX) / totalSupply;
        amountY = (shares * totalSupplyY) / totalSupply;

        // 销毁用户的份额
        _burn(msg.sender, shares);

        // 更新两种代币的总供应量
        totalSupplyX -= amountX;
        totalSupplyY -= amountY;

        // 将代币转移给用户
        require(amountX > 0 && amountY > 0, "Invalid amount");
        tokenX.transfer(msg.sender, amountX);
        tokenY.transfer(msg.sender, amountY);
    }
}
```

编写测试合约：

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint amount) external {
        _mint(to, amount);
    }
}
```

1. 部署两次 MyToken 合约，分别作为两种代币，这里分别命名为 `tokenX` 和 `tokenY`，符号分别为 `X` 和 `Y`

2. 部署 ConstantSumAMM 合约，传入 `tokenX` 和 `tokenY` 的地址

3. 调用 `tokenX` 合约的 mint 函数，传入编辑器地址和 `1000`，表示在 `tokenX` 合约中发行 `1000` 个代币到编辑器地址

4. 调用 `tokenY` 合约的 mint 函数，传入编辑器地址和 `1000`，表示在 `tokenY` 合约中发行 `1000` 个代币到编辑器地址

5. 调用 `tokenX` 合约的 approve 函数，传入 ConstantSumAMM 合约的地址和 `500`，表示授权 ConstantSumAMM 合约可以从编辑器地址转移 `500` 个 `tokenX` 代币

6. 调用 `tokenY` 合约的 approve 函数，传入 ConstantSumAMM 合约的地址和 `800`，表示授权 ConstantSumAMM 合约可以从编辑器地址转移 `800` 个 `tokenY` 代币

测试 addLiquidity：

1. 调用 ConstantSumAMM 合约的 addLiquidity 函数，传入 `400` 和 `600`，表示编辑器地址向 ConstantSumAMM 合约添加 `400` 个 `tokenX` 和 `600` 个 `tokenY`，获取响应的流动性份额

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `1000`、两种代币的总供应量 totalSupplyX 为 `400`、totalSupplyY 为 `600`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `1000`

3. 查看 `tokenX` 和 `tokenY` 合约中编辑器地址的余额，可以看到编辑器地址的 `tokenX` 余额变成了 `600`、`tokenY` 余额变成了 `400`

测试 swap：

1. 调用 ConstantSumAMM 合约的 swap 函数，传入 `tokenX` 的地址和 `100`，表示编辑器地址用 `100` 个 `tokenX` 交换 `tokenY`，获得相应的代币数量

2. 查看 `tokenX` 和 `tokenY` 合约中编辑器地址的余额，可以看到用户的 `tokenX` 余额变成了 `500`、`tokenY` 余额变成了 `499`，表示用户用 `100` 个 `tokenX` 交换了 `99` 个 `tokenY`

测试 removeLiquidity：

1. 调用 ConstantSumAMM 合约的 removeLiquidity 函数，传入 `500`，表示编辑器地址提取 `500` 份额的流动性，获得相应的代币数量

2. 可以查看到 ConstantSumAMM 合约的池中总的流动性份额 totalSupply 为 `500`、两种代币的总供应量 totalSupplyX 为 `200`、totalSupplyY 为 `300`；传入编辑器地址，查看到用户的流动性份额 balanceOf 为 `500`

3. 查看 `tokenX` 和 `tokenY` 合约中编辑器地址的余额，可以看到用户的 `tokenX` 余额变成了 `700`、`tokenY` 余额变成了 `799`

<br>
