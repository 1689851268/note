# 构造函数

构造函数仅在合约部署时调用一次，主要用于初始化状态变量。

```solidity
contract Demo {
    address public owner;
    uint public num;

    constructor(uint _num) {
        owner = msg.sender;
        num = _num;
    }
}
```

<br><br>

# 使用键值输入调用函数

键值输入允许你在调用函数时指定参数的名称，而不是仅仅按顺序提供参数值。这在参数较多或参数顺序容易混淆的情况下特别有用。

```solidity
contract Demo {
    // 定义一个函数, 接受两个参数
    function setValues(uint key, uint value) public pure returns (uint, uint) {
        return (key, value);
    }

    function callSetValues() public pure returns (uint, uint) {
        // 使用键值输入调用 setValues 函数
        return setValues({value: 42, key: 7});
    }
}
```

<br><br>

# 函数输出

单输出：

```solidity
contract Demo {
    function getSingleNumber() public pure returns (uint) {
        return 42;
    }
}
```

多输出：

```solidity
contract Demo {
    function getMultipleNumbers() public pure returns (uint, uint) {
        return (1, 2);
    }
}
```

命名输出：

```solidity
contract Demo {
    function getNamedNumbers1() public pure returns (uint first, uint second) {
        first = 3;
        second = 4;
    }

    // 相当于

    function getNamedNumbers2() public pure returns (uint, uint) {
        uint first;
        uint second;
        first = 3;
        second = 4;
        return (first, second);
    }
}
```

获取函数返回值：

```solidity
contract Demo {
    // ...

    function callFunctions() public pure returns (uint, uint, uint) {
        uint singleNumber = getSingleNumber(); // 获取单个返回值
        (uint multipleNumber1, uint multipleNumber2) = getMultipleNumbers(); // 获取多个返回值
        return (singleNumber, multipleNumber1, multipleNumber2);
    }
}
```

<br><br>

# 函数装饰器

函数装饰器可以在函数执行之前或之后插入代码逻辑，比如检查条件、限制访问权限等。

```solidity
contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义装饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 使用装饰器
    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}
```

装饰器可以接收参数 & 函数可以同时使用多个装饰器：

```solidity
contract Demo {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 定义装饰器
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the contract owner");
        _;
    }

    // 定义带参数的装饰器
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        // address(0) is often used to represent an invalid or uninitialized address.
        _;
    }

    // 同时使用多个装饰器
    function changeOwner(
        address newOwner
    ) public onlyOwner validAddress(newOwner) {
        owner = newOwner;
    }
}
```

三明治装饰器：可以在函数执行之前和之后插入代码逻辑的装饰器。demo - 防止重入攻击：

```solidity
contract Demo {
    bool private locked = false;

    // 定义一个防止重入攻击的装饰器
    modifier noReentrant() {
        require(!locked, "No Reentrant");
        locked = true;
        _;
        locked = false;
    }

    // 使用装饰器
    function withdraw() public noReentrant {
        // ... 提现逻辑 ...
    }
}
```

<br><br>

# 异常处理

Solidity 中有 3 个异常处理方法：

```solidity
contract Demo {
    // 1. require
    function testRequire(uint a) public pure returns (uint) {
        require(a > 10, "a must be greater than 10"); // 若条件不满足, 则触发异常, 并抛出异常信息; 会退还剩余的 gas
        return a;
    }

    // 2. revert
    function testRevert(uint a) public pure returns (uint) {
        if (a <= 10) {
            revert("a must be greater than 10"); // 触发异常, 并抛出异常信息; 会退还剩余的 gas
        }
        return a;
    }

    // 3. assert
    function testAssert(uint a) public pure returns (uint) {
        assert(a > 10); // 若条件不满足, 则触发异常; 会消耗剩余的 gas
        return a;
    }
}
```

自定义异常 - 可以自定义异常信息，且更节省 gas；搭配 revert 使用：

```solidity
contract Demo {
	// 声明自定义异常
    error MyError(address sender, uint value);

    function testCustomError(uint a) public view returns (uint) {
        if (a <= 10) {
            revert MyError(msg.sender, a); // 使用自定义异常
        }
        return a;
    }
}
```

try catch - 适用于处理外部合约调用失败的情况：

```solidity
// 外部合约, 用于示例
contract ExternalContract {
    function mayFail(uint value) public pure returns (uint) {
        require(value != 0, "Value cannot be zero");
        return value * 2;
    }
}

// 主合约, 使用 try/catch 处理外部调用
contract TryCatchExample {
    event Success(uint value);
    event Failure(string reason);
    event GoOn(string reason);

    ExternalContract externalContract;

    constructor() {
        // 通过 new 创建外部合约实例
        externalContract = new ExternalContract();
    }

    function tryCatchExample(uint value) public {
        try externalContract.mayFail(value) returns (uint result) {
            emit Success(result);
        } catch Error(string memory reason) {
            // 捕获 require 和 revert 抛出的错误, 并返回错误消息
            emit Failure(reason);
        } catch (bytes memory) {
            // 捕获低级别错误 (如 assert 抛出的错误), 并返回通用错误消息
            emit Failure("Low-level error");
        }
        // 无论是否发生错误, 都会继续执行
        emit GoOn("Continue execution");
    }
}
```

1. 部署 TryCatchExample 合约

2. 调用 tryCatchExample 方法，传入 0；可以看到触发了 Failure 事件和 GoOn 事件

3. 调用 tryCatchExample 方法，传入 1；可以看到触发了 Success 事件和 GoOn 事件

<br><br>

# Event

事件 (Event) 的用途：

-   事件可以用于记录交易日志，帮助调试和监控合约的运行状态。
-   外部应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件，从而在事件发生时执行相应的操作。

```solidity
contract Demo {
    event Transfer(address indexed from, address indexed to, uint value); // 定义事件

    function transfer(address _to, uint _value) public {
        emit Transfer(msg.sender, _to, _value); // 触发事件
    }
}
```

索引参数：

-   事件参数可以使用 `indexed` 关键字进行索引，最多可以索引三个参数。
-   索引参数可以加快事件的搜索和过滤。

监听事件：

-   eg：外部应用程序（如 DApp）可以使用 Web3.js 等库来监听和处理事件。

```javascript
const event = contractInstance.Transfer();
event.watch(function (error, result) {
    if (!error) {
        console.log(result.args.from, result.args.to, result.args.value);
    }
});
```

<br><br>

# Library

库（Library）定义了常用的功能函数，可以在多个合约中复用。

1.  库不能定义状态变量

2.  库不能继承其他合约，也不能被其他合约继承

3.  库不能接收以太币

4.  推荐使用 internal 修饰 Library 的方法

使用方式 1：

```solidity
library Math {
    function max(uint a, uint b) internal pure returns (uint) {
        return a >= b ? a : b;
    }
}

contract Test {
    function test() public pure returns (uint) {
        return Math.max(1, 2); // 通过库名 Math 调用里面的方法 max
    }
}
```

使用方式 2：

```solidity
library ArrayLib {
    function findIndex(
        uint[] memory arr,
        uint value
    ) internal pure returns (int) {
        for (uint i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return int(i);
            }
        }
        return -1;
    }
}

contract Test {
    using ArrayLib for uint[]; // 通过库名 ArrayLib 增强类型 uint[]

    uint[] public arr = [1, 2, 3, 4, 5];

    function findIndex(uint value) public view returns (int) {
        return arr.findIndex(value); // uint[] 类型的变量可直接调用 ArrayLib 里面的方法 findIndex
    }
}
```

<br><br>

# 流程控制

if-else：

```solidity
function testIf(uint a, uint b) public pure returns (uint) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

三元运算符：

```solidity
function testTernary(uint a, uint b) public pure returns (uint) {
    return a > b ? a : b;
}
```

注意：Solidity 不支持 switch-case 语句

<br>

for 循环：

```solidity
function forLoop() public pure returns (uint) {
    uint sum = 0;
    for (uint i = 0; i < 10; i++) {
        if (i == 3) continue;
        if (i == 5) break;
        sum += i;
    }
    return sum;
}
```

while 循环：

```solidity
function whileLoop() public pure returns (uint) {
    uint sum = 0;
    uint i = 0;
    while (i < 10) {
        if (i == 3) {
            i++;
            continue;
        }
        if (i == 5) break;
        sum += i;
        i++;
    }
    return sum;
}
```

do while 循环：

```solidity
function doWhileLoop() public pure returns (uint) {
    uint sum = 0;
    uint i = 0;
    do {
        if (i == 3) { i++; continue; }
        if (i == 5) break;
        sum += i;
        i++;
    } while (i < 10);
    return sum;
}
```

<br><br>

# Gas Golf

Gas Golf 是一种优化智能合约以减少 Gas 消耗的技术。

Gas 是以太坊网络上执行交易和智能合约所需的计算资源的度量单位。通过优化代码，可以显著降低交易成本，提高合约的效率。

以下是一些常见的 Gas 优化技巧：

1. **使用 calldata 代替 memory**

calldata 是一种只读数据位置，适用于函数参数。

```solidity
function example(uint[] calldata nums) external {
    // 使用 calldata 代替 memory
}
```

2. **将状态变量加载到内存中**

频繁访问状态变量会消耗大量 Gas。将状态变量加载到内存中可以减少重复访问的开销。

```solidity
uint public total;

function example() external {
    uint _total = total;
    // 使用 _total 代替 total
    total = _total;
}
```

3. **使用前置递增运算符**

在循环中，使用 ++i 代替 i++ 可以节省 Gas，因为前置递增运算符更高效。

```solidity
for (uint i = 0; i < nums.length; ++i) {
    // 使用 ++i 代替 i++
}
```

4. **缓存数组长度**

在循环中，频繁访问数组的长度会消耗 Gas。将数组长度缓存到本地变量中可以减少开销。

```solidity
uint len = nums.length;
for (uint i = 0; i < len; ++i) {
    // 使用缓存的 len 代替 nums.length
}
```

5. **短路求值**

在逻辑运算中，使用短路求值可以避免不必要的计算，从而节省 Gas。

```solidity
if (condition1 && condition2) {
    // 如果 condition1 为 false，则不会计算 condition2
}
```

6. **使用 unchecked 块**

在某些情况下，可以使用 unchecked 块来避免溢出检查，从而节省 Gas。

```solidity
unchecked {
    ++i;
}
```

7. **将常访问的值缓存到内存中**

在循环中，将常访问的值缓存到内存中可以减少重复访问的开销。

```solidity
for (uint i = 0; i < nums.length; i++) {
    uint num = nums[i];
    // 使用 num 代替 nums[i]
}
```

**demo**：

```solidity
// 未优化的代码
function sumIfEvenAndLessThan99(uint[] memory nums) external {
    for (uint i = 0; i < nums.length; i++) {
        bool isEven = nums[i] % 2 == 0;
        bool isLessThan99 = nums[i] < 99;
        if (isEven && isLessThan99) {
            total += nums[i];
        }
    }
}

// 优化后的代码
function sumIfEvenAndLessThan99(uint[] calldata nums) external {
    uint _total = total;
    uint len = nums.length;
    for (uint i = 0; i < len;) {
        uint num = nums[i];
        if (num % 2 == 0 && num < 99) {
            _total += num;
        }
        unchecked {
            ++i;
        }
    }
    total = _total;
}
```

<br>
