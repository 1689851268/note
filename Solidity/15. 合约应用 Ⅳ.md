# 质押奖励代币

质押奖励代币（Staking Reward Tokens）是 DeFi（去中心化金融）中的一种机制，允许用户通过质押（staking）他们的代币来获得奖励。

**质押奖励代币的工作原理**：

1. 质押代币：

    - 用户调用智能合约中的 `stake` 函数，将一定数量的代币转移到合约中。

    - 合约会记录用户质押的数量，并更新总质押量。

2. 更新奖励：

    - 每次用户进行质押、解除质押或领取奖励时，合约会更新奖励数据。

    - 更新奖励时，合约会计算每个代币的累计奖励，并记录上次更新的时间。

3. 计算奖励：

    - 合约通过 `rewardPerTokenStored` 函数计算每个代币的累计奖励。

    - 通过 `earned` 函数计算用户应得的奖励。

4. 领取奖励：

    - 用户调用 `getReward` 函数领取奖励代币。

    - 合约会将计算好的奖励代币转移到用户的账户中，并将用户的奖励余额清零。

5. 解除质押：

    - 用户调用 `withdraw` 函数解除质押。

    - 合约会更新总质押量和用户的质押余额，并将质押代币转回给用户。

**demo**：

```solidity
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract StakingRewards {
    // 定义质押代币和奖励代币
    IERC20 public immutable stakingToken;
    IERC20 public immutable rewardsToken;

    // 合约的所有者
    address public owner;

    // 质押代币的总量
    uint public totalSupply;

    // 奖励的持续时间
    uint public duration;

    // 奖励的结束时间
    uint public finishAt;

    // 合约的更新时间
    uint public updatedAt;

    // 每秒奖励代币的数量
    uint public rewardRate;

    // 每个代币的累计奖励; RPT
    // 等于 rewardRate * 持续时间 / 质押代币的总量
    uint public rewardPerTokenStored;

    // 记录每个用户的 RPT
    mapping(address => uint) public userRewardPerTokenPaid;

    // 记录每个用户拿到了多少奖励
    mapping(address => uint) public rewards;

    // 记录每个用户质押了多少代币
    mapping(address => uint) public balances;

    // 构造函数
    constructor(address _stakingToken, address _rewardsToken) {
        stakingToken = IERC20(_stakingToken);
        rewardsToken = IERC20(_rewardsToken);
        owner = msg.sender;
    }

    // 修饰符, 只有合约的所有者才能调用
    modifier onlyOwner() {
        require(msg.sender == owner, "only owner can call");
        _;
    }

    // 更新奖励的修饰符
    modifier updateReward(address _account) {
        rewardPerTokenStored = rewardPerToken();
        updatedAt = lastTimeRewardApplicable();
        if (_account != address(0)) {
            rewards[_account] = earned(_account);
            userRewardPerTokenPaid[_account] = rewardPerTokenStored;
        }
        _;
    }

    // 设置奖励的持续时间
    function setRewardsDuration(uint _duration) public onlyOwner {
        require(
            finishAt < block.timestamp,
            "can't update duration before finish"
        );
        duration = _duration;
    }

    // 设置奖励金额
    function notifyRewardAmount(
        uint _amount
    ) public onlyOwner updateReward(address(0)) {
        if (block.timestamp >= finishAt) {
            // 如果上一轮奖励已经结束, 则直接更新
            rewardRate = _amount / duration;
        } else {
            // 如果这一轮奖励还未结束, 则需要先计算剩余时间的奖励
            uint leftover = finishAt - block.timestamp * rewardRate;
            rewardRate = (_amount + leftover) / duration;
        }

        require(rewardRate > 0, "reward rate must be positive");
        require(
            rewardRate * duration <= rewardsToken.balanceOf(address(this)),
            "not enough reward token"
        );

        updatedAt = block.timestamp;
        finishAt = block.timestamp + duration;
    }

    // 用户进行质押
    function stake(uint _amount) public updateReward(msg.sender) {
        require(_amount > 0, "Cannot stake 0");
        stakingToken.transferFrom(msg.sender, address(this), _amount);
        balances[msg.sender] += _amount;
        totalSupply += _amount;
    }

    // 用户解除质押
    function withdraw(uint _amount) public updateReward(msg.sender) {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        balances[msg.sender] -= _amount;
        totalSupply -= _amount;
        stakingToken.transfer(msg.sender, _amount);
    }

    function _min(uint a, uint b) private pure returns (uint) {
        return a < b ? a : b;
    }

    // 上一次奖励的时间
    function lastTimeRewardApplicable() public view returns (uint) {
        return _min(block.timestamp, finishAt);
    }

    // 获取每个代币的累计奖励
    function rewardPerToken() public view returns (uint) {
        if (totalSupply == 0) {
            return rewardPerTokenStored;
        }
        // 当前的 RPT = 之前的 RPT + 持续时间 * 每秒奖励 / 总供应量
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - updatedAt) * rewardRate) * 1e18) /
            totalSupply;
    }

    // 用户查看奖励
    function earned(address _account) public view returns (uint) {
        // 用户的奖励 = 用户的质押余额 * (当前的 RPT - 用户的 RPT) + 用户的奖励余额
        return
            (balances[_account] *
                (rewardPerToken() - userRewardPerTokenPaid[_account])) /
            1e18 +
            rewards[_account];
    }

    // 用户领取奖励
    function getReward() public updateReward(msg.sender) {
        uint reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.transfer(msg.sender, reward);
        }
    }
}
```

1. 部署两个 ERC20 合约，分别代表质押代币和奖励代币

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint amount) external {
        _mint(to, amount);
    }
}
```

2. 传入质押代币和奖励代币的地址，部署 StakingRewards 合约

3. 传入 1000，调用 setRewardsDuration 设置奖励的持续时间

4. 传入 StakingRewards 地址、1000000000000000000000 (1000 \* 1e18)，调用奖励代币的 mint 函数，设置奖励代币的总供应量

5. 传入 1000000000000000000000 (1 \* 1e18)，调用 notifyRewardAmount 设置奖励金额

6. 切换编辑器账户 2 作为质押账户

7. 传入账户 2 地址、1000000000000000000000 (1 \* 1e18)，调用质押代币的 mint 函数，设置质押代币的总供应量

8. 传入 StakingRewards 地址、1000000000000000000000 (1 \* 1e18)，调用质押代币的 approve 函数，授权 StakingRewards 合约转移质押代币

9. 传入 1000000000000000000000 (1 \* 1e18)，调用 stake 进行质押

10. 传入账户 2 地址，调用 balances 查看质押余额，返回 1000000000000000000000 (1 \* 1e18)

11. 传入账户 2 地址，调用 earned 查看奖励

12. 调用 getReward 领取奖励；再次调用 earned 查看奖励，可以看到奖励数据已更新

13. 传入账户 2 地址，调用奖励代币的 balanceOf，可以看到账户 2 的奖励代币余额增加

14. 传入 1000000000000000000000 (1 \* 1e18)，调用 withdraw 解除质押；再次调用 balances 查看质押余额，返回 0

<br>
