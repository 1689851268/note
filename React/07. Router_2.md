<br>

与 React Router 5 相比，区别有：

1.  内置组件的变化：移除 `Switch`、新增 `Routes` 等
2.  语法的变化：`component={About}` 变为 `element={<About>}` 等
3.  新增多个 hook：`useParams`、`useNavigate`、`useMatch` 等

<br><br>

# 使用

1.  安装依赖：`yarn add react-router-dom`
2.  配置项目入口文件：

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

// BrowserRouter 是一个路由容器, 它会把 history 传递给下层组件
import { BrowserRouter } from "react-router-dom";

const root = ReactDOM.createRoot(document.getElementById("root"));

// 使用 BrowserRouter 包裹 App 组件, 使得 App 组件中可以使用路由相关的 API
root.render(
    <React.StrictMode>
        <BrowserRouter>
            <App />
        </BrowserRouter>
    </React.StrictMode>
);
```

3.  使用路由：

```jsx
import { NavLink, Route, Routes } from "react-router-dom";
import About from "./pages/About";
import Home from "./pages/Home";

function App() {
    return (
        <div>
            <h1>App</h1>
            <div>
                {/* 1️⃣ 配置路由链接 */}
                <NavLink to="/about">About</NavLink>
                <br />
                <NavLink to="/home">Home</NavLink>
            </div>
            {/* 2️⃣ 注册路由; Routes 的功能相当于 v5 的 Switch */}
            <Routes>
                <Route path="/about" element={<About />} />
                <Route
                    caseSensitive // path 区分大小写
                    path="/home"
                    element={<Home />}
                />
            </Routes>
        </div>
    );
}

export default App;
```

对于 NavLink，不能再通过 `activeClassName` 属性修改高亮类名。需要将 `className` 属性值编写成一个函数来设置：

```jsx
<NavLink
    className={({ isActive }) => (isActive ? 'isActive' : '')}
    to='/about'
>
    About
</NavLink>
<br />
<NavLink
    className={({ isActive }) => (isActive ? 'isActive' : '')}
    to='/home'
>
    Home
</NavLink>
```

可以将重复的地方提取出来：

```jsx
const isActiveComputed = ({ isActive }) => (isActive ? 'isActive' : '');

<NavLink
    className={isActiveComputed}
    to='/about'
>
    About
</NavLink>
<br />
<NavLink
    className={isActiveComputed}
    to='/home'
>
    Home
</NavLink>
```

<br><br>

# Navigate

Navigate 用于在 React 应用程序中进行编程式导航，进行页面路由的跳转操作

Navigate 一般用作重定向

```jsx
<Routes>
    <Route path="/about" element={<About />} />
    <Route path="/home" element={<Home />} />
    {/* 兜底, 将未能匹配成功的 path 重定向到 Home 组件 */}
    <Route path="*" element={<Navigate to="/home" />} />
</Routes>
```

Navigate 可以设置 `to`、`replace` 属性

<br><br>

# 路由表

```jsx
import { NavLink, Navigate, useRoutes } from "react-router-dom";
import About from "./pages/About";
import Home from "./pages/Home";

function App() {
    // 1️⃣ 使用 useRoutes() 注册路由表
    const element = useRoutes([
        {
            path: "/about",
            element: <About />,
        },
        {
            path: "/home",
            element: <Home />,
        },
        {
            path: "*",
            element: <Navigate to="/home" />,
        },
    ]);

    return (
        <div>
            <h1>App</h1>
            <div>
                <NavLink to="/about">About</NavLink>
                <br />
                <NavLink to="/home">Home</NavLink>
            </div>
            {/* 2️⃣ 使用 element 代替 <Routes> 组件 */}
            {element}
        </div>
    );
}

export default App;
```

在日常开发中，会将路由表放置在单独的文件进行管理：

```jsx
import { Navigate } from 'react-router-dom';
import About from '../pages/About';
import Home from '../pages/Home';

const routes = [
    {
        path: '/about',
        element: <About />,
    },
    {
        path: '/home',
        element: <Home />,
    },
    {
        path: '*',
        element: <Navigate to='/home' />,
    },
];

export default routes;
import { NavLink, useRoutes } from 'react-router-dom';
import routes from './routes'; // 导入路由表

function App() {
    // 1️⃣ 使用 useRoutes 注册路由表
    const element = useRoutes(routes);

    return (
        <div>
            <h1>App</h1>
            <div>
                <NavLink to='/about'>About</NavLink>
                <br />
                <NavLink to='/home'>Home</NavLink>
            </div>
            {/* 2️⃣ 使用 element 代替 <Routes> 组件 */}
            {element}
        </div>
    );
}

export default App;
```

<br><br>

# 嵌套路由

1.  修改路由表：

```jsx
{
    path: '/about',
    element: <About />,
    // 通过 children 属性定义子路由
    children: [
        {
            path: 'news', // 子路由的 path 不需要 / 前缀
            element: <h1>News</h1>,
        },
        {
            path: 'contact',
            element: <h1>Contact</h1>,
        },
    ],
},
```

2.  配置子路由：

```jsx
import React from "react";
import { NavLink, Outlet } from "react-router-dom";

export default function About() {
    return (
        <>
            <h2>About</h2>
            <div>
                {/* 1️⃣ 配置路由链接 */}
                <NavLink to="news">news</NavLink>
                <br />
                <NavLink to="contact">contact</NavLink>
            </div>
            {/* 2️⃣ 使用 Outlet 组件来渲染子路由 */}
            <Outlet />
        </>
    );
}
```

此时 `NavLink` 的 `to` 属性可以写成 `news` / `./news` / `/about/news`；注意不能写成 `/news`，否则会当成一级路由处理。

默认情况下，点击子路由 `NavLink`，其父路由 `NavLink` 也会添加高亮类名。此时如果希望父路由 `NavLink` 没有高亮类名，可以给父路由 `NavLink` 添加 `end` 属性：

```jsx
import { NavLink, useRoutes } from "react-router-dom";
import routes from "./routes";

function App() {
    const element = useRoutes(routes);
    return (
        <div>
            <h1>App</h1>
            <div>
                {/* end 属性表示精确匹配, 即只有当路径完全匹配时才会高亮 */}
                <NavLink end to="/about">
                    About
                </NavLink>
                <br />
                <NavLink to="/home">Home</NavLink>
            </div>
            {element}
        </div>
    );
}

export default App;
```

<br><br>

# 路由传参

## params 参数

1.  在父路由组件中设置 params 参数：

```jsx
import React from "react";
import { NavLink, Outlet } from "react-router-dom";

export default function About() {
    const [id] = React.useState(0); // 父路由组件中的状态
    return (
        <>
            <h2>About</h2>
            <div>
                <NavLink to="news">news</NavLink>
                <br />
                {/* 传递 params 参数 */}
                <NavLink to={`contact/${id}`}>contact</NavLink>
            </div>
            <Outlet />
        </>
    );
}
```

2.  配置路由表接收 params 参数：

```jsx
import { Navigate } from "react-router-dom";
import About from "../pages/About";
import Home from "../pages/Home";
import News from "../components/News";
import Contact from "../components/Contact";

const routes = [
    {
        path: "/about",
        element: <About />,
        children: [
            {
                path: "news",
                element: <News />,
            },
            {
                path: "contact/:id", // 接收 params 參數
                element: <Contact />,
            },
        ],
    },
    {
        path: "/home",
        element: <Home />,
    },
    {
        path: "*",
        element: <Navigate to="/home" />,
    },
];

export default routes;
```

3.  在子路由组件中获取 params 参数：

```jsx
import React from "react";
import { useParams } from "react-router-dom";

export default function Contact() {
    const { id } = useParams(); // 获取 params 参数
    return (
        <>
            <h3>Contact - {id}</h3>
        </>
    );
}
```

这里与 v5 不同，v5 是通过 this.props.match.params 获取 params 参数。

在 v6 中可以通过 useMatch 获取 this.props.match：`const match = useMatch('/about/contact/:id')`

<br>

## search 参数

1.  在父路由组件中传递 search 参数：

```jsx
export default function About() {
    const [id] = React.useState(0); // 父路由组件中的状态
    return (
        <>
            <h2>About</h2>
            <div>
                <NavLink to="news">news</NavLink>
                <br />
                {/* 传递 search 参数 */}
                <NavLink to={`contact?id=${id}`}>contact</NavLink>
            </div>
            <Outlet />
        </>
    );
}
```

2.  在子路由组件中获取 search 参数：

```jsx
import React from "react";
import { useSearchParams } from "react-router-dom";

export default function Contact() {
    const [searchParams, setSearchParams] = useSearchParams(); // 获取 search 参数 & 更新 search 参数的方法
    const id = searchParams.get("id"); // 获取 search 参数中的 id

    return (
        <>
            <h3>Contact - {id}</h3>
            {/* 更新 search 参数 */}
            <button onClick={() => setSearchParams({ id: 1 })}>
                点击更新 search 参数
            </button>
        </>
    );
}
```

这里与 v5 不同，v5 是通过 this.props.location.search 获取 search 参数。

在 v6 中可以通过 useLocation 获取 this.props.location：`const location = useLocation()`

<br>

## state 参数

1.  在父路由组件中传递 state 参数：

```jsx
export default function About() {
    const [id] = React.useState(0); // 父路由组件中的状态
    return (
        <>
            <h2>About</h2>
            <div>
                <NavLink to="news">news</NavLink>
                <br />
                {/* 传递 state 参数 */}
                <NavLink to="contact" state={{ id }}>
                    contact
                </NavLink>
            </div>
            <Outlet />
        </>
    );
}
```

2.  在子路由组件中获取 state 参数：

```jsx
import React from "react";
import { useLocation } from "react-router-dom";

export default function Contact() {
    const location = useLocation(); // 获取 this.props.location
    const { id } = location.state; // 获取 state 参数
    return (
        <>
            <h3>Contact - {id}</h3>
        </>
    );
}
```

<br><br>

# 编程式路由

```jsx
import React from "react";
import { NavLink, Outlet, useNavigate } from "react-router-dom";

export default function About() {
    const navigate = useNavigate(); // 通过 useNavigate 方法获取 navigate 方法

    const handleClick = (id) => {
        // 跳转到子路由组件, 并传递 state 参数, 并且替换当前路由
        navigate("contact", { state: { id }, replace: true });
    };

    return (
        <>
            <h2>About</h2>
            <div>
                <NavLink to="news">news</NavLink>
                <br />
                <button onClick={() => handleClick(1)}>contact</button>
            </div>
            <Outlet />
        </>
    );
}
```

上例的 `contact` 可以写成 `./contact` / `/about/contact`；但不能写成 `/contact`，否则会当成一级路由处理。

<br>
