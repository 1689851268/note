<br>

React Router 以 3 个不同的包发布到 npm 上，它们分别为：

1.  react-router：路由的核心库，提供了组件、钩子...
2.  react-router-dom：包含 react-router 所有内容，并添加了专门用于 DOM 的组件
3.  react-router-native：包括 react-router 所有内容，并添加了专门用于 ReactNative 的 API

<br><br>

# 使用

1.  安装依赖包 **react-router-dom**
2.  使用 `<Link>` 编写路由跳转逻辑
3.  使用 `<Route>` 编写组件显示逻辑
4.  使用 [Router] 包裹所有的 `<Link>`、`<Route>`；注意：包裹一组 `<Link>`、`<Route>` 的 [Router] 要相同

-   [Router] 一般使用 `<BrowserRouter>` / `<HashRouter>`
-   路由组件一般放在 pages 文件夹下，普通组件一般放在 components 文件夹下

<br><br>

# Route props

路由组件会接收到路由器传递过来的 3 个属性：`match`、`history`、`location`

<br>

## match

match 对象包含有关 `<Route path>` 如何与 URL 匹配的信息：

1.  `params`：动态路由参数
2.  `path`：路径的匹配模式，eg：`/user/:id`（通常用于构建嵌套 Route 标签）
3.  `url`：路径的匹配结果，eg：`/user/001`（通常用于构建嵌套 Link 标签）
4.  `isExact`：是否匹配整个 URL

<br>

## history

1.  `go: f go(n)`
2.  `goBack: f goBack()`
3.  `goForward: f goForward()`
4.  `push: f push(path, state)`
5.  `replace: f replace(path, state)`
6.  `action: "PUSH"`
7.  `length: 2`
8.  `block: f block(prompt)`
9.  `createHref: f createHref(location)`
10. `listen: f listen(listener)`
11. `location: {pathname: "/xxx", search: "", hash: "", state: undefined, key: "znwrid"}`

<br>

## location

其实就是 `history.location`：

1.  `pathname: "/xxx"`
2.  `search: ""` - 存放 query 参数
3.  `state: undefined` - 存放 state 参数
4.  `hash: ""`
5.  `key: "znwrid"`

<br><br>

# Link 标签

`<Link>` 用于跳转

```javascript
import { Link } from "react-router-dom";
```

<br>

## to 属性

`<Link>` 接收 `to` 属性，用于配置跳转的路径

```html
<Link to="/about">About</Link>
```

`to` 的属性值有 string 和 object 两种写法

```html
<link to="/courses?sort=name" /> <Link to={{ pathname: '/courses', search:
'?sort=name', hash: '#the-hash', state: { fromDashboard: true } }}/>
```

object 写法中，各属性含义如下：

1.  `pathname`：指定跳转路径
2.  `search`：指定查询参数
3.  `hash`：指定哈希值
4.  `state`：状态持续到 location

<br>

## replace 属性

`<Link>` 接收 `replace` 属性，用于指定跳转的方式

```html
<link to="/courses" replace />
```

<br>

## innerRef 属性

`<Link>` 接收 `innerRef` 属性，用于访问 ref 组件的底层

```jsx
const refCallback = (node) => {
    // 'node' 是指挂载的 DOM 元素;  卸载时为 null
};

<Link to="/" innerRef={refCallback} />;
```

<br>

## others

可以传递您想要放在 `<a>` 上的属性，如 `title`、`id`、`className` 等

<br><br>

# Route 标签

当 `<Route>` 的 `path` 与当前 URL 匹配时，它会呈现其 `children`

```jsx
<BrowserRouter>
    <Route path="/">
        {" "}
        <Home />{" "}
    </Route>
    <Route path="/news">
        {" "}
        <NewsFeed />{" "}
    </Route>
</BrowserRouter>
```

如果一个组件同时成为了多个 `<Route>` 的 `children`，React 会将其视为相同的组件实例，并在切换路由时保留组件的状态。如果不需要这样做，可以给组件设置 `key` 属性作为唯一标识。如此，React 在切换路由时会重新创建组件实例。

除了 `children`，还可以通过 `component` 属性指定显示的组件

```jsx
<Route path="/user" component={User} />
```

<br>

## path 属性

`<Route>` 接收 `path` 属性，用于指定匹配的路径

```jsx
<Route path="/">
    {" "}
    <Home />{" "}
</Route>
```

`path` 的属性值有 string 和 string[] 两种写法

```jsx
<Route path="/users/:id">
    <User />
</Route>
<Route path={["/users/:id", "/profile/:id"]}>
    <User />
</Route>
```

<br>

## exact 属性

`<Route>` 接收 `exact` 属性，表示是否开启精确匹配

```jsx
<Route exact path="/one">
    {" "}
    <Home />{" "}
</Route>
```

表示仅当 `path` 属性值与 `location.pathname` 完全匹配时，才会呈现对应的组件

| path 属性值 | location.pathname | exact | matches? |
| ----------- | ----------------- | ----- | -------- |
| /one        | /one/two          | true  | no       |
| /one        | /one/two          | false | yes      |

<br>

## strict 属性

```
<Route>` 接收 `strict` 属性，表示是否约束 `/
<Route strict path="/one/"> <Home /> </Route>
```

表示具有尾部斜杠的 `path` 将仅匹配具有尾部斜杠的 `location.pathname`

| path 属性值 | location.pathname | strict | matches? |
| ----------- | ----------------- | ------ | -------- |
| /one        | /one              | true   | yes      |
| /one        | /one/             | true   | no       |
| /one        | /one/two          | true   | no       |

<br><br>

# NavLink 标签

Link 标签的特殊版本，会为展现的元素添加类名

```jsx
<NavLink to="/about">About</NavLink>
```

默认会为展现的元素添加 `active` 类名；如果想使用别的类名，可以通过 `activeClassName` 属性修改

<br><br>

# Switch 标签

默认情况下，如果 URL 匹配多个 Route 标签，则会显示多个 Route 标签对应的元素

如果使用 Switch 标签包裹住所有的 Route 标签，则表示同一时间只会匹配一个 Route 标签，此时只会展示第一个匹配的 Route 标签对应的元素

```jsx
<Switch>
    <Route path="/home" component={Home} />
    <Route path="/user" component={User} />
</Switch>
```

<br><br>

# Redirect 标签

一般写在所有路由的后面，当所有路由都无法匹配时进行重定向。在 v6 中已被移除

使用 `to` 属性指定重定向的路由

```jsx
<Redirect to="/somewhere/else" />
<Redirect
    to={{
        pathname: "/login",
        search: "?utm=your+face",
        state: { referrer: currentLocation }
    }}
/>
```

<br><br>

# 路由模式对比

## history

1.  `<BrowserRouter>` 使用的是 H5 的 history API
2.  形如 `localhost:3000/a/b/c`
3.  使用 history 路由模式时，路径的匹配可能会出问题，因为浏览器不知道路径从哪里开始表示前端路由
4.  刷新页面仍能保存好 state 参数

<br>

## hash

1.  `<HashRouter>` 使用的是 URL 的哈希值
2.  形如 `localhost:3000/#/a/b/c`
3.  使用 hash 路由模式则不会出现路径的匹配问题，因为前端路由会被 `#` 分隔开
4.  刷新页面会导致 state 参数丢失，因为 state 参数存放在 history 中

<br>

解决多级路径刷新 页面样式丢失的问题：

1.  public/index.html 中，引入样式时不写 `./` 而写 `/`
2.  public/index.html 中，引入样式时不写 `./` 而写 `%PUBLIC_URL%/` (webpack 专属)
3.  使用 HashRouter

<br><br>

# 嵌套路由

-   子路由需要以父路由路径为前缀
-   路由的匹配是按照注册路由的顺序进行的

<br><br>

# 路由传参

## 动态路由参数 / params 参数

```jsx
{
    /* 传递参数 */
}
<Link to={`/about/${id}`}> About </Link>;

{
    /* 接收参数 */
}
<Route path="/about/:userId" component={About} />;
```

在路由组件中，可通过 Route props `match` 的 `params` 获取动态路由参数：

```javascript
this.props.match.params; // { userId: xxx }
```

<br>

## query 参数 / search 参数

```jsx
{
    /* 传递参数 */
}
<Link to={`/about?userId=${id}`}> About </Link>;

{
    /* 无需接收参数 */
}
<Route path="/about" component={About} />;
```

在组件中，可通过 Route props `location` 的 `search` 获取 query 参数：

```javascript
this.props.location.search; // ?userId=xxx
```

若希望将 `?userId=xxx` 转成 `{ userId: xxx }` 的形式，可以封装如下工具方法：

```javascript
// 将 URL 转换为对象, eg: ?a=1&b=2 => { a: '1', b: '2' }
const handleUrlToObj = (url) => {
    const pairs = url.split("?")[1].split("&"); // ?a=1&b=2 => ['a=1', 'b=2']
    return pairs.reduce((obj, pair) => {
        const [key, value] = pair.split("=");
        return { ...obj, [key]: value };
    }, {});
};
```

<br>

## state 参数

```jsx
{
    /* 传递参数 */
}
<Link to={{ pathname: `/about`, state: { userId: id } }}> About </Link>;

{
    /* 无需接收参数 */
}
<Route path="/about" component={About} />;
```

在组件中，可通过 Route props `location` 的 `state` 获取 state 参数：

```javascript
this.props.location.state; // { userId: xxx }
```

state 参数没有存放在 URL 上，但刷新页面不会丢失，是因为 React 将 state 参数存放到 `history.location` 上了。就是说，如果我把浏览器的历史记录清空，history 也会被重置，就会导致 state 参数丢失。

<br><br>

# 编程式路由

在路由组件中，可通过 Route props `history` 来实现编程式路由：

```javascript
this.props.history.push(`/about`);
this.props.history.replace(`/about`);
```

在非路由组件中，可以使用高阶组件 `withRouter` 来注入 `history` 对象：

```jsx
import React from "react";
import { withRouter } from "react-router-dom";

class App extends React.Component {
    handleClick = (id) => {
        return () => this.props.history.push(`/about?userId=${id}`);
    };

    render() {
        return (
            <div>
                <button onClick={this.handleClick(id)}>跳转</button>
            </div>
        );
    }
}

export default withRouter(App); // 注入 history 对象
```

编程式路由中，能以如下形式传递参数：

```javascript
this.props.history.push(`/about/${id}`); // 动态路由参数 / params 参数

this.props.history.push(`/about?userId=${id}`); // query 参数 / search 参数

this.props.history.push(`/about`, { userId: id }); // state 参数
```

除了 `push` 和 `replace`，还能使用 `goBack`、`goForward` 和 `go` 实现编程式路由

```javascript
this.props.history.goBack(); // 上一页
this.props.history.goForward(); // 下一页
this.props.history.go(1); // 参数为正数则往下翻, 为负数则往上翻
```

<br>
