# 游标

-   游标只能用在存储过程 / 函数中
-   使用游标可以对 select 语句的结果集进行逐行处理

> 使用步骤：
>
> 1. 定义游标：`declare`
> 2. 打开游标：`open`
> 3. 逐行提取游标集中的行：`fetch`
> 4. 关闭游标：`close`
> 5. 释放游标：`deallocate`

## 定义游标

```sql
declare <游标名> cursor for <子查询>;
```

-   游标只读，不能进行更新操作

## 打开游标

```sql
open <游标名>;
```

游标打开后默认指向第一个元组

## 获取游标

```sql
fetch <游标名> into <变量名>;
```

-   当游标移至尾部，不可再读取游标，必须关闭游标，然后重新打开游标

> 通过检查全局变量`@@FETCH_STATUS`来判断是否已读完游标集中所有元组。`@@FETCH_STATUS`的值有：
>
> -   `0`：`fetch` 语句成功，表示已经从游标集中获取了元组值
> -   `-1`：`fetch`语句失败或此行不在结果集中
> -   `-2`：被提取的行不存在

## 关闭游标

```sql
close <游标名>;
```

## 释放游标

```sql
deallocate <游标名>;
```

# 触发器

-   触发器是用户定义在关系表上的一类由事件驱动的存储过程，由服务器**自动激活**
-   是一种特殊的存储过程，不管什么原因造成的数据变化都能自动响应
-   有两个特殊的表用在触发器语句中，不同的数据库管理系统其名称不一样：
    -   Oracle 数据库使用 old 表 & new 表
    -   在 SQL Server 中使用 deleted 表 & inserted 表

> 以 SQL Server 为例介绍触发器：
>
> -   deleted 表、inserted 表的结构与**触发器作用的基本表**结构一致
> -   当**针对触发器作用的基本表**的 SQL 语句开始执行时，自动产生 deleted 表、inserted 表
> -   当 SQL 语句执行完毕， deleted 表、inserted 表会被删除

-   deleted 表：将被删除 / 修改前的元组值存入 deleted 表中
-   inserted 表：将被插入 / 修改后的元组值存入 inserted 表中，同时更新触发器作用的基本表
-   触发器仅在当前数据库中被创建
-   触发器有 3 种类型：插入、删除、修改

## 创建触发器

```sql
create trigger <触发器名>
on <表名>
for { insert | update | delete }
as <子查询>;
```

-   一张基本表可创建多个触发器
-   触发器是自动执行的，如果一张基本表建立了多个触发器，会加大系统的开销
-   触发器常常用于维护复杂的完整性约束，不用于业务处理
-   用户的业务处理常常使用**存储过程**实现
-   凡是可以用一般约束限制的，就不要使用触发器（如限制性别仅取男/女，可使用检查约束 check 实现

## 修改触发器

```sql
alter trigger <触发器名>
on <表名>
for { insert | update | delete }
as <子查询>;
```

## 删除触发器

```sql
drop trigger <触发器名>;
```
