# CommonJS

1. CommonJS 是社区标准
2. 使用函数实现
3. 仅支持 Node.js 环境
4. 仅支持动态依赖
5. 动态依赖是同步执行的

<br><br>

## 模块包装机制

在 CommonJS 规范中, Node.js 会将每个模块的代码包装在一个函数中, 该函数接收 5 个参数:

```javascript
(function (exports, require, module, __filename, __dirname) {
    // 模块代码
});
```

-   `exports`: 用于导出数据; 默认为空对象; 是 `module.exports` 的引用
-   `require`: 用于导入数据; 是一个函数, 返回 [被导入模块所导出的数据], 即 [被导入模块的 `module.exports`]
-   `module`: 当前模块对象, 包含模块信息
-   `__filename`: 当前模块的路径
-   `__dirname`: 当前模块所在目录的路径

```js
// app.js
console.log(arguments);
```

```js
[Arguments] {
    '0': {}, // module.exports 的引用, 用于导出数据
    '1': [Function: require] {...}, // require 函数, 用于导入数据
    '2': Module { // 当前模块对象
        path: 'e:\\node.js\\code\\newDemo\\js', // 当前模块所在目录的路径
        exports: {}, // module.exports 对象, 用于导出数据
        filename: 'e:\\node.js\\code\\newDemo\\js\\operation.js', // 当前模块的路径
        // ...
    },
    '3': 'e:\\node.js\\code\\newDemo\\js\\operation.js', // 当前模块的路径
    '4': 'e:\\node.js\\code\\newDemo\\js' // 当前模块所在目录的路径
}
```

<br><br>

## 导出方式

### module.exports

1.  以 `module.exports = xxx` 的形式导出数据:

```javascript
// math.js
module.exports = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

导入时 会先执行一遍被导入的文件, 所以上例会打印 `math.js` - `num 10`.

<br>

2.  以 `module.exports.xxx = xxx` 的形式导出数据:

```javascript
// math.js
module.exports.num = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

上例会打印 `math.js` - `num { num: 10 }`.

<br>

### exports

1.  以 `exports.xxx = xxx` 的形式导出数据:

```javascript
// math.js
exports.num = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

上例会打印 `math.js` - `num { num: 10 }`.

<br>

提问: 能以 `exports = xxx` 的形式导出数据吗? 答案是: 不能.

讲解: 用于文件导出的属性是 `module.exports`. `exports` 是 `module.exports` 的引用 (相当于 `exports = module.exports`). 所以, 直接给 `exports` 赋值 (相当于 `exports = xxx`) 是修改不了 `module.exports` 的. 所以, 通过直接赋值导出的操作, 只能由 `module.exports` 完成, 不能使用 `exports`.

```javascript
// math.js
exports = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

上例会打印 `math.js` - `num {}`.

可以看到 导入的是空对象 `{}`, 即 `module.exports` 的默认值.

<br>

## 导入方式

以 `require('模块标识')` 的形式导入数据, 会返回 [被导入模块所导出的数据], 即 [被导入模块的 `module.exports`].

<br>

模块分 3 类: 核心模块, 自定义模块, 第三方模块

1.  **核心模块**: Node 的内置模块, 模块标识是 `模块名`
2.  **自定义模块**: 用户自己创建的模块, 模块标识是 `文件路径`, 可以是绝对路径 / 相对路径
3.  **第三方模块**: 需要手动下载的模块; 模块标识是 `模块名`

<br>

`require` 根据 `模块标识` 的不同, 使用不同的查找策略:

1.  `模块名`: 如 `require('fs')`, `require('mysql')`
    1.  查看是否为内置模块. 如果是, 则直接从内存加载; 如果不是, 则往下走
    2.  到同级的 node_modules 目录中寻找 `'xxx'` 目录, 找不到则往上一级的 node_modules 目录找, 直至根目录.
    3.  在 `'xxx'` 目录下, 找到 package.json 中的 main 字段, 读取入口文件. 如果没有 package.json, 或者 main 字段 [入口不存在] / [无法解析], 则找该目录下的 index.js 文件
2.  `文件路径`: 如 `require('./cjs1')`
    1.  如果是文件, 则按 `.js`, `.json`, `.node` 的顺序自动尝试补全文件后缀
    2.  如果是目录, 找到 package.json 中的 main 字段, 读取入口文件. 如果没有 package.json, 或者 main 字段 [入口不存在] / [无法解析], 则找该目录下的 index.js 文件

<br>

## 模块特性

### 动态依赖

动态依赖, 即运行时才能确定依赖, 所以可以在任意位置导入/导出, 且可以配合变量使用:

```javascript
// 可以在任意位置调用
if (process.env.NODE_ENV === "development") {
    const devTools = require("./dev-tools.js");
    devTools.init();
}

// 可以配合变量使用
function loadModule(moduleName) {
    return require(`./modules/${moduleName}.js`);
}
```

<br>

### 动态依赖是同步执行的

因为是同步执行的, 所以会阻塞代码.

```javascript
// math.js
console.log("loading math.js...");
module.exports = {
    add: (a, b) => a + b,
};

// app.js
console.log("start");
const math = require("./math.js"); // 同步执行, 阻塞后续代码
console.log("loaded");
console.log(math.add(1, 2));

// 打印:
// start
// loading math.js...
// loaded
// 3
```

<br>

### 循环依赖时返回部分导出对象

两个模块相互引用时, CommonJS 会返回当前已执行部分的导出对象, 避免无限循环.

```javascript
// a.js
console.log("a.js 开始执行");
exports.done = false;
const b = require("./b.js");
console.log("在 a.js 中, b.done =", b.done);
exports.done = true;
console.log("a.js 执行完毕");

// b.js
console.log("b.js 开始执行");
exports.done = false;
const a = require("./a.js"); // 此时 a.js 还未执行完, 返回部分导出 { done: false }
console.log("在 b.js 中, a.done =", a.done);
exports.done = true;
console.log("b.js 执行完毕");

// app.js
const a = require("./a.js");
console.log("a.done =", a.done);

// 打印:
// a.js 开始执行
// b.js 开始执行
// 在 b.js 中, a.done = false  <- 返回了 a.js 的部分导出
// b.js 执行完毕
// 在 a.js 中, b.done = true
// a.js 执行完毕
// a.done = true
```

<br>

### 加载机制与缓存

-   模块在首次加载后会被缓存 (`require.cache`)
-   多次 `require` 同一模块只执行一次
-   可以通过 `delete require.cache[modulePath]` 清除缓存重新加载

```javascript
// 首次加载
const module1 = require("./module.js");

// 从缓存获取 (不会重新执行模块代码)
const module2 = require("./module.js");

console.log(module1 === module2); // true

// 清除缓存后重新加载
delete require.cache[require.resolve("./module.js")];
const module3 = require("./module.js");

console.log(module1 === module3); // false (新实例)
```

<br>

### this 指向

在 CommonJS 模块中, 顶层的 `this` 指向 `module.exports` (而非全局对象).

模块加载时, `this`, `exports`, `module.exports` 三者指向同一个对象:

```javascript
// test.js
console.log(this === exports); // true
console.log(this === module.exports); // true
console.log(exports === module.exports); // true
```

**原因**: Node.js 的模块包装机制中, `this` 被绑定到 `module.exports`, 而 `exports` 是 `module.exports` 的引用.

<br>

当 `module.exports` 被重新赋值时, `this` 不再等于 `module.exports`:

```javascript
// test.js
module.exports = {
    add: (a, b) => a + b,
};

console.log(this === module.exports); // false (关系断开)
console.log(this === exports); // true (仍然相等)
console.log(exports === module.exports); // false (关系断开)
```

**原因**: 重新赋值 `module.exports` 创建了新对象, 但 `this` 和 `exports` 仍指向原始的空对象.

<br>

由于 `this` 指向 `module.exports`, 可以通过 `this` 添加导出:

```javascript
// math.js
this.add = (a, b) => a + b; // 等价于 module.exports.add = ...
this.subtract = (a, b) => a - b;

// app.js
const math = require("./math.js");
console.log(math.add(5, 3)); // 8
console.log(math.subtract(5, 3)); // 2
```

**但不推荐使用 `this` 导出**, 因为:

1. 可读性差, 不如 `module.exports` 或 `exports` 明确
2. 重新赋值 `module.exports` 后, 通过 `this` 添加的属性会失效

<br><br><br>

# ES Modules

-   ES Modules 是 ECMAScript 官方标准 (ES6/ES2015 引入)
-   使用新语法实现
-   同时支持浏览器环境和 Node.js 环境
-   同时支持静态依赖和动态依赖
-   动态依赖是异步执行的

<br><br>

## 导出方式

### 命名导出 (Named Exports)

可以导出多个值:

```javascript
// 直接导出
export const PI = 3.14159;
export function circle(radius) {
    return 2 * PI * radius;
}

// 或统一导出
const PI = 3.14159;
function circle(radius) {
    return 2 * PI * radius;
}
export { PI, circle };

// 导出时重命名
export { PI as pi, circle as calculateCircle };
```

<br>

### 默认导出 (Default Export)

每个模块只能有一个默认导出:

```javascript
// 方式一
export default function square(x) {
    return x * x;
}

// 方式二
function square(x) {
    return x * x;
}
export default square;
```

<br>

### 混合导出

可以同时使用命名导出和默认导出:

```javascript
export default function main() {
    console.log("Main function");
}

export const version = "1.0.0";
export const author = "John Doe";
```

<br><br>

## 导入方式

### 导入命名导出

```javascript
// 导入指定项
import { add, subtract } from "./math.js";

// 导入时重命名
import { add as sum } from "./math.js";

// 导入所有命名导出
import * as math from "./math.js";
console.log(math.add(1, 2));
```

<br>

### 导入默认导出

```javascript
// 默认导出可以用任意名称接收
import myFunction from "./module.js";
import MyClass from "./module.js";
```

<br>

### 导入混合导出

```javascript
import main, { version, author } from "./module.js";
```

<br>

### 仅执行模块

```javascript
// 仅执行模块代码, 不导入任何值
import "./init.js";
```

<br>

### 动态导入 (Dynamic Import)

运行时异步加载模块, 返回 Promise:

```javascript
// 条件加载
if (condition) {
    import("./module.js").then((module) => {
        module.doSomething();
    });
}

// 配合 async/await
async function loadModule() {
    const module = await import("./module.js");
    module.doSomething();
}
```

<br><br>

## 重导出 (Re-export)

用于聚合多个模块:

```javascript
// 重导出所有命名导出
export * from "./math.js";

// 重导出指定项
export { add, subtract } from "./math.js";

// 重导出时重命名
export { add as sum } from "./math.js";

// 重导出默认导出为命名导出
export { default as multiply } from "./math.js";
```

<br><br>

## 模块特性

### 模块作用域

模块有独立作用域, 顶层变量不会污染全局:

```javascript
// module.js
const name = "Module"; // 不会成为全局变量
```

<br>

### 严格模式

所有模块默认运行在严格模式 (`'use strict'`):

```javascript
// 自动启用严格模式
x = 10; // ReferenceError: x is not defined
```

<br>

### 模块提升 (Hoisting)

`import` 语句会被提升到模块顶部, 优先执行:

```javascript
// 这样写完全正常
foo();
import { foo } from "./module.js"; // import 会被提升
```

这是因为 `import` 在编译阶段执行, 而非运行阶段. 因此:

-   不能在条件语句或函数内使用
-   不能搭配表达式或变量使用

```javascript
// ❌ 错误: 不能在条件语句中使用
if (condition) {
    import { foo } from './module.js';
}

// ❌ 错误: 不能使用表达式
import { 'f' + 'oo' } from './module.js';

// ❌ 错误: 不能使用变量
const modulePath = './module.js';
import { foo } from modulePath;

// ✅ 正确: 使用动态导入
if (condition) {
    const module = await import('./module.js');
}
```

<br>

### 单例模式

模块只执行一次, 多次导入返回同一实例:

```javascript
// math.js
console.log("math.js");

// app.js
import "./math.js";
import "./math.js";
import "./math.js";

// 打印:
// math.js
```

<br>

### 实时绑定 (Live Binding)

ES Modules 的导入是**只读的实时绑定 (read-only live bindings)**: 当导出模块更新导出值时, 导入模块会自动看到最新值, 但导入方无法重新赋值.

**核心特性:**

-   **实时同步**: 导出模块的更新会立即反映到导入模块
-   **只读限制**: 导入方无法修改绑定本身 (但对象属性可修改)
-   **编译时建立**: 绑定关系在模块加载时确定, 无法动态改变

<br>

**命名导出: 绑定变量本身**

命名导出会创建对**变量的实时引用**, 可以跟踪重新赋值:

```javascript
// counter.js
export let count = 0;
export function increment() {
    count++; // 导出模块修改变量
}

// app.js
import { count, increment } from "./counter.js";
console.log(count); // 0
increment();
console.log(count); // 1 ✅ 实时更新

// count = 10; // ❌ TypeError: Assignment to constant variable
// 导入方无法重新赋值
```

<br>

**默认导出: 语法差异导致不同行为**

默认导出的行为取决于具体语法:

**1. `export default <表达式>` - 导出表达式的结果值**

```javascript
// module.js
let count = 0;
export default count; // 导出的是表达式 value 的计算结果 (数字 1)
export function increment() {
    count++; // 修改局部变量, 不影响已导出的绑定
}

// app.js
import count, { increment } from "./counter.js";
console.log(count); // 0
increment();
console.log(count); // 0 ❌ 未更新
```

**原因**: `export default value` 会先计算表达式 `value` (结果为 0), 然后导出这个值. 绑定的是 "计算结果", 而非变量本身.

**2. `export { value as default }` - 创建变量的实时引用**

```javascript
// module.js
let count = 0;
export { count as default }; // 导出的是变量 value 的实时引用
export function increment() {
    count++; // 修改会反映到导入方
}

// app.js
import count, { increment } from "./counter.js";
console.log(count); // 0
increment();
console.log(count); // 1 ✅ 实时更新
```

<br>

**对象属性的可变性**

无论哪种导出方式, 导出对象的**属性**都可以修改 (因为绑定的是对象引用):

```javascript
// counter.js
const state = { count: 0 };
export default state;
export function increment() {
    state.count++; // 修改对象属性
}

// app.js
import state, { increment } from "./counter.js";
console.log(state.count); // 0
increment();
console.log(state.count); // 1 ✅ 对象属性可变
```

<br>

### this 指向

模块顶层的 `this` 为 `undefined`:

```javascript
console.log(this); // undefined
```

<br>

### import.meta

提供模块元信息:

```javascript
console.log(import.meta.url); // 当前模块的 URL
console.log(import.meta.resolve("./other.js")); // 解析模块路径
```

<br>

### Top-level await

支持在模块顶层使用 `await` (ES2022):

```javascript
// 顶层 await
const data = await fetch("/api/data").then((res) => res.json());

export { data };
```

<br><br>

## 浏览器中使用

### 基本用法

```html
<!-- type="module" 启用模块模式 -->
<script type="module">
    import { add } from "./math.js";
    console.log(add(1, 2));
</script>

<!-- 或加载外部模块 -->
<script type="module" src="./app.js"></script>
```

<br>

### 自动延迟执行 (Deferred)

模块脚本默认延迟执行 (等效于 `defer` 属性), 不会阻塞 HTML 解析:

```html
<script type="module">
    // 在 HTML 解析完成后执行
    console.log(document.querySelector("div")); // 可以访问 DOM
</script>
```

这使得模块脚本可以放在 `<head>` 中, 而无需等待 DOM 加载完成:

```html
<!DOCTYPE html>
<html>
    <head>
        <script type="module">
            // 即使在 head 中, 也能正常访问 body 中的元素
            console.log(document.querySelector("div"));
        </script>
    </head>
    <body>
        <div>Content</div>
    </body>
</html>
```

<br>

### CORS 限制

模块必须遵循 CORS 策略, 需要通过 Web 服务器访问:

```javascript
// ✅ 正确: 通过服务器访问
// http://localhost:3000/app.js

// ❌ 错误: 直接打开 HTML 文件
// file:///C:/project/app.js (会报 CORS 错误)
```

<br>

### 必须指定文件扩展名

浏览器中必须写完整路径和扩展名:

```javascript
import { add } from "./math.js"; // ✅ 正确
import { add } from "./math"; // ❌ 错误
```

<br>

### nomodule 兼容方案

为不支持模块的旧浏览器提供降级方案:

```html
<script type="module" src="modern.js"></script>
<script nomodule src="legacy.js"></script>
```

<br><br>

## Node.js 中使用

### 启用 ES Modules

**方式一: 使用 .mjs 扩展名**

```javascript
// math.mjs
export function add(a, b) {
    return a + b;
}
```

**方式二: package.json 配置**

```json
{
    "type": "module"
}
```

配置后, 所有 `.js` 文件都被视为 ES Modules. 若需使用 CommonJS, 使用 `.cjs` 扩展名.

<br>

### 特殊处理

1.  **filename 和 dirname 替代方案**

ES Modules 中没有 `__filename` 和 `__dirname`:

```javascript
import { fileURLToPath } from "url";
import { dirname } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

2.  **导入 JSON 文件**

Node.js 20.10.0+ 支持导入断言:

```javascript
import data from './data.json' with { type: 'json' };
```

3.  **导入内置模块**

推荐使用 `node:` 前缀:

```javascript
import fs from "node:fs";
import path from "node:path";
```

<br>

### 与 CommonJS 互操作

1.  **ESM 导入 CJS 模块**

ES Modules 可以导入 CommonJS 模块:

```javascript
// cjs-module.cjs
module.exports = {
    name: "CommonJS",
    version: "1.0.0",
};
```

```javascript
// esm-module.mjs
import cjsModule from "./cjs-module.cjs";
console.log(cjsModule.name); // 'CommonJS'

// 命名导入会被包装为 default
import { name } from "./cjs-module.cjs"; // ❌ 不支持
```

2.  **CJS 导入 ESM 模块**

CommonJS 无法直接使用 `require()` 导入 ES Modules, 需使用动态导入:

```javascript
// cjs-file.cjs
async function loadESM() {
    const esmModule = await import("./esm-module.mjs");
    console.log(esmModule.name);
}

loadESM();
```

3.  **使用 createRequire**

在 ESM 中加载 CommonJS 模块:

```javascript
import { createRequire } from "module";
const require = createRequire(import.meta.url);

const cjsModule = require("./cjs-module.cjs");
```

<br><br><br>

# 最佳实践

## 模块命名规范

```javascript
// ✅ 使用有意义的名称
import { UserService } from "./services/user.js";

// ❌ 避免模糊命名
import { getData } from "./utils.js";
```

<br>

## 单一职责原则

每个模块应有单一, 明确的职责:

```javascript
// ✅ 正确: 职责单一
// user-validator.js
export function validateUser(user) {
    /* ... */
}

// user-service.js
export function createUser(user) {
    /* ... */
}

// ❌ 错误: 职责混乱
// user.js
export function validateUser(user) {
    /* ... */
}
export function renderUserUI(user) {
    /* ... */
}
```

<br>

## 避免循环依赖

```javascript
// ❌ 循环依赖
// a.js
import { b } from "./b.js";
export const a = "A";

// b.js
import { a } from "./a.js";
export const b = "B";

// ✅ 解决方案: 提取共享依赖
// shared.js
export const shared = "Shared";

// a.js
import { shared } from "./shared.js";

// b.js
import { shared } from "./shared.js";
```

<br>

## 使用 barrel 文件聚合导出

```javascript
// components/index.js
export { Button } from "./Button.js";
export { Input } from "./Input.js";
export { Modal } from "./Modal.js";

// 使用时
import { Button, Input } from "./components/index.js";
```

<br>

## 合理使用动态导入

```javascript
// ✅ 条件加载
if (userPreference === "dark") {
    const theme = await import("./themes/dark.js");
    theme.apply();
}

// ✅ 路由懒加载 (React 示例)
const Home = lazy(() => import("./pages/Home.js"));
```

<br>

## 导入顺序规范

```javascript
// 1. 内置模块
import path from "node:path";
import fs from "node:fs";

// 2. 第三方依赖
import express from "express";
import lodash from "lodash";

// 3. 项目内部模块
import { config } from "./config.js";
import { logger } from "./utils/logger.js";
```

<br>

## 使用命名导出优于默认导出

```javascript
// ✅ 推荐: 命名导出 (支持 tree-shaking, IDE 自动补全更友好)
export function add(a, b) {
    return a + b;
}
export function subtract(a, b) {
    return a - b;
}

// ⚠️ 慎用: 默认导出 (重命名随意, 可维护性较差)
export default function calculate() {
    /* ... */
}
```

<br>
