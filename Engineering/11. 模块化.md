# 为什么会诞生模块化

## 背景

JavaScript 最初被设计为一种轻量级脚本语言, 主要用于在网页中执行简单的交互任务. 在早期, JavaScript 程序通常只有几十行代码, 开发者通过 `<script>` 标签直接在 HTML 中引入脚本文件, 所有变量和函数都暴露在全局作用域中.

随着 Web 2.0 时代的到来和 AJAX 技术的广泛应用, 浏览器承载的功能越来越复杂, JavaScript 代码量急剧增长. 这种传统的开发方式暴露出严重的问题:

<br><br>

## 核心问题

### 1. 全局变量污染与命名冲突

所有变量和函数都定义在全局作用域中, 不同脚本之间容易发生命名冲突.

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
    <head>
        <script src="script1.js"></script>
        <script src="script2.js"></script>
    </head>
    <body>
        <script>
            console.log(getData());
        </script>
    </body>
</html>
```

```javascript
// script1.js
var data = "Script 1";
function getData() {
    return data;
}
console.log("script1.js loaded");
```

```javascript
// script2.js
var data = "Script 2"; // 覆盖了 script1.js 的 data
console.log("script2.js loaded");
```

上例会打印: `script1.js loaded` - `script2.js loaded` - `Script 2`.

<br>

### 2. 依赖关系混乱

多个脚本文件之间的依赖关系需要通过 `<script>` 标签的加载顺序手动管理, 容易出错且难以维护.

```html
<script src="jquery.js"></script>
<!-- jquery-plugin.js 依赖 jquery.js -->
<script src="jquery-plugin.js"></script>
<!-- app.js 依赖 jquery-plugin.js -->
<script src="app.js"></script>
```

<br><br>

## 模块化的演进历程

### 早期探索 (1999-2009)

开发者尝试使用 IIFE 和闭包来模拟模块化:

```javascript
// 使用 IIFE 创建独立作用域
var myModule = (function () {
    var privateVar = "I am private";

    return {
        publicMethod: function () {
            console.log(privateVar);
        },
    };
})();
```

这种方式虽然能避免全局污染, 但依然缺乏统一的依赖管理和加载机制.

<br>

### CommonJS 诞生 (2009)

2009 年, Mozilla 工程师 Kevin Dangoor 发起 CommonJS 提案 (最初名为 ServerJS), 为 JavaScript 定义了模块化规范. 同年, Ryan Dahl 创建了 Node, 并采用 CommonJS 作为其模块系统, 同时推出了 npm (全球最大的包管理器).

CommonJS 的核心特性: 同步加载.

<br>

### 浏览器端方案 (AMD/CMD)

由于 CommonJS 的同步加载机制在浏览器端会导致阻塞 (需要通过网络请求加载模块), 社区发展出异步加载方案:

-   **AMD** (Asynchronous Module Definition): 以 RequireJS 为代表, 支持异步加载
-   **CMD** (Common Module Definition): 以 Sea.js 为代表, 结合了 CommonJS 和 AMD 的特性

<br>

### 跨平台兼容方案 (UMD)

随着模块化方案的增多 (CommonJS, AMD, 全局变量), 库开发者面临兼容性问题: 如何让同一个库在不同环境下都能使用? UMD (Universal Module Definition) 应运而生.

UMD 的核心思想: 通过判断当前环境支持的模块规范, 动态选择导出方式:

```javascript
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD 环境
        define(["dependency"], factory);
    } else if (typeof module === "object" && module.exports) {
        // CommonJS 环境
        module.exports = factory(require("dependency"));
    } else {
        // 浏览器全局变量
        root.MyLibrary = factory(root.Dependency);
    }
})(typeof self !== "undefined" ? self : this, function (dependency) {
    // 库的实际代码
    return {
        doSomething: function () {
            /* ... */
        },
    };
});
```

UMD 让库能够同时在 Node, RequireJS 和浏览器全局变量中运行, 但代码冗长且维护成本高.

<br>

### ES Modules 统一标准 (2015)

2015 年 6 月, ECMAScript 2015 (ES6) 正式发布, JavaScript 首次在**语言标准层面**实现了模块功能, 成为官方的模块化解决方案.

ES Modules 的核心特性:

-   支持静态分析 (编译时确定依赖关系)
-   支持 Tree Shaking (移除未使用的代码)
-   同时支持浏览器和 Node 环境

<br><br>

## 当前状态

-   **ES Modules (ESM)** 已成为主流标准, 所有现代浏览器和 Node 均原生支持
-   **CommonJS (CJS)** 仍广泛用于 Node 生态, 尤其是遗留代码
-   **AMD/UMD** 逐渐被淘汰, 但 UMD 在跨平台库中仍有应用

<br><br><br>

# CommonJS

1. CommonJS 是社区标准

2. 仅支持 Node 环境

3. 使用函数实现

4. 仅支持动态依赖

5. 动态依赖是同步执行的

<br><br>

## 模块包装原理

```javascript
// require 函数的伪代码
function require(entry) {
    // 获取当前模块的路径
    var filename = getFilename(entry);

    // 获取当前模块所在目录的路径
    var path = getPath(filename);

    // 如果该模块有缓存, 则返回缓存结果
    if (require.cache[filename]) {
        return require.cache[filename];
    }

    // 创建模块对象
    require.main = {
        path, // 当前模块所在目录的路径
        exports: {},
        filename, // 当前模块的路径
        // ... 其他属性
    };

    // 创建模块包装函数
    function _run(exports, require, module, __filename, __dirname) {
        // 模块代码会放到这里
    }

    // 执行模块包装函数, 绑定 this 为 require.main.exports, 并传入参数
    _run.call(require.main.exports, require.main.exports, require, require.main, filename, path);

    // 把 require.main.exports 加入到缓存
    require.cache[filename] = require.main.exports;

    // 返回 require.main.exports
    return require.main.exports;
}
```

可以在 Node 环境执行代码, 查看 `arguments` 对象:

```js
// app.js
console.log(arguments);
```

```js
[Arguments] {
    '0': {}, // module.exports 的引用
    '1': [Function: require] {...}, // require 函数, 返回模块导出的数据
    '2': Module { // 当前模块对象 module
        path: 'e:\\Node\\code\\newDemo\\js', // 当前模块所在目录的路径
        exports: {}, // 模块导出的数据
        filename: 'e:\\Node\\code\\newDemo\\js\\operation.js', // 当前模块的路径
        // ...
    },
    '3': 'e:\\Node\\code\\newDemo\\js\\operation.js', // 当前模块的路径
    '4': 'e:\\Node\\code\\newDemo\\js' // 当前模块所在目录的路径
}
```

<br><br>

## 导出方式

### module.exports

1.  以 `module.exports = xxx` 的形式导出数据:

```javascript
// math.js
module.exports = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

导入时 会先执行一遍被导入的文件, 所以上例会打印 `math.js` - `num 10`.

<br>

2.  以 `module.exports.xxx = xxx` 的形式导出数据:

```javascript
// math.js
module.exports.num = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

上例会打印 `math.js` - `num { num: 10 }`.

<br>

### exports

1.  以 `exports.xxx = xxx` 的形式导出数据:

```javascript
// math.js
exports.num = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

上例会打印 `math.js` - `num { num: 10 }`.

<br>

提问: 能以 `exports = xxx` 的形式导出数据吗? 答案是: 不能.

讲解: 用于文件导出的属性是 `module.exports`. `exports` 是 `module.exports` 的引用 (相当于 `exports = module.exports`). 所以, 直接给 `exports` 赋值 (相当于 `exports = xxx`) 是修改不了 `module.exports` 的. 所以, 通过直接赋值导出的操作, 只能由 `module.exports` 完成, 不能使用 `exports`.

```javascript
// math.js
exports = 10;
console.log("math.js");
```

```javascript
// app.js
const num = require("./math");
console.log("num", num);
```

上例会打印 `math.js` - `num {}`.

可以看到 导入的是空对象 `{}`, 即 `module.exports` 的默认值.

<br>

## 导入方式

以 `require('模块标识')` 的形式导入数据, 会返回 [被导入模块所导出的数据], 即 [被导入模块的 `module.exports`].

<br>

模块分 3 类: 核心模块, 自定义模块, 第三方模块

1.  **核心模块**: Node 的内置模块, 模块标识是 `模块名`
2.  **自定义模块**: 用户自己创建的模块, 模块标识是 `文件路径`, 可以是绝对路径 / 相对路径
3.  **第三方模块**: 需要手动下载的模块; 模块标识是 `模块名`

<br>

`require` 根据 `模块标识` 的不同, 使用不同的查找策略:

1.  `模块名`: 如 `require('fs')`, `require('mysql')`
    1.  查看是否为内置模块. 如果是, 则直接从内存加载; 如果不是, 则往下走
    2.  到同级的 node_modules 目录中寻找 `'xxx'` 目录, 找不到则往上一级的 node_modules 目录找, 直至根目录.
    3.  在 `'xxx'` 目录下, 找到 package.json 中的 main 字段, 读取入口文件. 如果没有 package.json, 或者 main 字段 [入口不存在] / [无法解析], 则找该目录下的 index.js 文件
2.  `文件路径`: 如 `require('./cjs1')`
    1.  如果是文件, 可以不写文件后缀, Node 会按 `.js`, `.json`, `.node` 的顺序尝试补全
    2.  如果是目录, 找到 package.json 中的 main 字段, 读取入口文件. 如果没有 package.json, 或者 main 字段 [入口不存在] / [无法解析], 则找该目录下的 index.js 文件

<br>

## 模块特性

### 动态依赖

动态依赖, 即运行时才能确定依赖, 所以可以在任意位置导入/导出, 且可以配合变量使用:

```javascript
// 可以在任意位置调用
if (process.env.NODE_ENV === "development") {
    const devTools = require("./dev-tools.js");
    devTools.init();
}

// 可以配合变量使用
function loadModule(moduleName) {
    return require(`./modules/${moduleName}.js`);
}
```

<br>

### 动态依赖是同步执行的

因为是同步执行的, 所以会阻塞代码.

```javascript
// math.js
console.log("loading math.js...");
module.exports = {
    add: (a, b) => a + b,
};

// app.js
console.log("start");
const math = require("./math.js"); // 同步执行, 阻塞后续代码
console.log("loaded");
console.log(math.add(1, 2));

// 打印:
// start
// loading math.js...
// loaded
// 3
```

<br>

### 循环依赖

两个模块相互引用时, CommonJS 会返回当前已执行部分的导出对象, 避免无限循环.

```javascript
// a.js
console.log("a.js 开始执行");
exports.done = false;
const b = require("./b.js");
console.log("在 a.js 中, b.done =", b.done);
exports.done = true;
console.log("a.js 执行完毕");

// b.js
console.log("b.js 开始执行");
exports.done = false;
const a = require("./a.js"); // 此时 a.js 还未执行完, 返回部分导出 { done: false }
console.log("在 b.js 中, a.done =", a.done);
exports.done = true;
console.log("b.js 执行完毕");

// app.js
const a = require("./a.js");
console.log("a.done =", a.done);

// 打印:
// a.js 开始执行
// b.js 开始执行
// 在 b.js 中, a.done = false  <- 返回了 a.js 的部分导出
// b.js 执行完毕
// 在 a.js 中, b.done = true
// a.js 执行完毕
// a.done = true
```

<br>

### 缓存机制

-   模块在首次加载后会被缓存 (`require.cache`)
-   多次 `require` 同一模块只执行一次
-   可以通过 `delete require.cache[modulePath]` 清除缓存重新加载

```javascript
// 首次加载
const module1 = require("./module.js");

// 从缓存获取 (不会重新执行模块代码)
const module2 = require("./module.js");

console.log(module1 === module2); // true

// 清除缓存后重新加载
delete require.cache[require.resolve("./module.js")];
const module3 = require("./module.js");

console.log(module1 === module3); // false (新实例)
```

<br>

### this 指向

在 CommonJS 模块中, 顶层的 `this` 指向 `module.exports`.

模块加载时, `this`, `exports`, `module.exports` 三者指向同一个对象:

```javascript
// test.js
console.log(this === exports); // true
console.log(this === module.exports); // true
console.log(exports === module.exports); // true
```

**原因**: Node 的模块包装机制中, `this` 被绑定到 `module.exports`, 而 `exports` 是 `module.exports` 的引用.

<br>

当 `module.exports` 被重新赋值时, `this` 不再等于 `module.exports`:

```javascript
// test.js
module.exports = {
    add: (a, b) => a + b,
};

console.log(this === module.exports); // false (关系断开)
console.log(this === exports); // true (仍然相等)
console.log(exports === module.exports); // false (关系断开)
```

**原因**: 重新赋值 `module.exports` 创建了新对象, 但 `this` 和 `exports` 仍指向原始的空对象.

<br>

由于 `this` 指向 `module.exports`, 可以通过 `this` 添加导出:

```javascript
// math.js
this.add = (a, b) => a + b; // 等价于 module.exports.add = ...
this.subtract = (a, b) => a - b;

// app.js
const math = require("./math.js");
console.log(math.add(5, 3)); // 8
console.log(math.subtract(5, 3)); // 2
```

**但不推荐使用 `this` 导出**, 因为:

1. 可读性差, 不如 `module.exports` 或 `exports` 明确
2. `this` & `exports` 都是 `module.exports` 的引用, 它们的引用关系可能会断开

<br><br><br>

# ES Modules

1.  ES Modules 是 ECMAScript 官方标准 (ES6/ES2015 引入)

2.  同时支持浏览器环境和 Node 环境

3.  使用新语法实现

4.  同时支持静态依赖和动态依赖

5.  动态依赖是异步执行的

<br><br>

## 导出方式

### 命名导出 (Named Exports)

可以导出多个值:

```javascript
// 定义, 并导出
export const PI = 3.14159;
export function circle(radius) {
    return 2 * PI * radius;
}

// 先定义, 再导出
const PI = 3.14159;
function circle(radius) {
    return 2 * PI * radius;
}
export { PI, circle };

// 导出时重命名
export { PI as pi, circle as calculateCircle };
```

<br>

### 默认导出 (Default Export)

每个模块只能有一个默认导出:

```javascript
// 定义, 并导出
export default function square(x) {
    return x * x;
}

// 先定义, 再导出
function square(x) {
    return x * x;
}
export default square;
```

<br>

### 混合导出

可以同时使用命名导出和默认导出:

```javascript
export default function main() {
    console.log("Main function");
}

export const version = "1.0.0";
export const author = "John Doe";
```

<br><br>

## 导入方式

### 导入命名导出

```javascript
// 导入指定项
import { add, subtract } from "./math.js";

// 导入时重命名
import { add as sum } from "./math.js";

// 导入所有命名导出
import * as math from "./math.js";
console.log(math.add(1, 2));
```

<br>

### 导入默认导出

```javascript
// 默认导出可以用任意名称接收
import myFunction from "./module.js";
import MyClass from "./module.js";
```

<br>

### 导入混合导出

```javascript
import main, { version, author } from "./module.js";
```

<br>

### 仅执行模块

```javascript
// 仅执行模块代码, 不导入任何值
import "./init.js";
```

<br>

### 动态导入 (Dynamic Import)

运行时异步加载模块, 返回 Promise:

```javascript
// 条件加载
if (condition) {
    import("./module.js").then((module) => {
        module.doSomething();
    });
}

// 配合 async/await
async function loadModule() {
    const module = await import("./module.js");
    module.doSomething();
}
```

<br><br>

## 重导出 (Re-export)

用于聚合多个模块:

```javascript
// 重导出所有命名导出
export * from "./math.js";

// 重导出指定项
export { add, subtract } from "./math.js";

// 重导出时重命名
export { add as sum } from "./math.js";

// 重导出默认导出为命名导出
export { default as multiply } from "./math.js";
```

<br><br>

## 模块特性

### 模块作用域

模块有独立作用域, 顶层变量不会污染全局:

```javascript
// module.js
var name = "Module"; // 不会成为全局变量
```

<br>

### 严格模式

所有模块默认运行在严格模式 (`'use strict'`):

```javascript
// 自动启用严格模式
x = 10; // ReferenceError: x is not defined
```

<br>

### this 指向

因为默认开启严格模式, 所以模块顶层的 `this` 为 `undefined`:

```javascript
console.log(this); // undefined
```

<br>

### 模块提升 (Hoisting)

`import` 语句会被提升到模块顶部, 优先执行:

```javascript
// 这样写完全正常
foo();
import { foo } from "./module.js"; // import 会被提升
```

这是因为 `import` 在编译阶段执行, 而非运行阶段. 因此:

-   不能在条件语句或函数内使用
-   不能搭配表达式或变量使用

```javascript
// ❌ 错误: 不能在条件语句中使用
if (condition) {
    import { foo } from './module.js';
}

// ❌ 错误: 不能使用表达式
import { 'f' + 'oo' } from './module.js';

// ❌ 错误: 不能使用变量
const modulePath = './module.js';
import { foo } from modulePath;

// ✅ 正确: 使用动态导入
if (condition) {
    const module = await import('./module.js');
}
```

<br>

### 单例模式

模块只执行一次, 多次导入返回同一实例:

```javascript
// math.js
console.log("math.js");

// app.js
import "./math.js";
import "./math.js";
import "./math.js";

// 打印:
// math.js
```

<br>

### 命名导出的实时绑定

命名导出会创建对**变量的实时引用**, 可以跟踪重新赋值:

```javascript
// counter.js
export let count = 0;
export function increment() {
    count++; // 导出模块修改变量
}

// app.js
import { count, increment } from "./counter.js";
console.log(count); // 0
increment();
console.log(count); // 1 ✅ 实时更新

// count = 10; // ❌ TypeError: Assignment to constant variable
// 导入方无法重新赋值
```

能以 `export { value as default }` 的形式, 使默认导出也具备实时绑定:

```javascript
// module.js
let count = 0;
export { count as default }; // 导出的是变量 value 的实时引用
export function increment() {
    count++; // 修改会反映到导入方
}

// app.js
import count, { increment } from "./counter.js";
console.log(count); // 0
increment();
console.log(count); // 1 ✅ 实时更新
```

<br>

### import.meta

提供模块元信息:

```javascript
console.log(import.meta.url); // 当前模块的 URL
console.log(import.meta.resolve("./other.js")); // 解析模块路径
```

<br>

### Top-level await

支持在模块顶层使用 `await` (ES2022):

```javascript
// 顶层 await
const data = await fetch("/api/data").then((res) => res.json());
export { data };
```

<br>

### 循环依赖

ES Modules 通过 **静态分析 + 提前绑定 + 实时绑定** 处理循环依赖.

**核心机制:**

1. 在执行前先建立所有模块的依赖关系图
2. 在模块执行前创建导出的绑定 (bindings), 但不初始化值
3. 导入的是引用而非副本, 值可以在初始化后更新

**执行顺序:** 按 **深度优先, 左到右** 的顺序评估, 遇到循环依赖时返回未初始化的绑定.

<br>

**两种循环依赖类型:**

**1. 立即循环依赖 (Immediate/Static)** - 在模块顶层初始化时就访问被导入的值:

```javascript
// a.js
import { b } from "./b.js";
export const a = "aloha";
console.log("from a", b); // ❌ 在顶层访问 b

// b.js
import { a } from "./a.js";
export const b = "bye";
console.log("from b", a); // ❌ ReferenceError: Cannot access 'a' before initialization
```

执行流程: a.js 加载 → 遇到 `import { b }` → 跳转加载 b.js → b.js 遇到 `import { a }` → a.js 已在加载中, 返回未初始化的绑定 → b.js 执行 `console.log("from b", a)` → **a 仍在 TDZ (时间死区)** → 抛出错误.

<br>

**2. 延迟循环依赖 (Delayed)** - 仅在函数内部访问被导入的值:

```javascript
// even.js
import { isOdd } from "./odd.js";
export function isEven(n) {
    return n === 0 || isOdd(n - 1); // ✅ 函数体内访问
}

// odd.js
import { isEven } from "./even.js";
export function isOdd(n) {
    return n !== 0 && isEven(n - 1); // ✅ 函数体内访问
}

// app.js
import { isEven } from "./even.js";
console.log(isEven(4)); // true ✅ 正常工作
```

能正常工作的原因: 函数声明被提升, 在模块初始化时就创建了绑定; 函数体在 **模块初始化完成后** 才执行, 调用时所有模块已完全初始化.

<br><br>

## 浏览器中使用

### 基本用法

```html
<!-- type="module" 启用模块模式 -->
<script type="module">
    import { add } from "./math.js";
    console.log(add(1, 2));
</script>

<!-- 或加载外部模块 -->
<script type="module" src="./app.js"></script>
```

<br>

### 自动延迟执行 (Deferred)

模块脚本默认延迟执行 (等效于 `defer` 属性), 不会阻塞 HTML 解析:

```html
<script type="module">
    // 在 HTML 解析完成后执行
    console.log(document.querySelector("div")); // 可以访问 DOM
</script>
```

这使得模块脚本可以放在 `<head>` 中, 而无需等待 DOM 加载完成:

```html
<!DOCTYPE html>
<html>
    <head>
        <script type="module">
            // 即使在 head 中, 也能正常访问 body 中的元素
            console.log(document.querySelector("div"));
        </script>
    </head>
    <body>
        <div>Content</div>
    </body>
</html>
```

<br>

### CORS 限制

Classic scripts (传统脚本):

-   可以跨域加载, 不需要 CORS 协议 (浏览器不会阻止加载和执行)
-   但跨域脚本的错误信息会被限制 (出于安全考虑)

Module scripts (`type="module"`):

-   跨域加载必须遵循 CORS 协议
-   服务器必须返回正确的 `Access-Control-Allow-Origin` 等 CORS 响应头, 否则浏览器会阻止模块加载

```html
<!-- ✅ 同源模块: 无需 CORS -->
<script type="module" src="/js/app.js"></script>

<!-- ❌ 跨域模块: 必须有 CORS 响应头 -->
<script type="module" src="https://cdn.example.com/module.js"></script>
<!-- 服务器必须返回: Access-Control-Allow-Origin: * (或具体域名) -->
```

<br>

### 必须指定文件扩展名

浏览器中必须写完整路径和扩展名:

```javascript
import { add } from "./math.js"; // ✅ 正确
import { add } from "./math"; // ❌ 错误
```

<br>

### nomodule 兼容方案

为不支持模块的旧浏览器提供降级方案:

```html
<script type="module" src="modern.js"></script>
<script nomodule defer src="legacy.js"></script>
```

**工作原理:**

-   现代浏览器: 执行 `type="module"` 脚本, 忽略 `nomodule` 脚本
-   旧浏览器: 忽略 `type="module"` 脚本, 执行 `nomodule` 脚本

**注意事项:** **执行顺序**: 模块脚本默认延迟执行 (defer), 建议在 `nomodule` 脚本上也添加 `defer` 属性, 保证两者执行顺序一致

<br><br>

## Node 中使用

### 启用 ES Modules

方式一: 使用 .mjs 扩展名

```javascript
// math.mjs
export function add(a, b) {
    return a + b;
}
```

方式二: package.json 配置

```json
{
    "type": "module"
}
```

配置后, 所有 `.js` 文件都被视为 ES Modules. 若需使用 CommonJS, 使用 `.cjs` 扩展名.

<br>

### 特殊处理

1.  **filename 和 dirname 替代方案**: ES Modules 中没有 `__filename` 和 `__dirname`

```javascript
import { fileURLToPath } from "url";
import { dirname } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

2.  **导入 JSON 文件**: Node 20.10.0+ 支持导入断言

```javascript
import data from './data.json' with { type: 'json' };
```

3.  **导入内置模块**: 推荐使用 `node:` 前缀

```javascript
import fs from "node:fs";
import path from "node:path";
```

<br>

### 与 CommonJS 互操作

ESM 能以 "导入默认导出" 的形式导入 CJS 以 `module.exports == xxx` 的形式导出的数据:

```javascript
// cjs-module.cjs
module.exports = {
    name: "CommonJS",
    version: "1.0.0",
};
```

```javascript
// esm-module.mjs
import cjsModule from "./cjs-module.cjs"; // 导入整个 module.exports
console.log(cjsModule); // { name: 'CommonJS', version: '1.0.0' }
```

ESM 能以 "导入命名导出" 的形式导入 CJS 以 `exports.xxx = xxx` 的形式导出的数据:

```javascript
// cjs-module.cjs
module.exports.name = "CommonJS";
```

```javascript
// esm-module.mjs
import { name } from "./cjs-module.cjs";
console.log(name); // 'CommonJS'
```

<br>

CommonJS 无法直接使用 `require()` 同步导入 ES Modules, 需使用动态导入:

```javascript
// cjs-file.cjs
async function loadESM() {
    const esmModule = await import("./esm-module.mjs");
    console.log(esmModule.name); // 访问命名导出
    console.log(esmModule.default); // 访问默认导出
}

loadESM();
```

**Node 22.12.0+ 实验性功能:**

从 Node 22.12.0 开始, 可以使用 `--experimental-require-module` 标志允许 `require()` 同步加载不包含顶层 `await` 的 ESM 模块:

```javascript
// cjs-file.cjs
async function loadESM() {
    const esmModule = require("./esm-module.mjs"); // 实验性功能
    console.log(esmModule.name); // 访问命名导出
    console.log(esmModule.default); // 访问默认导出
}

loadESM();
```

```bash
node --experimental-require-module cjs-file.cjs
```

<br><br><br>

# 最佳实践

## 模块命名规范

```javascript
// ✅ 使用有意义的名称
import { UserService } from "./services/user.js";

// ❌ 避免模糊命名
import { getData } from "./utils.js";
```

<br>

## 单一职责原则

每个模块应有单一, 明确的职责:

```javascript
// ✅ 正确: 职责单一
// user-validator.js
export function validateUser(user) {
    /* ... */
}

// user-service.js
export function createUser(user) {
    /* ... */
}

// ❌ 错误: 职责混乱
// user.js
export function validateUser(user) {
    /* ... */
}
export function renderUserUI(user) {
    /* ... */
}
```

<br>

## 避免循环依赖

```javascript
// ❌ 循环依赖
// a.js
import { b } from "./b.js";
export const a = "A";

// b.js
import { a } from "./a.js";
export const b = "B";

// ✅ 解决方案: 提取共享依赖
// shared.js
export const shared = "Shared";

// a.js
import { shared } from "./shared.js";

// b.js
import { shared } from "./shared.js";
```

<br>

## 使用 barrel 文件聚合导出

```javascript
// components/index.js
export { Button } from "./Button.js";
export { Input } from "./Input.js";
export { Modal } from "./Modal.js";

// 使用时
import { Button, Input } from "./components/index.js";
```

<br>

## 合理使用动态导入

```javascript
// ✅ 条件加载
if (userPreference === "dark") {
    const theme = await import("./themes/dark.js");
    theme.apply();
}

// ✅ 路由懒加载 (React 示例)
const Home = lazy(() => import("./pages/Home.js"));
```

<br>

## 导入顺序规范

```javascript
// 1. 内置模块
import path from "node:path";
import fs from "node:fs";

// 2. 第三方依赖
import express from "express";
import lodash from "lodash";

// 3. 项目内部模块
import { config } from "./config.js";
import { logger } from "./utils/logger.js";
```

<br>

## 使用命名导出优于默认导出

```javascript
// ✅ 推荐: 命名导出 (支持 tree-shaking, IDE 自动补全更友好)
export function add(a, b) {
    return a + b;
}
export function subtract(a, b) {
    return a - b;
}

// ⚠️ 慎用: 默认导出 (重命名随意, 可维护性较差)
export default function calculate() {
    /* ... */
}
```

<br>
