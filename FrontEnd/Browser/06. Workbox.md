# Workbox

## 概念

Workbox 是由 Google Chrome 团队开发的开源 JavaScript 库集合, 用于简化 Service Worker 的编写和管理. 它封装了 Service Worker API 的复杂性, 提供了一套高级 API 和最佳实践, 让开发者能够轻松实现 PWA (Progressive Web App) 的核心功能: 离线支持, 缓存管理, 预缓存, 后台同步等.

**核心价值:**

-   **简化开发**: 将复杂的 Service Worker API 封装成易用的高级接口
-   **生产级方案**: Google 多年经验的最佳实践, 已在 YouTube, Google Photos 等产品中应用
-   **模块化设计**: 按需引入所需功能, 避免代码冗余
-   **构建工具集成**: 与 Webpack, Vite, Rollup 等主流构建工具无缝集成

<br>

## 为什么需要 Workbox

### 原生 Service Worker 的痛点

```javascript
// 手写 Service Worker 需要处理大量细节
self.addEventListener("install", (event) => {
    event.waitUntil(
        caches.open("v1").then((cache) => {
            // 需要手动列出所有文件及其版本
            return cache.addAll([
                "/index.html",
                "/styles.css?v=1.0",
                "/app.js?v=1.0",
                // ...数百个文件
            ]);
        })
    );
});

self.addEventListener("fetch", (event) => {
    // 需要手动实现各种缓存策略
    // 需要处理各种边界情况
    // 需要手动管理缓存更新
    // ...大量重复代码
});
```

### 使用 Workbox 的优势

```javascript
// 使用 Workbox, 简洁清晰
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { CacheFirst } from "workbox-strategies";

// 自动预缓存构建时生成的资源清单
precacheAndRoute(self.__WB_MANIFEST);

// 图片使用缓存优先策略
registerRoute(({ request }) => request.destination === "image", new CacheFirst({ cacheName: "images" }));
```

<br>

## 核心模块

Workbox 采用模块化设计, 主要包含以下核心模块:

### 1. workbox-routing (路由管理)

用于匹配请求 URL 并应用对应的处理策略.

```javascript
import { registerRoute } from "workbox-routing";
import { CacheFirst } from "workbox-strategies";

// 字符串匹配
registerRoute("/api/data", new CacheFirst());

// 正则匹配
registerRoute(/\.(?:png|jpg|jpeg|svg|gif)$/, new CacheFirst());

// 函数匹配
registerRoute(({ request, url }) => {
    return request.destination === "script" || url.pathname.endsWith(".js");
}, new CacheFirst());
```

### 2. workbox-strategies (缓存策略)

提供 5 种常用的缓存策略.

#### CacheFirst (缓存优先)

```javascript
import { CacheFirst } from "workbox-strategies";
import { registerRoute } from "workbox-routing";

registerRoute(
    ({ request }) => request.destination === "style",
    new CacheFirst({
        cacheName: "css-cache",
        plugins: [
            // 可添加插件
        ],
    })
);
```

**流程:** 缓存 → 网络  
**适用:** CSS, JS, 图片等静态资源

#### NetworkFirst (网络优先)

```javascript
import { NetworkFirst } from "workbox-strategies";

registerRoute(
    ({ url }) => url.pathname.startsWith("/api/"),
    new NetworkFirst({
        cacheName: "api-cache",
        networkTimeoutSeconds: 3, // 3 秒超时则使用缓存
        plugins: [
            // 插件配置
        ],
    })
);
```

**流程:** 网络 → 缓存  
**适用:** API 请求, HTML 页面

#### CacheOnly (仅缓存)

```javascript
import { CacheOnly } from "workbox-strategies";

registerRoute(
    "/offline.html",
    new CacheOnly({
        cacheName: "offline-cache",
    })
);
```

**流程:** 仅缓存  
**适用:** 离线页面, 必须预缓存的资源

#### NetworkOnly (仅网络)

```javascript
import { NetworkOnly } from "workbox-strategies";

registerRoute(({ url }) => url.pathname.startsWith("/admin/"), new NetworkOnly());
```

**流程:** 仅网络  
**适用:** 实时数据, 敏感信息

#### StaleWhileRevalidate (缓存同时更新)

```javascript
import { StaleWhileRevalidate } from "workbox-strategies";

registerRoute(
    ({ request }) => request.destination === "script",
    new StaleWhileRevalidate({
        cacheName: "js-cache",
    })
);
```

**流程:** 返回缓存, 同时请求网络更新缓存  
**适用:** 需要快速响应但也要保持更新的资源

### 3. workbox-precaching (预缓存)

在 Service Worker 安装时预先缓存关键资源.

```javascript
import { precacheAndRoute } from "workbox-precaching";

// __WB_MANIFEST 会在构建时被替换为资源清单
precacheAndRoute(self.__WB_MANIFEST);

// 或手动指定
precacheAndRoute([
    { url: "/index.html", revision: "1.0.0" },
    { url: "/styles.css", revision: "2.1.3" },
    { url: "/app.js", revision: "1.5.2" },
]);
```

**特点:**

-   自动生成资源版本号 (基于文件内容 hash)
-   安装时下载所有资源
-   更新时只下载变化的文件
-   自动清理旧版本缓存

### 4. workbox-expiration (缓存过期)

管理缓存的数量和时效性.

```javascript
import { ExpirationPlugin } from "workbox-expiration";
import { CacheFirst } from "workbox-strategies";
import { registerRoute } from "workbox-routing";

registerRoute(
    ({ request }) => request.destination === "image",
    new CacheFirst({
        cacheName: "images",
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50, // 最多缓存 50 张图片
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 天过期
                purgeOnQuotaError: true, // 存储空间不足时自动清理
            }),
        ],
    })
);
```

### 5. workbox-background-sync (后台同步)

在网络恢复时重新发送失败的请求.

```javascript
import { BackgroundSyncPlugin } from "workbox-background-sync";
import { NetworkOnly } from "workbox-strategies";
import { registerRoute } from "workbox-routing";

const bgSyncPlugin = new BackgroundSyncPlugin("api-queue", {
    maxRetentionTime: 24 * 60, // 重试 24 小时
});

registerRoute(
    ({ url }) => url.pathname.startsWith("/api/"),
    new NetworkOnly({
        plugins: [bgSyncPlugin],
    }),
    "POST" // 只对 POST 请求生效
);
```

**场景:** 用户提交表单时网络断开, 等网络恢复后自动重发

### 6. workbox-cacheable-response (可缓存响应)

控制哪些响应可以被缓存.

```javascript
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { NetworkFirst } from "workbox-strategies";

registerRoute(
    ({ url }) => url.pathname.startsWith("/api/"),
    new NetworkFirst({
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200], // 只缓存状态码为 0 或 200 的响应
                headers: {
                    "X-Is-Cacheable": "true", // 必须包含此响应头
                },
            }),
        ],
    })
);
```

### 7. workbox-range-requests (范围请求)

支持 HTTP Range 请求 (用于音视频的分段加载).

```javascript
import { RangeRequestsPlugin } from "workbox-range-requests";
import { CacheFirst } from "workbox-strategies";

registerRoute(
    ({ request }) => request.destination === "video",
    new CacheFirst({
        plugins: [new RangeRequestsPlugin()],
    })
);
```

<br>

## 使用方式

Workbox 提供三种使用方式, 适应不同的项目需求:

### 方式一: CDN 引入 (快速开始)

适合小型项目或快速原型.

```javascript
// sw.js
importScripts("https://storage.googleapis.com/workbox-cdn/releases/7.0.0/workbox-sw.js");

if (workbox) {
    console.log("Workbox 加载成功");

    // 预缓存
    workbox.precaching.precacheAndRoute([
        { url: "/index.html", revision: "1.0" },
        { url: "/styles.css", revision: "1.0" },
    ]);

    // 图片缓存优先
    workbox.routing.registerRoute(
        ({ request }) => request.destination === "image",
        new workbox.strategies.CacheFirst({
            cacheName: "images",
            plugins: [
                new workbox.expiration.ExpirationPlugin({
                    maxEntries: 60,
                    maxAgeSeconds: 30 * 24 * 60 * 60,
                }),
            ],
        })
    );

    // API 网络优先
    workbox.routing.registerRoute(
        ({ url }) => url.pathname.startsWith("/api/"),
        new workbox.strategies.NetworkFirst({
            cacheName: "api",
        })
    );
} else {
    console.log("Workbox 加载失败");
}
```

**优点:** 简单快速, 无需构建  
**缺点:** 需要网络加载 Workbox, 无法使用构建时特性

### 方式二: npm 包 + 手写 Service Worker

适合需要精细控制的项目.

**1. 安装依赖**

```bash
npm install workbox-routing workbox-strategies workbox-precaching
```

**2. 编写 Service Worker**

```javascript
// sw.js
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";
import { CacheableResponsePlugin } from "workbox-cacheable-response";

// 预缓存 (构建工具会自动注入资源清单)
precacheAndRoute(self.__WB_MANIFEST);

// 静态资源: 缓存优先
registerRoute(
    ({ request }) => ["style", "script", "font"].includes(request.destination),
    new CacheFirst({
        cacheName: "static-resources",
        plugins: [
            new CacheableResponsePlugin({ statuses: [0, 200] }),
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
            }),
        ],
    })
);

// 图片: 缓存同时更新
registerRoute(
    ({ request }) => request.destination === "image",
    new StaleWhileRevalidate({
        cacheName: "images",
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 天
            }),
        ],
    })
);

// API: 网络优先
registerRoute(
    ({ url }) => url.pathname.startsWith("/api/"),
    new NetworkFirst({
        cacheName: "api-cache",
        networkTimeoutSeconds: 5,
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
        ],
    })
);

// 跨域请求: 网络优先
registerRoute(
    ({ url }) => url.origin !== self.location.origin,
    new NetworkFirst({
        cacheName: "cross-origin",
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
        ],
    })
);
```

**3. 注册 Service Worker**

```javascript
// main.js
if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
        navigator.serviceWorker.register("/sw.js");
    });
}
```

### 方式三: Webpack/Vite 插件 (推荐)

适合现代前端项目, 自动生成 Service Worker.

#### Vite + vite-plugin-pwa

**1. 安装插件**

```bash
npm install -D vite-plugin-pwa
```

**2. 配置 vite.config.js**

```javascript
import { defineConfig } from "vite";
import { VitePWA } from "vite-plugin-pwa";

export default defineConfig({
    plugins: [
        VitePWA({
            registerType: "autoUpdate", // 自动更新
            includeAssets: ["favicon.ico", "robots.txt", "apple-touch-icon.png"],

            manifest: {
                name: "My App",
                short_name: "App",
                description: "My awesome app",
                theme_color: "#ffffff",
                icons: [
                    {
                        src: "pwa-192x192.png",
                        sizes: "192x192",
                        type: "image/png",
                    },
                    {
                        src: "pwa-512x512.png",
                        sizes: "512x512",
                        type: "image/png",
                    },
                ],
            },

            workbox: {
                // Workbox 配置
                globPatterns: ["**/*.{js,css,html,ico,png,svg}"], // 需要预缓存的文件

                runtimeCaching: [
                    // 图片缓存
                    {
                        urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
                        handler: "CacheFirst",
                        options: {
                            cacheName: "images",
                            expiration: {
                                maxEntries: 50,
                                maxAgeSeconds: 30 * 24 * 60 * 60,
                            },
                        },
                    },

                    // API 缓存
                    {
                        urlPattern: /^https:\/\/api\.example\.com\/.*/,
                        handler: "NetworkFirst",
                        options: {
                            cacheName: "api",
                            networkTimeoutSeconds: 5,
                            expiration: {
                                maxEntries: 100,
                                maxAgeSeconds: 24 * 60 * 60,
                            },
                            cacheableResponse: {
                                statuses: [0, 200],
                            },
                        },
                    },

                    // 字体缓存
                    {
                        urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/,
                        handler: "StaleWhileRevalidate",
                        options: {
                            cacheName: "google-fonts",
                        },
                    },
                ],
            },
        }),
    ],
});
```

**3. 在应用中使用**

```javascript
// main.js
import { registerSW } from "virtual:pwa-register";

// 自动更新
const updateSW = registerSW({
    onNeedRefresh() {
        // 有新版本时的回调
        if (confirm("发现新版本, 是否立即更新?")) {
            updateSW(true);
        }
    },
    onOfflineReady() {
        console.log("应用已可离线使用");
    },
});
```

#### Webpack + workbox-webpack-plugin

**1. 安装插件**

```bash
npm install -D workbox-webpack-plugin
```

**2. 配置 webpack.config.js**

```javascript
const { GenerateSW } = require("workbox-webpack-plugin");

module.exports = {
    // ... 其他配置

    plugins: [
        new GenerateSW({
            clientsClaim: true, // 立即接管页面
            skipWaiting: true, // 跳过等待

            // 预缓存
            include: [/\.html$/, /\.js$/, /\.css$/],
            exclude: [/\.map$/, /^manifest.*\.js$/],

            // 运行时缓存
            runtimeCaching: [
                {
                    urlPattern: /\.(?:png|jpg|jpeg|svg)$/,
                    handler: "CacheFirst",
                    options: {
                        cacheName: "images",
                        expiration: {
                            maxEntries: 60,
                            maxAgeSeconds: 30 * 24 * 60 * 60,
                        },
                    },
                },
                {
                    urlPattern: /^https:\/\/api\.example\.com\/.*/,
                    handler: "NetworkFirst",
                    options: {
                        cacheName: "api",
                        networkTimeoutSeconds: 3,
                    },
                },
            ],
        }),
    ],
};
```

<br>

## 完整实战案例

### 场景: 博客网站 PWA 改造

**需求:**

-   离线访问文章
-   快速加载图片
-   API 数据网络优先
-   自动更新

**1. 项目结构**

```
project/
├── src/
│   ├── main.js
│   ├── App.vue
│   └── ...
├── public/
│   ├── manifest.json
│   └── offline.html
├── vite.config.js
└── package.json
```

**2. 安装依赖**

```bash
npm install -D vite-plugin-pwa
```

**3. 配置 vite.config.js**

```javascript
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import { VitePWA } from "vite-plugin-pwa";

export default defineConfig({
    plugins: [
        vue(),
        VitePWA({
            registerType: "autoUpdate",

            // PWA 配置清单
            manifest: {
                name: "My Blog",
                short_name: "Blog",
                description: "A beautiful blog powered by PWA",
                theme_color: "#42b983",
                background_color: "#ffffff",
                display: "standalone",
                start_url: "/",
                icons: [
                    {
                        src: "/icon-192.png",
                        sizes: "192x192",
                        type: "image/png",
                    },
                    {
                        src: "/icon-512.png",
                        sizes: "512x512",
                        type: "image/png",
                        purpose: "any maskable",
                    },
                ],
            },

            // Workbox 配置
            workbox: {
                // 预缓存文件
                globPatterns: ["**/*.{js,css,html,ico,png,svg,woff2}"],

                // 运行时缓存
                runtimeCaching: [
                    // 文章页面: 网络优先, 5 秒超时
                    {
                        urlPattern: /^https:\/\/blog\.example\.com\/posts\/.*/,
                        handler: "NetworkFirst",
                        options: {
                            cacheName: "posts",
                            networkTimeoutSeconds: 5,
                            expiration: {
                                maxEntries: 50,
                                maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
                            },
                            cacheableResponse: {
                                statuses: [0, 200],
                            },
                        },
                    },

                    // 图片: 缓存同时更新
                    {
                        urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
                        handler: "StaleWhileRevalidate",
                        options: {
                            cacheName: "images",
                            expiration: {
                                maxEntries: 100,
                                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 天
                            },
                        },
                    },

                    // CDN 资源: 缓存优先
                    {
                        urlPattern: /^https:\/\/cdn\.jsdelivr\.net\/.*/,
                        handler: "CacheFirst",
                        options: {
                            cacheName: "cdn",
                            expiration: {
                                maxEntries: 50,
                                maxAgeSeconds: 365 * 24 * 60 * 60, // 1 年
                            },
                            cacheableResponse: {
                                statuses: [0, 200],
                            },
                        },
                    },

                    // API: 网络优先
                    {
                        urlPattern: /^https:\/\/api\.example\.com\/.*/,
                        handler: "NetworkFirst",
                        options: {
                            cacheName: "api",
                            networkTimeoutSeconds: 3,
                            expiration: {
                                maxEntries: 100,
                                maxAgeSeconds: 24 * 60 * 60, // 1 天
                            },
                            cacheableResponse: {
                                statuses: [0, 200],
                            },
                        },
                    },
                ],

                // 导航回退 (离线时显示)
                navigateFallback: "/offline.html",
                navigateFallbackDenylist: [/^\/api\//], // API 请求不使用回退
            },

            // 开发选项
            devOptions: {
                enabled: false, // 开发环境不启用
                type: "module",
            },
        }),
    ],
});
```

**4. 在应用中注册**

```javascript
// main.js
import { createApp } from "vue";
import App from "./App.vue";
import { registerSW } from "virtual:pwa-register";

const app = createApp(App);

// 注册 Service Worker
const updateSW = registerSW({
    immediate: true,

    onNeedRefresh() {
        // 显示更新提示
        const result = confirm("发现新版本, 是否立即更新? (将刷新页面)");
        if (result) {
            updateSW(true); // 更新并刷新
        }
    },

    onOfflineReady() {
        console.log("应用已可离线访问");
        // 可以显示一个提示
    },

    onRegistered(registration) {
        console.log("Service Worker 注册成功");

        // 每小时检查一次更新
        setInterval(() => {
            registration.update();
        }, 60 * 60 * 1000);
    },

    onRegisterError(error) {
        console.error("Service Worker 注册失败:", error);
    },
});

app.mount("#app");
```

**5. 创建离线页面**

```html
<!-- public/offline.html -->
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>离线模式</title>
        <style>
            body {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100vh;
                margin: 0;
                font-family: system-ui, -apple-system, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }
            .container {
                text-align: center;
                padding: 2rem;
            }
            h1 {
                font-size: 3rem;
                margin: 0 0 1rem;
            }
            p {
                font-size: 1.2rem;
                opacity: 0.9;
            }
            button {
                margin-top: 2rem;
                padding: 1rem 2rem;
                font-size: 1rem;
                background: white;
                color: #667eea;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: transform 0.2s;
            }
            button:hover {
                transform: scale(1.05);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>📡</h1>
            <h1>网络连接已断开</h1>
            <p>请检查您的网络连接后重试</p>
            <button onclick="location.reload()">重新加载</button>
        </div>
    </body>
</html>
```

**6. 构建并测试**

```bash
# 构建生产版本
npm run build

# 预览 (测试 Service Worker)
npm run preview
```

**测试步骤:**

1. 访问网站, 等待 Service Worker 注册
2. 打开 DevTools → Application → Service Workers, 确认已激活
3. 勾选 "Offline" 模拟离线环境
4. 刷新页面, 应该能正常访问
5. 访问未缓存的页面, 应该显示离线页面

<br>

## 高级特性

### 1. 自定义插件

```javascript
import { registerRoute } from "workbox-routing";
import { NetworkFirst } from "workbox-strategies";

// 自定义插件: 添加自定义响应头
class CustomHeaderPlugin {
    requestWillFetch({ request }) {
        const headers = new Headers(request.headers);
        headers.set("X-Custom-Header", "Workbox");

        return new Request(request, { headers });
    }

    cachedResponseWillBeUsed({ cachedResponse }) {
        if (cachedResponse) {
            console.log("使用缓存响应");
        }
        return cachedResponse;
    }
}

registerRoute(
    ({ url }) => url.pathname.startsWith("/api/"),
    new NetworkFirst({
        plugins: [new CustomHeaderPlugin()],
    })
);
```

### 2. 消息通信

**Service Worker 向页面发送消息:**

```javascript
// sw.js
import { clientsClaim } from "workbox-core";

self.addEventListener("activate", (event) => {
    event.waitUntil(
        (async () => {
            clientsClaim();

            // 通知所有客户端
            const clients = await self.clients.matchAll();
            clients.forEach((client) => {
                client.postMessage({
                    type: "CACHE_UPDATED",
                    message: "缓存已更新",
                });
            });
        })()
    );
});
```

**页面接收消息:**

```javascript
// main.js
navigator.serviceWorker.addEventListener("message", (event) => {
    if (event.data.type === "CACHE_UPDATED") {
        console.log(event.data.message);
        // 显示提示或更新 UI
    }
});
```

**页面向 Service Worker 发送消息:**

```javascript
// main.js
navigator.serviceWorker.ready.then((registration) => {
    registration.active.postMessage({
        type: "CLEAR_CACHE",
        cacheName: "images",
    });
});

// sw.js
self.addEventListener("message", (event) => {
    if (event.data.type === "CLEAR_CACHE") {
        caches.delete(event.data.cacheName);
    }
});
```

### 3. 预加载导航请求

```javascript
import { NavigationRoute, registerRoute } from "workbox-routing";
import { NetworkFirst } from "workbox-strategies";

// 对导航请求使用特殊处理
const navigationRoute = new NavigationRoute(
    new NetworkFirst({
        cacheName: "navigations",
        networkTimeoutSeconds: 3,
    }),
    {
        // 排除某些路径
        denylist: [/^\/admin/, /^\/api/],
    }
);

registerRoute(navigationRoute);
```

### 4. 条件缓存

```javascript
import { registerRoute } from "workbox-routing";
import { NetworkFirst } from "workbox-strategies";

registerRoute(({ request, url }) => {
    // 只缓存 GET 请求
    if (request.method !== "GET") {
        return false;
    }

    // 只缓存同源请求
    if (url.origin !== self.location.origin) {
        return false;
    }

    // 排除某些路径
    if (url.pathname.startsWith("/admin")) {
        return false;
    }

    return true;
}, new NetworkFirst());
```

<br>

## 调试技巧

### 1. 开启调试日志

```javascript
// sw.js
import { setLogLevel } from "workbox-core";

// 开发环境开启详细日志
if (process.env.NODE_ENV === "development") {
    setLogLevel("debug");
} else {
    setLogLevel("warn");
}
```

### 2. Chrome DevTools

**Application → Service Workers:**

-   查看 Service Worker 状态
-   手动更新
-   注销 Service Worker
-   模拟离线环境

**Application → Cache Storage:**

-   查看所有缓存内容
-   手动删除缓存
-   检查预缓存清单

**Network 面板:**

-   筛选 "Service Worker" 查看被拦截的请求
-   查看资源来源 (from ServiceWorker)

### 3. 常用调试代码

```javascript
// 查看所有缓存
caches.keys().then(console.log);

// 查看指定缓存的内容
caches.open("images").then((cache) => {
    cache.keys().then(console.log);
});

// 手动清除所有缓存
caches.keys().then((keys) => {
    keys.forEach((key) => caches.delete(key));
});

// 获取当前 Service Worker
navigator.serviceWorker.getRegistration().then(console.log);

// 手动触发更新
navigator.serviceWorker.getRegistration().then((reg) => {
    reg.update();
});
```

<br>

## 性能优化

### 1. 按需预缓存

```javascript
// 只预缓存核心资源
import { precacheAndRoute } from "workbox-precaching";

const criticalAssets = self.__WB_MANIFEST.filter((asset) => {
    // 只预缓存 HTML, CSS 和核心 JS
    return /\.(html|css)$/.test(asset.url) || asset.url.includes("main.js") || asset.url.includes("vendor.js");
});

precacheAndRoute(criticalAssets);
```

### 2. 分级缓存策略

```javascript
// 不同资源使用不同的缓存时长
import { ExpirationPlugin } from "workbox-expiration";

// 长期缓存: 不变的资源 (带 hash 的文件)
registerRoute(
    /\.[\da-f]{8}\.(js|css)$/,
    new CacheFirst({
        cacheName: "immutable",
        plugins: [
            new ExpirationPlugin({
                maxAgeSeconds: 365 * 24 * 60 * 60, // 1 年
            }),
        ],
    })
);

// 短期缓存: 可能变化的资源
registerRoute(
    /\.(?:png|jpg)$/,
    new StaleWhileRevalidate({
        cacheName: "images",
        plugins: [
            new ExpirationPlugin({
                maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
                maxEntries: 50,
            }),
        ],
    })
);
```

### 3. 智能更新检测

```javascript
// main.js
import { registerSW } from "virtual:pwa-register";

const updateSW = registerSW({
    onRegistered(registration) {
        // 非活跃时才检查更新 (避免影响用户体验)
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "hidden") {
                registration.update();
            }
        });

        // 每 6 小时检查一次
        setInterval(() => {
            registration.update();
        }, 6 * 60 * 60 * 1000);
    },
});
```

<br>

## 常见问题

### 1. 预缓存文件过多导致安装缓慢

**问题:** 预缓存了几百个文件, Service Worker 安装需要很长时间

**解决方案:**

```javascript
// 只预缓存核心资源
workbox: {
    globPatterns: [
        '**/*.{html,css}',
        '**/main.*.js',
        '**/vendor.*.js',
    ],
    // 其他资源使用运行时缓存
}
```

### 2. Service Worker 更新不及时

**问题:** 修改了代码但用户看不到最新版本

**解决方案:**

```javascript
// 配置 Service Worker 文件不缓存
// vite.config.js
workbox: {
    clientsClaim: true,
    skipWaiting: true,
}

// 服务器响应头
// Cache-Control: no-cache (针对 sw.js)
```

### 3. 开发环境受缓存影响

**问题:** 开发时缓存导致无法看到最新修改

**解决方案:**

```javascript
// vite.config.js
VitePWA({
    devOptions: {
        enabled: false, // 开发环境禁用
    },
});

// 或在 DevTools 中勾选 "Bypass for network"
```

### 4. 缓存占用空间过大

**问题:** 缓存文件越来越多, 占用大量存储空间

**解决方案:**

```javascript
import { ExpirationPlugin } from "workbox-expiration";

new ExpirationPlugin({
    maxEntries: 50, // 限制数量
    maxAgeSeconds: 30 * 24 * 60 * 60, // 限制时间
    purgeOnQuotaError: true, // 空间不足时自动清理
});
```

<br>

## 最佳实践

1. **渐进增强**: 确保不支持 Service Worker 的浏览器也能正常使用
2. **合理预缓存**: 只预缓存必要的核心资源, 其他资源使用运行时缓存
3. **版本控制**: 使用文件 hash 确保缓存失效机制正确
4. **及时更新**: 定期检查更新, 但避免影响用户体验
5. **错误处理**: 为所有策略添加回退方案
6. **性能监控**: 记录缓存命中率, 持续优化
7. **用户提示**: 有新版本时友好地提示用户
8. **测试覆盖**: 测试离线场景, 网络不稳定场景

<br>

## 与原生 Service Worker 对比

| 特性     | 原生 Service Worker    | Workbox                |
| -------- | ---------------------- | ---------------------- |
| 学习曲线 | 陡峭, 需要理解底层 API | 平缓, 高级 API 易用    |
| 代码量   | 大量样板代码           | 简洁清晰               |
| 预缓存   | 手动管理文件清单       | 自动生成, 自动版本控制 |
| 缓存策略 | 手动实现               | 开箱即用的 5 种策略    |
| 插件系统 | 无                     | 丰富的插件生态         |
| 构建集成 | 需自行处理             | 与主流构建工具无缝集成 |
| 调试     | 复杂                   | 内置日志和调试工具     |
| 维护性   | 难以维护               | 结构清晰, 易于维护     |

<br>

## 浏览器兼容性

Workbox 支持所有支持 Service Worker 的浏览器:

-   Chrome 40+
-   Firefox 44+
-   Safari 11.1+
-   Edge 17+
-   Opera 27+

**注意:** 部分高级特性 (如 Background Sync) 的支持情况可能不同

<br>

## 参考资料

-   [Workbox 官方文档](https://developer.chrome.com/docs/workbox)
-   [vite-plugin-pwa 文档](https://vite-pwa-org.netlify.app/)
-   [PWA 最佳实践](https://web.dev/progressive-web-apps/)
-   [Service Worker Cookbook](https://serviceworke.rs/)
