# Service Worker

## 概念

Service Worker 是一种运行在浏览器后台的 JavaScript 脚本, 充当 Web 应用程序与网络之间的代理层. 它独立于网页运行, 为 Web 应用提供了类似原生应用的离线体验, 推送通知, 后台同步等能力.

<br>

## 核心特性

1. **独立于主线程**: Service Worker 运行在独立的 Worker 线程中, 不会阻塞主线程, 也无法直接访问 DOM
2. **事件驱动**: 基于事件驱动模型, 不使用时会被终止, 需要时会被唤醒
3. **生命周期管理**: 拥有完整的生命周期, 独立于网页存在
4. **网络代理**: 可以拦截和处理页面发出的所有网络请求
5. **HTTPS 要求**: 出于安全考虑, 必须在 HTTPS 环境下运行 (localhost 除外)
6. **作用域控制**: 只能控制其作用域内的页面请求

<br>

## 生命周期

Service Worker 具有完整的生命周期, 主要包含以下阶段:

### 1. 注册 (Register)

在主线程中注册 Service Worker 脚本:

```javascript
if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
        navigator.serviceWorker
            .register("/sw.js", {
                scope: "/", // 控制范围, 默认为 sw.js 所在目录
            })
            .then((registration) => {
                console.log("SW 注册成功:", registration);
            })
            .catch((error) => {
                console.log("SW 注册失败:", error);
            });
    });
}
```

### 2. 安装 (Install)

Service Worker 首次注册时会触发 `install` 事件, 通常用于缓存静态资源:

```javascript
const CACHE_NAME = "v1";
const urlsToCache = ["/", "/styles/main.css", "/script/main.js", "/images/logo.png"];

self.addEventListener("install", (event) => {
    console.log("SW 正在安装...");

    event.waitUntil(
        caches
            .open(CACHE_NAME)
            .then((cache) => {
                console.log("打开缓存");
                return cache.addAll(urlsToCache);
            })
            .then(() => {
                // 强制跳过等待, 立即激活
                return self.skipWaiting();
            })
    );
});
```

**关键点:**

-   `event.waitUntil()` 接收一个 Promise, 确保 Service Worker 不会在 Promise 完成前被终止
-   `self.skipWaiting()` 强制新的 Service Worker 跳过等待阶段, 立即激活

### 3. 激活 (Activate)

安装成功后进入激活阶段, 通常用于清理旧缓存:

```javascript
self.addEventListener("activate", (event) => {
    console.log("SW 正在激活...");

    const cacheWhitelist = [CACHE_NAME];

    event.waitUntil(
        caches
            .keys()
            .then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        // 删除不在白名单中的缓存
                        if (!cacheWhitelist.includes(cacheName)) {
                            console.log("删除旧缓存:", cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
            .then(() => {
                // 立即控制所有页面
                return self.clients.claim();
            })
    );
});
```

**关键点:**

-   `self.clients.claim()` 让新激活的 Service Worker 立即接管所有页面

### 4. 运行 (Fetch)

激活后, Service Worker 可以拦截页面的所有网络请求:

```javascript
self.addEventListener("fetch", (event) => {
    event.respondWith(
        caches.match(event.request).then((response) => {
            // 缓存命中则返回缓存, 否则发起网络请求
            return response || fetch(event.request);
        })
    );
});
```

<br>

## 缓存策略

Service Worker 最重要的应用场景是实现资源缓存, 常见的缓存策略包括:

### 1. Cache First (缓存优先)

优先使用缓存, 缓存不存在才请求网络:

```javascript
self.addEventListener("fetch", (event) => {
    event.respondWith(
        caches.match(event.request).then((response) => {
            return response || fetch(event.request);
        })
    );
});
```

**适用场景:** 静态资源 (CSS, JS, 图片)

### 2. Network First (网络优先)

优先请求网络, 网络失败才使用缓存:

```javascript
self.addEventListener("fetch", (event) => {
    event.respondWith(
        fetch(event.request)
            .then((response) => {
                // 请求成功, 更新缓存
                return caches.open(CACHE_NAME).then((cache) => {
                    cache.put(event.request, response.clone());
                    return response;
                });
            })
            .catch(() => {
                // 网络失败, 返回缓存
                return caches.match(event.request);
            })
    );
});
```

**适用场景:** API 请求, 动态内容

### 3. Cache Only (仅缓存)

只使用缓存, 不请求网络:

```javascript
self.addEventListener("fetch", (event) => {
    event.respondWith(caches.match(event.request));
});
```

**适用场景:** 离线应用的核心资源

### 4. Network Only (仅网络)

只请求网络, 不使用缓存:

```javascript
self.addEventListener("fetch", (event) => {
    event.respondWith(fetch(event.request));
});
```

**适用场景:** 实时数据, 不可缓存的请求

### 5. Stale While Revalidate (缓存同时更新)

先返回缓存, 同时发起网络请求更新缓存:

```javascript
self.addEventListener("fetch", (event) => {
    event.respondWith(
        caches.match(event.request).then((cachedResponse) => {
            const fetchPromise = fetch(event.request).then((networkResponse) => {
                caches.open(CACHE_NAME).then((cache) => {
                    cache.put(event.request, networkResponse.clone());
                });
                return networkResponse;
            });

            // 返回缓存 (如果有), 否则返回网络请求
            return cachedResponse || fetchPromise;
        })
    );
});
```

**适用场景:** 需要快速响应但也需要及时更新的资源

<br>

## 实战示例

### 完整的 Service Worker 实现

```javascript
// sw.js
const CACHE_NAME = "my-app-v1";
const RUNTIME_CACHE = "runtime-cache";

// 需要预缓存的静态资源
const STATIC_ASSETS = ["/", "/index.html", "/styles/main.css", "/scripts/app.js", "/images/logo.png", "/offline.html"];

// 安装阶段: 预缓存静态资源
self.addEventListener("install", (event) => {
    event.waitUntil(
        caches
            .open(CACHE_NAME)
            .then((cache) => cache.addAll(STATIC_ASSETS))
            .then(() => self.skipWaiting())
    );
});

// 激活阶段: 清理旧缓存
self.addEventListener("activate", (event) => {
    event.waitUntil(
        caches
            .keys()
            .then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
            .then(() => self.clients.claim())
    );
});

// 拦截请求
self.addEventListener("fetch", (event) => {
    const { request } = event;
    const url = new URL(request.url);

    // 同源请求采用缓存优先策略
    if (url.origin === location.origin) {
        event.respondWith(cacheFirst(request));
    } else {
        // 跨域请求采用网络优先策略
        event.respondWith(networkFirst(request));
    }
});

// 缓存优先策略
async function cacheFirst(request) {
    const cache = await caches.open(CACHE_NAME);
    const cached = await cache.match(request);

    if (cached) {
        return cached;
    }

    try {
        const response = await fetch(request);
        // 只缓存成功的 GET 请求
        if (response.ok && request.method === "GET") {
            cache.put(request, response.clone());
        }
        return response;
    } catch (error) {
        // 网络失败, 返回离线页面
        return cache.match("/offline.html");
    }
}

// 网络优先策略
async function networkFirst(request) {
    const cache = await caches.open(RUNTIME_CACHE);

    try {
        const response = await fetch(request);
        if (response.ok && request.method === "GET") {
            cache.put(request, response.clone());
        }
        return response;
    } catch (error) {
        const cached = await cache.match(request);
        return cached || cache.match("/offline.html");
    }
}
```

### 主页面注册代码

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
    <head>
        <title>Service Worker Demo</title>
    </head>
    <body>
        <h1>Service Worker 示例</h1>

        <script>
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", () => {
                    navigator.serviceWorker
                        .register("/sw.js")
                        .then((registration) => {
                            console.log("SW 注册成功:", registration);

                            // 监听更新
                            registration.addEventListener("updatefound", () => {
                                const newWorker = registration.installing;
                                newWorker.addEventListener("statechange", () => {
                                    if (newWorker.state === "activated") {
                                        // 提示用户刷新页面
                                        if (confirm("发现新版本, 是否立即刷新?")) {
                                            window.location.reload();
                                        }
                                    }
                                });
                            });
                        })
                        .catch((error) => {
                            console.error("SW 注册失败:", error);
                        });
                });
            }
        </script>
    </body>
</html>
```

<br>

## 更新机制

Service Worker 的更新遵循以下规则:

1. **浏览器会定期检查** (通常是 24 小时), 或者用户访问页面时检查
2. **字节差异更新**: 如果 `sw.js` 文件有任何字节变化, 浏览器会认为这是新版本
3. **等待激活**: 新的 Service Worker 会等待旧的 Service Worker 控制的页面全部关闭后才激活
4. **强制更新**: 使用 `skipWaiting()` 和 `clients.claim()` 可以强制立即更新

### 手动触发更新

```javascript
navigator.serviceWorker.ready.then((registration) => {
    // 手动检查更新
    registration.update();
});
```

### 处理更新提示

```javascript
let refreshing = false;

// 监听控制器变化
navigator.serviceWorker.addEventListener("controllerchange", () => {
    if (refreshing) return;
    refreshing = true;
    window.location.reload();
});

// 注册时监听更新
navigator.serviceWorker.register("/sw.js").then((registration) => {
    registration.addEventListener("updatefound", () => {
        const newWorker = registration.installing;

        newWorker.addEventListener("statechange", () => {
            if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                // 新的 Service Worker 已安装, 提示用户
                if (confirm("发现新版本, 是否立即更新?")) {
                    newWorker.postMessage({ type: "SKIP_WAITING" });
                }
            }
        });
    });
});
```

在 Service Worker 中接收消息:

```javascript
// sw.js
self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
        self.skipWaiting();
    }
});
```

<br>

## 调试技巧

### Chrome DevTools

1. 打开 Chrome DevTools → Application → Service Workers
2. 可以看到当前页面的 Service Worker 状态
3. **Offline** 复选框: 模拟离线环境
4. **Update on reload**: 每次刷新时强制更新 Service Worker
5. **Bypass for network**: 绕过 Service Worker, 直接请求网络
6. **Unregister**: 注销 Service Worker
7. **Errors**: 查看错误日志

### Cache Storage

1. DevTools → Application → Cache Storage
2. 查看所有缓存的资源
3. 可以手动删除缓存项

### 常用调试命令

```javascript
// 获取所有注册的 Service Worker
navigator.serviceWorker.getRegistrations().then((registrations) => {
    console.log(registrations);
});

// 注销所有 Service Worker
navigator.serviceWorker.getRegistrations().then((registrations) => {
    registrations.forEach((registration) => {
        registration.unregister();
    });
});

// 清空所有缓存
caches.keys().then((names) => {
    names.forEach((name) => {
        caches.delete(name);
    });
});
```

<br>

## 常见问题

### 1. Service Worker 不生效

-   检查是否在 HTTPS 环境 (或 localhost)
-   检查 `sw.js` 路径是否正确
-   检查 Service Worker 的作用域范围
-   清除浏览器缓存后重试

### 2. 更新不生效

-   浏览器会对 `sw.js` 进行 HTTP 缓存, 可以在响应头设置: `Cache-Control: no-cache`
-   使用 `registration.update()` 手动触发更新
-   在 DevTools 中勾选 "Update on reload"

### 3. 缓存占用过多

-   定期清理过期缓存
-   使用 LRU (Least Recently Used) 策略限制缓存数量
-   监听 `storage` 事件, 在空间不足时清理

```javascript
// 限制缓存数量
async function limitCacheSize(cacheName, maxItems) {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();

    if (keys.length > maxItems) {
        // 删除最早的缓存
        await cache.delete(keys[0]);
        // 递归检查
        await limitCacheSize(cacheName, maxItems);
    }
}
```

### 4. 开发环境与生产环境

开发环境建议:

```javascript
// 开发模式: 不缓存, 方便调试
if (process.env.NODE_ENV === "development") {
    self.addEventListener("fetch", (event) => {
        event.respondWith(fetch(event.request));
    });
}
```

<br>

## 高级特性

### 1. 后台同步 (Background Sync)

```javascript
// 注册后台同步
navigator.serviceWorker.ready.then((registration) => {
    return registration.sync.register("sync-tag");
});

// 在 Service Worker 中监听
self.addEventListener("sync", (event) => {
    if (event.tag === "sync-tag") {
        event.waitUntil(
            // 执行同步操作
            syncData()
        );
    }
});
```

### 2. 推送通知 (Push Notifications)

```javascript
// 请求通知权限
Notification.requestPermission().then((permission) => {
    if (permission === "granted") {
        console.log("通知权限已授予");
    }
});

// 订阅推送
navigator.serviceWorker.ready.then((registration) => {
    registration.pushManager
        .subscribe({
            userVisibleOnly: true,
            applicationServerKey: "YOUR_PUBLIC_KEY",
        })
        .then((subscription) => {
            console.log("推送订阅成功", subscription);
        });
});

// Service Worker 中接收推送
self.addEventListener("push", (event) => {
    const data = event.data.json();
    event.waitUntil(
        self.registration.showNotification(data.title, {
            body: data.body,
            icon: "/icon.png",
        })
    );
});
```

### 3. 预缓存更新策略

```javascript
// 使用 Workbox 简化开发
importScripts("https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js");

workbox.precaching.precacheAndRoute([
    { url: "/index.html", revision: "v1" },
    { url: "/styles.css", revision: "v1" },
]);

workbox.routing.registerRoute(({ request }) => request.destination === "image", new workbox.strategies.CacheFirst());
```

<br>

## 最佳实践

1. **版本控制**: 使用版本号管理缓存, 便于更新和回滚
2. **缓存策略分离**: 不同类型的资源使用不同的缓存策略
3. **错误处理**: 为所有异步操作添加错误处理
4. **离线体验**: 提供友好的离线页面
5. **性能监控**: 记录缓存命中率, 优化缓存策略
6. **渐进增强**: 确保 Service Worker 不可用时应用仍能正常运行
7. **安全考虑**: 验证所有缓存的资源, 防止缓存污染
8. **及时清理**: 定期清理过期或无用的缓存

<br>

## 浏览器兼容性

-   Chrome 40+
-   Firefox 44+
-   Safari 11.1+
-   Edge 17+

**注意:** 部分高级特性 (如 Background Sync, Push Notifications) 的浏览器支持情况可能有所不同, 使用前需要进行特性检测.

<br>

## 参考资料

-   [MDN - Service Worker API](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)
-   [Workbox - Google 官方 Service Worker 工具库](https://developer.chrome.com/docs/workbox)
-   [PWA Builder](https://www.pwabuilder.com/)
