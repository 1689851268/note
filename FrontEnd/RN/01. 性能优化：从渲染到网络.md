# 渲染优化

**避免不必要的渲染**: 使用 `React.memo` 或 `PureComponent` 通过比较属性和状态来防止不必要的组件重新渲染.

```jsx
import React, { memo } from "react";

const MyComponent = memo(({ prop1, prop2 }) => {
    // Component logic
});

// Or use PureComponent
class MyComponent extends React.PureComponent {
    render() {
        // Component logic
    }
}
```

**使用 shouldComponentUpdate**: 对于自定义组件, 重写 `shouldComponentUpdate` 以手动控制渲染.

```jsx
class MyComponent extends React.Component {
    shouldComponentUpdate(nextProps, nextState) {
        return nextProps.prop1 !== this.props.prop1 || nextState.stateProp !== this.state.stateProp;
    }

    render() {
        // Component logic
    }
}
```

**使用 FlatList 和 SectionList**: 对于长列表, 使用 `FlatList` 或 `SectionList` 通过虚拟化显著提高性能, 仅渲染可视区域内的项目.

```jsx
import { FlatList } from "react-native";

const MyList = ({ data }) => (
    <FlatList
        data={data}
        renderItem={({ item }) => <MyListItem item={item} />}
        keyExtractor={(item, index) => item.id.toString()}
    />
);
```

**减少样式计算**: 避免在运行时计算样式, 尤其是在 `render` 方法中.

**懒加载和按需加载**: 对于大型组件或图片, 使用懒加载, 仅在它们接近视口时才加载.

<br><br>

# 网络请求优化

**批量请求**: 尽可能将多个请求合并为一个, 例如使用 GraphQL 或批量 API.

**缓存机制**: 实现缓存机制, 如 `Cache-Control` 或 Service Workers, 以减少冗余请求.

**异步和预加载**: 在应用启动时, 后台预加载关键数据.

**错误处理和重试策略**: 实现智能错误处理和重试逻辑, 以最小化失败请求.

<br><br>

# 内存管理

**清理引用**: 使用 `useEffect` 中的 `cleanup` 函数或 `componentWillUnmount` 生命周期方法来清除订阅, 计时器等.

```jsx
useEffect(() => {
    const subscription = someObservable.subscribe((data) => {
        // Handle data
    });

    return () => {
        subscription.unsubscribe(); // Clean up reference
    };
}, []); // Run only once on component mount
```

**避免内存泄漏**: 仔细检查未使用的对象和变量, 确保它们被正确释放.

**优化图片资源**: 使用压缩图片和合适的尺寸来减少内存使用.

<br><br>

# 平台特定优化

**使用原生模块**: 对于性能关键部分, 编写原生模块以利用平台特定的性能优势.

**优化动画**: 使用 Animated API 或原生动画库来提高动画性能.

**利用平台特性**: 根据平台特性优化代码, 例如在 iOS 上使用 `UIRefreshControl` 而不是自定义下拉刷新.

**更新 React Native 版本**: 保持 React Native 更新以受益于最新的性能改进和修复.

<br><br>

# 代码拆分和动态导入

代码拆分可以减少初始包的大小, 提高应用启动速度. 虽然 React Native 原生不支持代码拆分, 但像 `react-native-code-push` 或 `expo-updates` 这样的服务可以实现动态更新和按需加载.

```jsx
// Using Expo Updates for dynamic module loading
import * as Updates from "expo-updates";

async function loadDynamicModule() {
    const updateInfo = await Updates.fetchUpdateAsync();
    if (updateInfo.isAvailable) {
        await Updates.reloadAsync();
        // After reloading, dynamically import module from the new version
        const DynamicModule = await import("path/to/dynamic/module");
        // Use DynamicModule
    }
}
```

<br><br>

# 优化图片和字体

**压缩图片**: 使用 TinyPNG 或 ImageOptim 等工具压缩图片, 减小文件大小.

**使用矢量图形**: 对于图标和简单图形, 使用 SVG 格式以实现可缩放性和更小的文件大小.

**字体子集化**: 仅加载应用程序中使用的字体字符, 以减小字体文件大小.

<br><br>

# 减少组件层级

尽量减少组件树的深度, 因为渲染会遍历整棵树. 通过组合组件和移除不必要的包装组件来优化.

<br><br>

# 优化 FlatList 属性

`FlatList` 提供了 `initialNumToRender` 和 `maxToRenderPerBatch` 等优化属性来减少初始渲染开销.

```jsx
<FlatList
    data={data}
    renderItem={renderItem}
    keyExtractor={keyExtractor}
    initialNumToRender={10} // Number of items to render initially
    maxToRenderPerBatch={5} // Number of items to render per batch during scrolling
/>
```

<br><br>

# 避免使用高阶组件 (HOCs)

HOCs 会增加组件的复杂性, 导致额外的渲染. 尽可能使用函数组件和 Hooks.

<br><br>

# 使用分析器工具

React Native 提供了一个内置的分析器工具来识别性能瓶颈. 在开发模式下, 打开开发者菜单, 选择 "分析器", 开始录制以分析哪些组件渲染时间最长.

<br><br>

# 使用性能监控工具

使用 `react-native-perf-monitor` 或 `react-native-performance` 这类库来监控性能指标, 如帧率和内存使用情况.

<br><br>

# 优化网络库

如果使用自定义网络库, 确保其经过优化. 例如, 使用 `axios` 而不是 `fetch` 可能会提供更好的性能, 因为其提供了更多的控制和优化选项.

<br><br>

# 使用 Hermes 引擎

从 React Native 0.60 开始, Hermes 是一个可选的 JavaScript 引擎, 它提供了更快的启动时间和更好的运行时性能. 确保在您的项目中启用 Hermes.

<br><br>

# 优化布局

避免使用绝对定位和负边距等复杂布局. 使用 Flexbox 或 Grid 布局, 通常性能更好.

<br><br>

# 持续监控和优化

性能优化是一个持续的过程. 定期监控应用性能, 利用用户反馈和数据分析来识别和解决问题.

<br><br>

# 避免不必要的全局状态

全局状态 (例如 Redux 或 MobX) 简化了应用管理, 但可能导致不必要的渲染. 仅在必要时使用全局状态, 以避免过度依赖.

```jsx
// Redux example
import { Provider } from "react-redux";
import store from "./store";

function App() {
    return (
        <Provider store={store}>
            <RootNavigator />
        </Provider>
    );
}
```

<br><br>

# 使用纯函数组件和 Hooks

纯函数组件和 Hooks (例如, `useState`, `useMemo`) 通过仅在依赖项变化时重新计算来减少不必要的渲染.

```jsx
import React, { useState, useMemo } from "react";

function MyComponent({ data }) {
    const [count, setCount] = useState(0);

    const computedValue = useMemo(() => {
        // Computation logic
        return data.length + count;
    }, [data, count]);

    return (
        <View>
            <Text>{computedValue}</Text>
            <Button onPress={() => setCount(count + 1)} title="Increment" />
        </View>
    );
}
```

<br><br>

# 使用 useCallback 和 useMemo

对于传递给子组件的函数, 使用 `useCallback` 来缓存函数实例, 避免每次渲染时创建新函数. 对于依赖于其他值的复杂计算, 使用 `useMemo` 来防止重复计算.

```jsx
import React, { useCallback, useMemo } from "react";

function ParentComponent({ items }) {
    const handleItemClick = useCallback((item) => {
        console.log(`Clicked on ${item.name}`);
    }, []);

    const sortedItems = useMemo(() => {
        return items.sort((a, b) => a.name.localeCompare(b.name));
    }, [items]);

    return <ChildComponent items={sortedItems} onItemClick={handleItemClick} />;
}
```

<br><br>

# 使用 useLayoutEffect

对于需要在布局完成后运行的副作用, 例如测量元素尺寸, 请使用 `useLayoutEffect` 而不是 `useEffect`. `useLayoutEffect` 在所有 DOM 变更完成后, 屏幕更新前运行.

```jsx
import React, { useLayoutEffect, useRef } from "react";

function MyComponent() {
    const textRef = useRef(null);

    useLayoutEffect(() => {
        const textWidth = textRef.current.measureLayout(findNodeHandle(textRef.current.parentNode));
        console.log("Text width:", textWidth);
    }, []);

    return <Text ref={textRef}>Hello, World!</Text>;
}
```

<br><br>

# 避免在事件处理器中执行复杂操作

保持事件处理器轻量, 避免复杂的计算或异步操作. 将这些操作移至事件处理器调用后的单独函数中.

```jsx
function MyComponent() {
    const handleClick = () => {
        // Lightweight operations, like setting state
        setIsLoading(true);

        // Move complex operations to a separate function
        fetchData().then(() => setIsLoading(false));
    };

    return (
        <TouchableOpacity onPress={handleClick}>
            <Text>Loading...</Text>
        </TouchableOpacity>
    );
}
```

<br><br>
