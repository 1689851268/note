# 静态资源的动态加载

## 问题描述

在前端工程化开发中, 经常会遇到一个问题: **静态资源的动态加载**.

典型场景: 根据条件动态加载静态资源.

```vue
<template>
    <!-- 季节选择器 -->
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <!-- 根据用户选择, 动态加载不同季节的图片 -->
    <img :src="currentImage" />
</template>

<script setup lang="ts">
import { ref, computed } from "vue";

const selectedSeason = ref("spring");

const currentImage = computed(() => {
    return `@/assets/images/${selectedSeason.value}.webp`;
});
</script>
```

结果: 图片无法正常显示.

<br><br>

## 问题原因分析

### 根本原因

打包工具 (如 Vite) 通过**依赖分析**来确定哪些资源需要打包, **只有被明确导入或通过特定方式引用的资源才会被打包**, 动态拼接的路径在编译时无法被识别.

<br>

### 为什么静态链接可以工作

```html
<img src="@/assets/images/spring.webp" />
```

原因: Vite 的自动依赖发现机制能够识别:

-   多媒体元素的静态链接 (img、video、audio)
-   CSS 中的静态链接
-   `import()` / `new URL()` 中的静态或半静态链接

<br><br>

## 解决方案

### 方案一: 使用 public 目录

**实现方式**:

1. 将静态资源文件放到 public 目录下
2. 使用绝对路径引用资源

**工作原理**:

-   Vite 在构建过程中会将 public 目录下的文件原样复制到 dist 输出目录下
-   可通过绝对路径直接请求资源, 无需模块解析

**注意事项**:

-   资源文件不会获得文件指纹, 影响缓存策略
-   需要手动管理资源版本和缓存策略
-   引用文件的路径必须与 public 目录结构保持一致

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <img :src="currentImage" />
</template>

<script setup lang="ts">
import { ref, computed } from "vue";

const selectedSeason = ref("spring");

const currentImage = computed(() => {
    // 使用绝对路径引用资源
    return `/images/${selectedSeason.value}.webp`;
});
</script>
```

<br>

### 方案二: 手动导入所有资源

**实现方式**:

1. 手动导入所有可能的静态资源
2. 创建映射维护资源名称和资源路径
3. 根据条件从映射中获取对应的资源路径

**工作原理**:

-   Vite 在构建时能识别所有静态 `import` 语句, 进行依赖分析

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <img :src="currentImage" />
</template>

<script setup lang="ts">
import { ref, computed } from "vue";

// 手动导入所有可能的静态资源
import spring from "@/assets/images/spring.webp";
import summer from "@/assets/images/summer.webp";
import autumn from "@/assets/images/autumn.webp";
import winter from "@/assets/images/winter.webp";

const selectedSeason = ref("spring");

// 创建映射维护资源名称和资源路径
const imageMap = { spring, summer, autumn, winter };

const currentImage = computed(() => {
    // 根据条件从映射中获取对应的资源路径
    const image = imageMap[selectedSeason.value as keyof typeof imageMap];
    console.log({ imageMap, image });
    return image;
});
</script>
```

<br>

### 方案三: 动态绑定 CSS 类

**实现方式**:

1. 预先定义多个 CSS 类, 每个类对应一张特定的图片
2. 在 CSS 中使用 `background-image` 属性引用静态资源
3. 通过 Vue 的动态类绑定 (`:class`) 实现类名切换
4. 使用 `div` 元素作为容器, 设置合适的尺寸和背景属性

**工作原理**:

-   CSS 中的静态资源引用能被 Vite 的依赖分析机制识别和处理
-   通过动态切换 CSS 类名来改变元素的背景图片

**注意事项**:

-   必须使用 `div` 等块级元素, 不能使用 `img` 元素
-   需要为容器设置明确的宽高, 否则背景图片可能不显示

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <!-- 使用 div 元素和动态 CSS 类 -->
    <div :class="currentImageClass" class="season-image-container"></div>
</template>

<script setup lang="ts">
import { ref, computed } from "vue";

const selectedSeason = ref("spring");

const currentImageClass = computed(() => {
    return `season-image-${selectedSeason.value}`;
});
</script>

<style scoped>
/* 基础容器样式 */
.season-image-container {
    width: 200px;
    height: 200px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

/* 春天图片 */
.season-image-spring {
    background-image: url("@/assets/images/spring.webp");
}

/* 夏天图片 */
.season-image-summer {
    background-image: url("@/assets/images/summer.webp");
}

/* 秋天图片 */
.season-image-autumn {
    background-image: url("@/assets/images/autumn.webp");
}

/* 冬天图片 */
.season-image-winter {
    background-image: url("@/assets/images/winter.webp");
}
</style>
```

<br>

### 方案四: 使用 `import()`

**实现方式**:

1. 使用 `import()` 函数动态导入模块
2. 使用 `watchEffect` 或 `watch` 监听依赖变化, 触发资源重新加载

**工作原理**:

-   Vite 能识别 `import()` 中的 "半静态路径", 构建时自动将该目录下所有匹配的资源作为依赖进行打包

**注意事项**:

-   路径必须是半静态的, 即目录和文件后缀固定, 只有文件名部分可以动态
-   动态加载会产生两次网络请求, 先加载模块文件, 再加载实际资源

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <!-- currentImage 为空字符串时不设置 src 属性 -->
    <img v-bind="{ src: currentImage }" />
</template>

<script setup lang="ts">
import { ref, watchEffect } from "vue";

const selectedSeason = ref("spring");
const currentImage = ref("");

watchEffect(async () => {
    const module = await import(`@/assets/images/${selectedSeason.value}.webp`);
    console.log("module", module);
    currentImage.value = module.default;
});
</script>
```

<br>

### 方案五: 使用 `new URL()`

**实现方式**:

1. 使用 `new URL()` 构造器创建 URL 对象 `url`
2. 第一个参数为资源的相对路径, 文件名部分支持动态
3. 第二个参数使用 `import.meta.url` 作为基准 URL
4. 通过 `url.href` 属性获取完整的资源 URL

**工作原理**:

-   `new URL()` 是浏览器原生 Web API, 用于解析相对路径为绝对 URL
-   `import.meta.url` 提供当前模块的绝对 URL 作为路径解析的基准点

**注意事项**:

-   路径必须是半静态的, 即目录和文件后缀固定, 只有文件名部分可以动态
-   不能使用别名路径 (如 `@/`), 必须使用相对于当前文件的路径
-   在服务端渲染 (SSR) 模式下可能无法正常工作, 因为 `import.meta.url` 在浏览器和 Node 中的表现不同

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <img :src="currentImage" />
</template>

<script setup lang="ts">
import { ref, computed } from "vue";

const selectedSeason = ref("spring");

const currentImage = computed(() => {
    // 使用 new URL() 构造器获取资源路径
    const url = new URL(`../../assets/images/${selectedSeason.value}.webp`, import.meta.url);
    console.log({ url, "import.meta.url": import.meta.url });
    return url.href;
});
</script>
```

<br>

### 方案六: 使用 `import.meta.glob()`

**实现方式**:

1. 使用 `import.meta.glob` 批量导入匹配特定模式的模块
2. 通过路径匹配获取对应的资源模块

**工作原理**:

-   `import.meta.glob` 是 Vite 提供的特殊 API, 专门用于批量导入模块
-   构建时自动分析匹配模式, 将所有符合条件的资源作为依赖进行打包

**注意事项**:

-   路径模式必须使用资源的相对路径, 不能使用 Vite 别名 (如 `@/`)
-   支持预加载模式 (`eager: true`) 和懒加载模式 (`eager: false`)
-   懒加载模式 (`eager: false`) 会产生两次网络请求, 先加载模块文件, 再加载实际资源

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <img :src="currentImage" />
</template>

<script setup lang="ts">
import { ref, computed } from "vue";

const selectedSeason = ref("spring");

// 使用 import.meta.glob 批量导入图片资源 (预加载模式)
const images = import.meta.glob("../../assets/images/*.webp", { eager: true }) as Record<string, { default: string }>;

// 计算当前图片 URL
const currentImage = computed(() => {
    const image = images[`../../assets/images/${selectedSeason.value}.webp`];
    console.log({ images, image });
    return image.default;
});
</script>
```

```vue
<template>
    <div>
        <label>选择季节:</label>
        <select v-model="selectedSeason">
            <option value="spring">春天</option>
            <option value="summer">夏天</option>
            <option value="autumn">秋天</option>
            <option value="winter">冬天</option>
        </select>
    </div>

    <!-- currentImage 为空字符串时不设置 src 属性 -->
    <img v-bind="{ src: currentImage }" />
</template>

<script setup lang="ts">
import { ref, watchEffect } from "vue";

const selectedSeason = ref("spring");

// 使用 import.meta.glob 批量导入图片资源 (懒加载模式)
const images = import.meta.glob("../../assets/images/*.webp") as Record<string, () => Promise<{ default: string }>>;

// 当前图片 URL
const currentImage = ref("");

// 使用 watchEffect 自动追踪依赖并懒加载图片
watchEffect(async () => {
    const image = images[`../../assets/images/${selectedSeason.value}.webp`];
    const imageModule = await image();
    console.log({ images, image, imageModule });
    currentImage.value = imageModule.default;
});
</script>
```

<br><br>

## 总结

Vite 能够识别:

-   `import` 语句中的静态路径
-   多媒体元素 (`<img>`, `<video>`, `<audio>` 等标签) 的 `src` 属性中的静态路径
-   CSS `url()` 函数中的静态路径
-   `import()` / `new URL()` 中的半静态路径
-   `import.meta.glob()` 中的模式匹配路径

<br>
