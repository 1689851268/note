# TAP

TAP ( 三地址协议, Three Address Protocol ) 是一种通过使用三个独立的钱包地址来保护数字资产的安全协议. 建立以下三种钱包基本可以满足我们的日常使用需求:

1. **铸币钱包 ( Mint Wallet )**

-   存放金额: 非常少量

-   用途: 铸币合约 & 投机活动

-   特点: 连接到不受信任网站的最小资金

2. **交易钱包 ( Marketplace Wallet )**

-   存放金额: 较 Mint Wallet 多, 一般满足交易即可

-   用途: OpenSea / Blur / Uniswap & 在受信任的市场合约上批准

-   特点: 进行市场交易

3. **保险库钱包 ( Vault Wallet )**

-   存放金额: 大量

-   用途: 存放高价值资产

-   特点: 不进行任何批准 & 不与合约交互 & 仅限转账 & 使用明文签名

在日常的普通交易中我们可以使用交易钱包 ( Marketplace Wallet ) , 当我们需要进行做一些投机风险时, 如领取空投就可以使用铸币钱包 ( Mint Wallet ) , 当我们交易完毕, 就可以把交易钱包 ( Marketplace Wallet ) 中的数字资产转移到我们的保险库钱包 ( Vault Wallet ) , 通过将不同用途的钱包分离, 可以有效地限制风险暴露, 保护高价值资产的安全性

<br><br>

# 检查和撤销授权

定期检查和撤销不必要的授权可以显著提高安全性, 保护用户的资产免受潜在的威胁.

可以使用 Revoke.cash 检查和撤销授权:

1. 打开浏览器, 访问 [Revoke.cash](https://revoke.cash)

2. 连接钱包

3. 查看授权列表

4. 撤销不需要的授权

<br><br>

# 区块链如何应用零知识证明

## 隐私

在比特币交易过程中, 为验证一笔交易是否合法, 实际上只需验证以下三件事:

1. 发送方确实拥有足够的资金.

2. 发送方转出的金额和接收方收到的金额一致.

3. 发送方的资金确实被销毁.

在整个证明过程中, 矿工实际上并不关心具体的交易金额, 发送者身份或接收者身份. 矿工只关心系统中的资金是否守恒. Zcash (大零币) 正是基于这一思路, 实现了隐私交易.

<br>

## 扩容

早期公链项目的 TPS (每秒交易数) 非常低, 例如比特币的 TPS 约为 7, 以太坊的 TPS 约为 15. 这意味着以太坊每秒只能处理 15 笔交易, 如此低的 TPS 严重限制了区块链应用的大规模落地. 因此, 研究区块链扩容的问题变得至关重要, 目标是提高链上的 TPS.

然而, 区块链扩容受限于 Vitalik 提出的不可能三角理论, 即区块链系统设计无法同时兼顾 [可扩展性], [去中心化] 和 [安全性], 三者只能取其二. 这一结论虽然令人失望, 但我们必须认识到, 任何事物都有其边界. 公链不应试图承担所有任务, 而应专注于其核心使命: "公链是以最高效率达成共识的工具, 能够以最低成本构建信任".

作为共识的工具和信任的引擎, 公链不应为了可扩展性而放弃去中心化和安全性. 那么, 如何在保持去中心化和安全性的同时, 提升公链的 TPS 呢? 一个有效的方法是将大量的工作放到链下处理, 只将最重要的数据提交到区块链主链上, 让所有节点都能够验证这些链下工作的准确性和可靠性.

区块链技术的发展也是如此, 在底层区块链 (Layer 1) 上构建一个扩展层 (Layer 2). Layer 1 负责确保安全和去中心化, 做到全球共识, 并作为 "加密法院", 通过智能合约设计的规则进行仲裁, 以经济激励的形式将信任传递到 Layer 2 上. 而 Layer 2 追求极致的性能, 虽然只能实现局部共识, 但能够满足各种商业场景的需求.

**链下扩容**:

ZK-Rollup 是一种基于零知识证明的二层扩容方案. ZK-Rollup 方案起源于 2018 年下半年, 由 Barry Whitehat 和 Vitalik 提出. Rollup 意为 "卷起" 和 "汇总", 将大量交易 "卷起/汇总" 打包成一个交易.

ZK-Rollup 的原理可以简要概述为: 在链下进行复杂的计算和证明生成, 链上进行证明的校验并存储部分数据以保证数据可用性. ZK-Rollup 的数据可用性允许任何人根据链上存储的交易数据, 还原出账户的全局状态.

<br><br>

# Base58 编码方案

Base58 是一种 58 进制的编码方案, 与 Base64 类似, 基于 58 个可打印字符来表示二进制数据. 这些字符包括阿拉伯数字和大小写英文字母.

**特点**:

相比于 Base64, Base58 去掉了 6 个易混淆的字符: 数字 `0`, 大写 `O`, 小写 `l`, 大写 `I` 以及 `+` `/`, 以便在任何字体中都能肉眼区分这些字符. 这种设计使得 Base58 编码在需要高可读性的场景中 (如区块链地址和密钥) 更加实用.

Base58 和 Base64 的缺点是会造成信息冗余, 输出比输入大许多, 所以这种编码方案只适合小数据. 而且 Base58 与 Base64 不同的是, 前者采用大数进制转换, 效率更低, 所以使用场景更少.

Base64 普通应用于 URL, 短文本, 图片; Base58 一般用在比特币地址, 私钥和脚本哈希场景.

<br><br>
