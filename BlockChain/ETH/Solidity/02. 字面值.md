# 地址字面值

地址字面值是长度为 42 字节的十六进制字符串, 例如 `0x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990`, 可直接赋值给地址类型变量, 如 `address addr = 0x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990;`.

<br><br>

# 有理数和整数字面值

**表示方式**:

-   十进制整数：如 `123`. eg: `uint256 d1 = 123;` (`d1 = 123`)

-   十进制小数：如 `0.1`,`1.2` 等, 小数点后必须至少跟一个数字. eg: `uint256 d2 = 0.1 + 1.9;` (`d2 = 2`)

-   十六进制整数：如 `0xff`. eg: `uint256 h = 0xff;` (`h = 255`)

-   科学记数法：如 `2e10`,`-2e10`,`2e-10`,`2.5e1`. eg: `int256 s1 = 2e10;` (`s1 = 20000000000`)

**不支持的表示与辅助表示**:

-   Solidity 不支持 8 进制字面值.

-   在整数字面值中可使用下划线增强可读性, 如 1000_000 表示 100 万, 下划线不影响数值.

**任意精度特性**:

-   有理数和整数字面值在 Solidity 中可具有任意精度, 不会有精度损失. 例如, `uint256 p = (2**800 + 1) - 2**800;`, 变量 `p` 的值为 1.

**与非字面值运算的类型转换**: 字面值与非字面值运算时, 字面值会尝试转换为非字面值类型：

-   `uint128 a = 1; uint128 b = 2.5 + a + 0.5;` (编译报错, 因为 2.5 与 `a` 运算时需转换为 `uint128` 类型但不匹配).

-   `uint128 a = 1; uint128 b = 2.5 + 0.5 + a;` (结果为 `b = 4`, 因为 2.5 和 0.5 先运算得到 3, 3 转换为 `uint128` 再与 `a` 运算).

-   `uint128 a = 1; uint128 b = a + 2.5 + 0.5;` (编译报错, 因为 `a` 与 2.5 先运算需转换 2.5 为 `uint128` 类型但不匹配).

<br><br>

# 字符串字面值

用单引号 `''` 或双引号 `""` 定义, 如 `string memory s1 = "This is a string";` 和 `string memory s2 = 'This is a string';`.

**隐式类型转换**:

字符串字面值可隐式转换为 `bytes1`,`bytes2`,…,`bytes32` 和 `string` 类型, 可直接赋值, 如 `bytes1 b1 = "b";` 等.

**转义字符**:

支持多种转义字符, 包括 `\<newline>` (字符串跨多行), `\\` (反斜杠), `\'` (单引号), `\"` (双引号), `\n` (新行), `\r` (回车), `\t` (tab), `\xNN` (十六进制表示字符), `\uNNNN` (unicode 表示字符), 可混合使用, 如 `”\’hello world\’”`.

<br><br>

# Unicode 字面值

与字符串字面值类似, 在前面加上 `unicode` 关键字, 由反斜杠 `\` 和四位十六进制数拼成, 可包含 UTF-8 字符, 如 `string memory a = unicode"Hello \u0041 😃";` (`\u0041` 表示大写字母 A).

<br><br>
