# Value Type

Value Type (值类型) 的变量在赋值或作为函数参数传递时, 会复制其数据的值.

<br>

## Boolean

```solidity
contract Demo {
    bool public isActive; // 默认为 false
}
```

布尔类型的值可以进行以下运算:

-   逻辑运算: `!` (逻辑非), `&&` (逻辑与), `||` (逻辑或)

-   比较运算: `==` (等于), `!=` (不等于)

其中, `&&` 和 `||` 是短路运算符, 即如果第一个操作数已经能够确定整个表达式的值, 则不会再计算第二个操作数.

<br>

## Integer

-   无符号整数类型: `uint8`, `uint16`, ..., `uint256` (`uint256` 可简写为 `uint`)

-   有符号整数类型: `int8`, `int16`, ..., `int256` (`int256` 可简写为 `int`)

```solidity
contract Demo {
    // 有符号整数类型
    int public signedInt; // 默认为 0, 取值范围为 -2^255 ~ 2^255-1
    // 无符号整数类型
    uint public unsignedInt; // 默认为 0, 取值范围为 0 ~ 2^256-1
}
```

整数类型的值可以进行以下运算:

-   算术运算: `+` (加), `-` (减), `*` (乘), `/` (除), `%` (取余), `**` (幂)

-   比较运算: `==` (等于), `!=` (不等于), `<` (小于), `>` (大于), `<=` (小于等于), `>=` (大于等于)

-   位运算: `&` (按位与), `|` (按位或), `^` (按位异或), `~` (按位取反), `<<` (左移), `>>` (右移)

<br>

## Address

-   20 字节大小, 用于存储合约或账户的地址

```solidity
contract Demo {
    address public owner; // 默认为 0x0000000000000000000000000000000000000000,  即 address(0)
}
```

地址类型的值可以进行比较运算: `==` (等于), `!=` (不等于), `<` (小于), `>` (大于), `<=` (小于等于), `>=` (大于等于), 通常用来判断两个地址是否相等.

<br>

## Fixed-length Byte

-   `bytes1`, `bytes2`, ..., `bytes32`

```solidity
contract Demo {
    bytes1 public dataHash1; // 默认为 0x00
    bytes2 public dataHash2; // 默认为 0x0000
}
```

可以看出, 1 字节 (byte) - 8 位 (bit) - 2 个十六进制数. 因为 `2^4 = 16`, 即 1 个十六进制数可以表示 4 位二进制数.

<br>

## Enum

-   枚举的默认值是其定义的第一个值

-   枚举值在内部表示为 uint8, 从 0 开始递增

```solidity
contract Demo {
    enum State {
        PENDING,  // 0
        ACTIVE,  // 1
        INACTIVE // 2
    }
    State public state; // 默认值为 PENDING,  即 0
}
```

<br><br>

# Reference Type

Reference Type (引用类型) 的变量在赋值或作为函数参数传递时, 会复制存储数据的地址.

<br>

## String

```solidity
contract Demo {
    string public stringData; // 默认为空字符串 ""
}
```

<br>

## Dynamic-length Byte

```solidity
contract Demo {
    bytes public byteData; // 默认为 0x
}
```

<br>

## Array

-   固定大小数组类型: `uint[5]` 表示包含 5 个无符号整数的数组

-   动态大小数组类型: `uint[]` 表示大小可变的无符号整数数组

```solidity
contract Demo {
    // 固定大小数组类型
    uint[3] public fixedArray1; // 默认为 [0,  0,  0]
    // 动态大小数组类型
    uint[] public dynamicArray; // 默认为 []

    // 对于固定大小数组类型的变量,  还能如下创建
    uint[] public fixedArray2 = new uint[](3); // 默认为 [0,  0,  0]
}
```

<br>

## Structure

用于将不同类型的数据组合在一起

```solidity
contract Demo {
    struct Person {
        string name;
        uint age;
    }
    Person public person;
    // 数据的默认值为对应类型的默认值,  这里 name 默认为空字符串 "",  age 默认为 0
}
```

<br><br>

# Mapping Type

Mapping Type (映射类型) 是存储键值对的数据结构, 可以理解为哈希表.

```solidity
contract Demo {
    mapping(address => uint) public balances;
    // key-value 中,  value 的默认值为对应类型的默认值,  这里为 uint 的默认值 0
}
```

需要注意: ① 映射的 key 只能是 Solidity 内置的值类型, 如 uint, address; ② 映射类型也属于引用类型的一种; ③ 映射的存储位置必需是 storage.

原理: 映射用 `keccak256(abi.encodePacked(key,  slot))` 作 offset 存取 value, 其中 slot 是映射变量定义所在的插槽位置.

<br><br>

# Function Type

Function Type (函数类型) 是 Solidity 的一种特殊类型, 用于存储函数的引用.

```solidity
contract Demo {
    function add(uint a,  uint b) public pure returns (uint) {
        return a + b;
    }
}
```

<br><br>

# 字符串 & 字节

```solidity
contract Demo {
    bytes32 public _byte32 = "MiniSolidity";
    // 以字节形式存储字符串 "MiniSolidity"
    // 0x4d696e69536f6c69646974790000000000000000000000000000000000000000

    bytes1 public _byte = _byte32[0]; // 取出第一个字节
    // 0x4d
}
```

```solidity
contract Demo {
    bytes public _byte32 = "MiniSolidity";
    // 以字节形式存储字符串 "MiniSolidity"
    // 0x4d696e69536f6c6964697479

    bytes1 public _byte = _byte32[0]; // 取出第一个字节
    // 0x4d
}
```

<br><br>

# 整数 & 枚举

枚举可以显式地和 uint 相互转换, 且会检查转换的正整数是否在枚举的长度内:

```solidity
contract Demo {
    enum State {
        PENDING,  // 0
        ACTIVE,  // 1
        INACTIVE // 2
    }
    State public state = State.ACTIVE; // 1

    uint public stateValue = uint(state); // 1
    State public newState = State(stateValue); // ACTIVE,  即 1
}
```

<br><br>
