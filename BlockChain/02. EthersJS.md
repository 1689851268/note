# EthersJS

EthersJS 用于与以太坊区块链及其生态系统进行交互。

与更早出现的 Web3JS 相比，EthersJS 具有以下优势：

1. 代码更加紧凑：Web3JS 大小为 590.6 kB；而 EthersJS 为 116.5 kB 。

2. 安全性更高：Web3JS 假设用户会在本地部署以太坊节点，并由该节点管理私钥和网络连接状态（实际情况并非如此）；EthersJS 则通过 Provider 类管理网络连接状态，通过 Wallet 类管理密钥，既安全又灵活。

3. 原生支持 ENS：EthersJS 原生支持以太坊名称服务（ENS），使得与 ENS 的交互更加便捷。

<br><br>

# HelloVitalik

现在，让我们用 Ethers 编写第一个程序 HelloVitalik，查询以太坊创始人 Vitalik 的 ETH 余额并输出到控制台。

```shell
pnpm install ethers
```

```js
import { ethers } from "ethers";

// 创建一个默认的以太坊提供者 (Provider), 这个提供者会连接到以太坊主网 (homestead)
const provider = ethers.getDefaultProvider();

const main = async () => {
    // 使用 provider 获取指定 ENS 名称 (vitalik.eth) 的以太坊余额
    const balance = await provider.getBalance(`vitalik.eth`);
    // 将获取到的余额从 Wei 单位转换为 Ether 单位, 并打印到控制台
    console.log(`Vitalik Buterin 的以太坊地址余额: ${ethers.utils.formatEther(balance)} ETH`);
};

main();
```

在 Ethers 中，Provider 类是一个用于连接以太坊网络的抽象类，它提供对区块链及其状态的只读访问。Ethers 内置了一些公共 RPC，方便用户连接以太坊。但 Ethers 内置的 RPC 访问速度有限制，仅供测试使用。在生产环境中，建议申请个人 RPC，例如 Infura 或 Alchemy。

我们可以使用 getBalance 函数来查询指定地址的 ETH 余额。由于 Ethers 原生支持 ENS 域名，我们不需要知道具体地址，只需使用 ENS 域名 vitalik.eth 就可以查询到 Vitalik 的余额。

从链上获取的以太坊余额以 wei 为单位，而 1 ETH = 10^18 wei 。Ethers 提供了 formatEther 函数，可以将 wei 转换为 ETH 。

<br><br>

# Provider 提供器

在 Ethers 中，Provider 不接触用户私钥，只能读取链上信息，不能进行写入操作，这使得它比 Web3JS 更加安全。

除了之前提到的默认提供者 defaultProvider 以外，Ethers 中最常用的提供者是 JsonRpcProvider，它允许用户连接到特定节点。

**连接节点**：

我们可以在节点服务商的网站 (如 Infura 或 Alchemy) 注册并创建 API Key。此外，我们还可以在 [Chainlist](https://chainlist.org/) 找到各个链的公开节点。

这里，我们以 Chainlist 上的公开节点为例。在找到合适的 RPC 后，可以利用 `ethers.providers.JsonRpcProvider()` 方法来创建 provider ，该方法以节点服务的 URL 链接为参数。以下是分别连接到 ETH 主网和 Sepolia 测试网的 provider 创建示例：

```js
// 定义以太坊主网和 Sepolia 测试网的 RPC URL
const ETH_MAINNET_RPC_URL = "https://rpc.ankr.com/eth";
const SEPOLIA_TESTNET_RPC_URL = "https://rpc.sepolia.org";

// 创建连接以太坊主网的 provider
const mainnetProvider = new ethers.providers.JsonRpcProvider(ETH_MAINNET_RPC_URL);

// 创建连接以太坊 Sepolia 测试网的 provider
const sepoliaProvider = new ethers.providers.JsonRpcProvider(SEPOLIA_TESTNET_RPC_URL);
```

**利用 provider 读取链上数据**：

1. getBalance：查询指定地址的 ETH 余额（测试网目前不支持 ENS 域名，只能用钱包地址查询）：

```js
const mainnetBalance = await mainnetProvider.getBalance(`vitalik.eth`);
console.log(`Vitalik Buterin 在主网的余额: ${ethers.utils.formatEther(mainnetBalance)} ETH`);

const sepoliaBalance = await sepoliaProvider.getBalance(`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`);
console.log(`Vitalik Buterin 在 Sepolia 测试网的余额: ${ethers.utils.formatEther(sepoliaBalance)} ETH`);
```

2. getNetwork：查询当前连接的网络信息（`name: homestead` 表示 ETH 主网）：

```js
const mainnetNetwork = await mainnetProvider.getNetwork();
console.log(`主网的网络信息: ${JSON.stringify(mainnetNetwork)}`);

const sepoliaNetwork = await sepoliaProvider.getNetwork();
console.log(`Sepolia 测试网的网络信息: ${JSON.stringify(sepoliaNetwork)}`);
```

3. getBlockNumber：查询当前区块高度

```js
const mainnetBlockNumber = await mainnetProvider.getBlockNumber();
console.log(`主网的当前区块高度: ${mainnetBlockNumber}`);

const sepoliaBlockNumber = await sepoliaProvider.getBlockNumber();
console.log(`Sepolia 测试网的当前区块高度: ${sepoliaBlockNumber}`);
```

4. getTransactionCount：查询指定地址的交易次数

```js
const mainnetTransactionCount = await mainnetProvider.getTransactionCount(`vitalik.eth`);
console.log(`Vitalik Buterin 在主网的交易次数: ${mainnetTransactionCount}`);

const sepoliaTransactionCount = await sepoliaProvider.getTransactionCount(`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`);
console.log(`Vitalik Buterin 在 Sepolia 测试网的交易次数: ${sepoliaTransactionCount}`);
```

5. getFeeData：查询当前建议的 gas 费用数据

```js
const mainnetFeeData = await mainnetProvider.getFeeData();
console.log(`主网当前建议的 gas 费用数据: ${JSON.stringify(mainnetFeeData)}`);

const sepoliaFeeData = await sepoliaProvider.getFeeData();
console.log(`Sepolia 测试网当前建议的 gas 费用数据: ${JSON.stringify(sepoliaFeeData)}`);
```

6. getBlock：查询指定区块的信息

```js
const mainnetBlock = await mainnetProvider.getBlock(0);
console.log(`主网区块 0 的信息: ${JSON.stringify(mainnetBlock)}`);

const sepoliaBlock = await sepoliaProvider.getBlock(0);
console.log(`Sepolia 测试网区块 0 的信息: ${JSON.stringify(sepoliaBlock)}`);
```

7. getCode：查询指定地址的合约字节码

```js
// 本例使用主网 WETH 合约的地址
const mainnetCode = await mainnetProvider.getCode(`0xc778417e063141139fce010982780140aa0cd5ab`);
console.log(`主网 WETH 合约的字节码: ${mainnetCode}`);
```

<br><br>

# Contract 合约

在 Ethers 中，Contract 类是以太坊网络上合约（EVM 字节码）的抽象。通过它，开发者可以轻松地读取合约信息 call 和进行交易 transaction 。注意：Ethers 中的 call 指的是只读操作，与 Solidity 中的 call 不同。

contract 分为 2 类：

-   只读 contract：只能读取链上合约信息，执行 call 操作，即调用合约中的 `view` 和 `pure` 函数，不能执行交易。创建时需要传入合约地址、合约 ABI 和 provider 。

-   可写 contract：可以读取和写入链上合约信息，执行交易。创建时需要传入合约地址、合约 ABI 和 signer。`Signer` 是 Ethers 中的另一个类，用于签名，我们稍后会讲解。

**创建只读 contract 实例**：

ABI (Application Binary Interface) 是与以太坊智能合约交互的标准。Ethers 支持两种 ABI 格式：

1. 直接输入合约 ABI：可以从 Remix 的编译页面复制，或在本地编译合约时生成的 artifact 文件夹中的 JSON 文件中找到，也可以从 Etherscan 开源合约的代码页面获取。

```js
const abiWETH =
    '[{"constant":true,"inputs":[],"name":"name","outputs":...太长了可以从 https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code 获取';
const addressWETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const contractWETH = new ethers.Contract(addressWETH, abiWETH, provider);
```

2. Human-Readable ABI（人类可读 ABI）：由于传统 ABI 的可读性较差，Ethers 引入了 Human-Readable ABI。开发者可以通过函数签名和事件签名来编写 ABI 。

```js
const abiWETH = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint256)",
];
const addressWETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const contractWETH = new ethers.Contract(addressWETH, abiWETH, provider);
```

**读取 WETH 的链上信息**：

我们可以利用只读 Contract 实例调用合约的 view 和 pure 函数，获取链上信息：

```js
console.log(`合约地址: ${addressWETH}`);

const nameWETH = await contractWETH.name();
console.log(`名称: ${nameWETH}`);

const symbolWETH = await contractWETH.symbol();
console.log(`代号: ${symbolWETH}`);

const totalSupplyWETH = await contractWETH.totalSupply();
console.log(`总供给: ${totalSupplyWETH}`);

const balanceWETH = await contractWETH.balanceOf("vitalik.eth");
console.log(`Vitalik 持仓: ${ethers.utils.formatEther(balanceWETH)}`);
```

<br><br>

# Signer & Wallet

Web3JS 假设用户会在本地部署以太坊节点，并由该节点管理私钥和网络连接状态（实际情况并非如此）。而在 EthersJS 中，Provider 类管理网络连接状态，Signer 类或 Wallet 类管理密钥，既安全又灵活。

在 EthersJS 中，Signer 类是以太坊账户的抽象，用于对消息和交易进行签名，并将签名的交易发送到以太坊网络，从而更改区块链状态。Signer 类是一个抽象类，不能直接实例化，我们需要使用它的子类：Wallet 类。

Wallet 类继承了 Signer 类，并且开发者可以像包含私钥的外部拥有帐户 (EOA) 一样，用它对交易和消息进行签名。

**代码示例**：

1. 创建 Provider 实例

```js
import { ethers } from "ethers";

const infuraKey = "infuraKey...";
const provider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${infuraKey}`);
```

2. 创建 Wallet 实例

方法 1：创建随机的 wallet 对象：利用 `ethers.Wallet.createRandom()` 创建带有随机私钥的 wallet 对象。该私钥由加密安全的熵源生成，如果当前环境没有安全的熵源，则会引发错误。

方法 2：用私钥创建 wallet 对象：利用 `ethers.Wallet(privateKey, provider)` 创建 wallet 对象。

方法 3：用助记词创建 wallet 对象：利用 `ethers.Wallet.fromPhrase(phrase)` 创建 wallet 对象。

方法 4：用 JSON 文件创建 wallet 对象：利用 `ethers.Wallet.fromEncryptedJson(keystoreJson)` 解密一个 JSON 钱包文件创建钱包实例，JSON 文件即 keystore 文件，通常来自 Geth、Parity 等钱包。

```js
// 创建随机的 wallet 对象
const wallet1 = ethers.Wallet.createRandom();

// 通过私钥创建 wallet 对象;  这种方法创建的钱包获取不到助记词
const privateKey = "钱包账户的私钥...";
const wallet2 = new ethers.Wallet(privateKey, provider);

// 通过助记词创建 wallet 对象
const phrase = wallet1.mnemonic.phrase; // 获取 wallet1 的助记词
const wallet3 = ethers.Wallet.fromMnemonic(phrase);
```

3. 获取钱包地址

```js
// 方式 1
console.log(`wallet1 address: ${wallet1.address}`);
console.log(`wallet2 address: ${wallet2.address}`);
console.log(`wallet3 address: ${wallet3.address}`);

// 方式 2
console.log(`wallet1 address: ${await wallet1.getAddress()}`);
console.log(`wallet2 address: ${await wallet2.getAddress()}`);
console.log(`wallet3 address: ${await wallet3.getAddress()}`);
```

4. 获取助记词信息

```js
console.log(`wallet1 mnemonic: ${JSON.stringify(wallet1.mnemonic)}`);
console.log(`wallet2 mnemonic: ${JSON.stringify(wallet2.mnemonic)}`); // wallet2 的助记词信息为 null
console.log(`wallet3 mnemonic: ${JSON.stringify(wallet3.mnemonic)}`);
```

5. 获取私钥

```js
console.log(`wallet1 private key: ${wallet1.privateKey}`);
console.log(`wallet2 private key: ${wallet2.privateKey}`);
console.log(`wallet3 private key: ${wallet3.privateKey}`);
```

6. 获取钱包在链上的交互次数

```js
// 方式 1
console.log(`wallet1 nonce: ${await provider.getTransactionCount(wallet1.address)}`);
console.log(`wallet2 nonce: ${await provider.getTransactionCount(wallet2.address)}`);
console.log(`wallet3 nonce: ${await provider.getTransactionCount(wallet3.address)}`);

// 方式 2
console.log(`wallet1 nonce: ${await wallet1.connect(provider).getTransactionCount()}`);
console.log(`wallet2 nonce: ${await wallet2.getTransactionCount()}`);
console.log(`wallet3 nonce: ${await wallet3.connect(provider).getTransactionCount()}`);
```

7. 发送 ETH

我们用 wallet2 给 wallet1 发送 0.001 ETH，并打印交易前后的钱包余额。

如果钱包没钱, 可以去水龙头领一些（chainlink 水龙头: https://faucets.chain.link/goerli、paradigm 水龙头: https://faucet.paradigm.xyz/）。

```js
// 查询余额: 方式 1
console.log("wallet1:", await provider.getBalance(wallet1.address));
console.log("wallet2:", await provider.getBalance(wallet2.address));

// 转账: wallet2 -> wallet1
const tx = {
    to: wallet1.address, // 接收地址
    value: ethers.utils.parseEther("0.001"), // 转账金额
};
const txResponse = await wallet2.sendTransaction(tx);
await txResponse.wait(); // 等待链上交易确认
console.log("txResponse:", JSON.stringify(txResponse, null, 4));

// 查询余额: 方式 2
console.log("wallet1:", await wallet1.connect(provider).getBalance());
console.log("wallet2:", await wallet2.getBalance());
```

<br><br>
