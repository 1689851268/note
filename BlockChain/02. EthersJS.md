# EthersJS

EthersJS 是一个用于与以太坊区块链交互的 JS 库。

与更早出现的 Web3JS 相比，EthersJS 具有以下优势：

1. 体积更小：Web3JS (590.6 kB) - EthersJS (116.5 kB)

2. 安全性更高：Web3JS 假设用户会在本地部署以太坊节点，并由该节点管理私钥和网络连接状态（实际情况并非如此）；EthersJS 则通过 Provider 类管理网络连接状态，通过 Wallet 类管理密钥，既安全又灵活。

3. 原生支持 ENS：EthersJS 原生支持以太坊名称服务（ENS），简化了与 ENS 的交互

**demo**：查询以太坊创始人 Vitalik Buterin 的 ETH 余额

```shell
pnpm i ethers
```

```js
import { ethers } from "ethers";

// 创建一个默认的以太坊主网提供者 provider
const provider = ethers.getDefaultProvider();

const main = async () => {
    // 通过 provider 获取指定 ENS (vitalik.eth) 的以太坊余额
    const balance = await provider.getBalance(`vitalik.eth`);
    // 将获取到的余额从 Wei 单位转换为 Ether 单位, 并输出到控制台
    console.log(`Vitalik 的以太坊地址余额: ${ethers.utils.formatEther(balance)} ETH`);
};

main();
```

<br><br>

# Provider

Provider 是 EthersJS 中用于连接以太坊网络的抽象类，提供对区块链的只读访问。

Ethers 内置了一些公共 RPC，方便用户连接以太坊。但 Ethers 内置的 RPC 访问速度有限制，仅供测试使用。在生产环境中，建议申请个人 RPC，例如 Infura 或 Alchemy。

**连接节点**：

除了之前提到的默认提供者 defaultProvider 以外，Ethers 中最常用的提供者是 JsonRpcProvider，它允许用户连接到特定节点。

我们可以在节点服务商的网站 (如 Infura 或 Alchemy) 注册并创建 API Key。此外，我们还可以在 [Chainlist](https://chainlist.org/) 找到各个链的公开节点。

这里，我们以 Chainlist 上的公开节点为例。以下是分别连接到 ETH 主网和 ETH Sepolia 测试网的 provider 创建示例：

```js
// 定义以太坊主网和 Sepolia 测试网的 RPC URL
const ETH_MAINNET_RPC_URL = "https://rpc.ankr.com/eth";
const SEPOLIA_TESTNET_RPC_URL = "https://rpc.sepolia.org";

// 创建连接以太坊主网 Sepolia 测试网的 provider
const mainnetProvider = new ethers.providers.JsonRpcProvider(ETH_MAINNET_RPC_URL);
const sepoliaProvider = new ethers.providers.JsonRpcProvider(SEPOLIA_TESTNET_RPC_URL);
```

**利用 provider 读取链上数据**：

1. getBalance：查询指定地址的 ETH 余额 (测试网目前不支持 ENS 域名，只能用钱包地址查询)：

```js
const mainnetBalance = await mainnetProvider.getBalance(`vitalik.eth`);
console.log(`Vitalik Buterin 在主网的余额: ${ethers.utils.formatEther(mainnetBalance)} ETH`);

const sepoliaBalance = await sepoliaProvider.getBalance(`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`);
console.log(`Vitalik Buterin 在 Sepolia 测试网的余额: ${ethers.utils.formatEther(sepoliaBalance)} ETH`);
```

2. getNetwork：查询当前连接的网络信息 (`name: homestead` 表示 ETH 主网)：

```js
const mainnetNetwork = await mainnetProvider.getNetwork();
console.log(`主网的网络信息: ${JSON.stringify(mainnetNetwork)}`);

const sepoliaNetwork = await sepoliaProvider.getNetwork();
console.log(`Sepolia 测试网的网络信息: ${JSON.stringify(sepoliaNetwork)}`);
```

3. getBlockNumber：查询当前区块高度

```js
const mainnetBlockNumber = await mainnetProvider.getBlockNumber();
console.log(`主网的当前区块高度: ${mainnetBlockNumber}`);

const sepoliaBlockNumber = await sepoliaProvider.getBlockNumber();
console.log(`Sepolia 测试网的当前区块高度: ${sepoliaBlockNumber}`);
```

4. getTransactionCount：查询指定地址的交易次数

```js
const mainnetTransactionCount = await mainnetProvider.getTransactionCount(`vitalik.eth`);
console.log(`Vitalik Buterin 在主网的交易次数: ${mainnetTransactionCount}`);

const sepoliaTransactionCount = await sepoliaProvider.getTransactionCount(`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`);
console.log(`Vitalik Buterin 在 Sepolia 测试网的交易次数: ${sepoliaTransactionCount}`);
```

5. getFeeData：查询当前建议的 gas 费用数据

```js
const mainnetFeeData = await mainnetProvider.getFeeData();
console.log(`主网当前建议的 gas 费用数据: ${JSON.stringify(mainnetFeeData)}`);

const sepoliaFeeData = await sepoliaProvider.getFeeData();
console.log(`Sepolia 测试网当前建议的 gas 费用数据: ${JSON.stringify(sepoliaFeeData)}`);
```

6. getBlock：查询指定区块的信息

```js
const mainnetBlock = await mainnetProvider.getBlock(0);
console.log(`主网区块 0 的信息: ${JSON.stringify(mainnetBlock)}`);

const sepoliaBlock = await sepoliaProvider.getBlock(0);
console.log(`Sepolia 测试网区块 0 的信息: ${JSON.stringify(sepoliaBlock)}`);
```

7. getCode：查询指定地址的合约字节码

```js
// 本例使用主网 WETH 合约的地址
const mainnetCode = await mainnetProvider.getCode(`0xc778417e063141139fce010982780140aa0cd5ab`);
console.log(`主网 WETH 合约的字节码: ${mainnetCode}`);
```

<br><br>

# Signer & Wallet

在 EthersJS 中，Signer 类是以太坊账户的抽象，用于对消息和交易进行签名，并将签名的交易发送到以太坊网络，从而更改区块链状态。Signer 类是一个抽象类，不能直接实例化，我们需要使用它的子类：Wallet 类。

Wallet 类继承了 Signer 类，并且开发者可以像包含私钥的外部拥有帐户 (EOA) 一样，用它对交易和消息进行签名。

**代码示例**：

1. 创建 Provider 实例

```js
import { ethers } from "ethers";

const infuraKey = "infuraKey...";
const provider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${infuraKey}`);
```

2. 创建 Wallet 实例

方法 1：创建随机的 wallet 对象：利用 `ethers.Wallet.createRandom()` 创建带有随机私钥的 wallet 对象。该私钥由加密安全的熵源生成，如果当前环境没有安全的熵源，则会引发错误。

方法 2：用私钥创建 wallet 对象：利用 `ethers.Wallet(privateKey, provider)` 创建 wallet 对象。

方法 3：用助记词创建 wallet 对象：利用 `ethers.Wallet.fromPhrase(phrase)` 创建 wallet 对象。

方法 4：用 JSON 文件创建 wallet 对象：利用 `ethers.Wallet.fromEncryptedJson(keystoreJson)` 解密一个 JSON 钱包文件创建钱包实例，JSON 文件即 keystore 文件，通常来自 Geth、Parity 等钱包。

```js
// 创建随机的 wallet 对象
const wallet1 = ethers.Wallet.createRandom();

// 通过私钥创建 wallet 对象;  这种方法创建的钱包获取不到助记词
const privateKey = "钱包账户的私钥...";
const wallet2 = new ethers.Wallet(privateKey, provider);

// 通过助记词创建 wallet 对象
const phrase = wallet1.mnemonic.phrase; // 获取 wallet1 的助记词
const wallet3 = ethers.Wallet.fromMnemonic(phrase);
```

3. 获取钱包地址

```js
// 方式 1
console.log(`wallet1 address: ${wallet1.address}`);
console.log(`wallet2 address: ${wallet2.address}`);
console.log(`wallet3 address: ${wallet3.address}`);

// 方式 2
console.log(`wallet1 address: ${await wallet1.getAddress()}`);
console.log(`wallet2 address: ${await wallet2.getAddress()}`);
console.log(`wallet3 address: ${await wallet3.getAddress()}`);
```

4. 获取助记词信息

```js
console.log(`wallet1 mnemonic: ${JSON.stringify(wallet1.mnemonic)}`);
console.log(`wallet2 mnemonic: ${JSON.stringify(wallet2.mnemonic)}`); // wallet2 的助记词信息为 null
console.log(`wallet3 mnemonic: ${JSON.stringify(wallet3.mnemonic)}`);
```

5. 获取私钥

```js
console.log(`wallet1 private key: ${wallet1.privateKey}`);
console.log(`wallet2 private key: ${wallet2.privateKey}`);
console.log(`wallet3 private key: ${wallet3.privateKey}`);
```

6. 获取钱包在链上的交互次数

```js
// 方式 1
console.log(`wallet1 nonce: ${await provider.getTransactionCount(wallet1.address)}`);
console.log(`wallet2 nonce: ${await provider.getTransactionCount(wallet2.address)}`);
console.log(`wallet3 nonce: ${await provider.getTransactionCount(wallet3.address)}`);

// 方式 2
console.log(`wallet1 nonce: ${await wallet1.connect(provider).getTransactionCount()}`);
console.log(`wallet2 nonce: ${await wallet2.getTransactionCount()}`);
console.log(`wallet3 nonce: ${await wallet3.connect(provider).getTransactionCount()}`);
```

7. 发送 ETH

我们用 wallet2 给 wallet1 发送 0.001 ETH，并打印交易前后的钱包余额。

如果钱包没钱, 可以去水龙头领一些（chainlink 水龙头: https://faucets.chain.link/goerli、paradigm 水龙头: https://faucet.paradigm.xyz/）。

```js
// 查询余额: 方式 1
console.log("wallet1:", await provider.getBalance(wallet1.address));
console.log("wallet2:", await provider.getBalance(wallet2.address));

// 转账: wallet2 -> wallet1
const tx = {
    to: wallet1.address, // 接收地址
    value: ethers.utils.parseEther("0.001"), // 转账金额
};
const txResponse = await wallet2.sendTransaction(tx);
await txResponse.wait(); // 等待链上交易确认
console.log("txResponse:", JSON.stringify(txResponse, null, 4));

// 查询余额: 方式 2
console.log("wallet1:", await wallet1.connect(provider).getBalance());
console.log("wallet2:", await wallet2.getBalance());
```

<br><br>

# Contract

Contract 类是以太坊智能合约的抽象，用于与链上合约交互。

**contract 类型**：

-   只读 contract：

    -   只能读取链上合约信息，即调用合约中的 view 和 pure 函数；不能执行交易

    -   创建时需传入：合约地址、ABI、provider

-   可写 contract：

    -   可以读取和写入链上合约信息；可以执行交易

    -   创建时需传入：合约地址、ABI、signer

**ABI 格式**：

以 sepolia 测试网的 WETH 合约为例：

1.  标准 JSON 格式

```js
// 从 https://sepolia.etherscan.io/address/0x5f207d42f869fd1c71d7f0f81a2a67fc20ff7323#code 获取
const WETHABI = '[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":""...]';
```

2.  Human-Readable ABI（函数签名列表）

```js
const WETHABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint256)",
    // 按需填写...
];
```

**创建合约实例**：

先声明前置数据

```js
import { ethers } from "ethers";

const infuraKey = "infuraKey...";
const provider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${infuraKey}`);

const privateKey = "钱包账户的私钥...";
const wallet = new ethers.Wallet(privateKey, provider);

// sepolia 测试网的 WETH 合约地址
const WETHAddress = "0x5f207d42F869fd1c71d7f0f81a2A67Fc20FF7323";
```

1.  创建只读合约：

```js
const readableWETHContract = new ethers.Contract(WETHAddress, WETHABI, provider);
```

2. 创建可写合约：

方法 1：

```js
const writableWETHContract = new ethers.Contract(WETHAddress, WETHABI, wallet);
```

方法 2：

```js
const writableWETHContract = readableWETHContract.connect(wallet);
```

**合约交互**：

我们可以使用 readableWETHContract 调用合约的 view / pure 函数，以获取合约信息 (不需要 gas) ：

```js
const WETHName = await readableWETHContract.name();
console.log(`名称: ${WETHName}`);

const WETHSymbol = await readableWETHContract.symbol();
console.log(`代号: ${WETHSymbol}`);

const WETHTotalSupply = await readableWETHContract.totalSupply();
console.log(`总供给: ${WETHTotalSupply}`);

const WETHBalance = await readableWETHContract.balanceOf("vitalik.eth");
console.log(`Vitalik 持仓: ${ethers.utils.formatEther(WETHBalance)}`);
```

我们可以使用 writableWETHContract 调用合约函数，以获取合约信息 (不需要 gas) / 执行交易 (需要 gas) ：

```js
const balance1 = await writableWETHContract.balanceOf(wallet.address);
console.log(`WETH 余额: ${ethers.utils.formatEther(balance1)}`);

// 调用 WETH 合约的 deposit 方法, 将 0.01 ETH 转换为 WETH
const tx1 = await writableWETHContract.deposit({ value: ethers.utils.parseEther("0.01") });
await tx1.wait(); // 等待链上确认
console.log("deposit tx1:", JSON.stringify(tx1, null, 4));

const balance2 = await writableWETHContract.balanceOf(wallet.address);
console.log(`WETH 余额: ${ethers.utils.formatEther(balance2)}`);

// 调用 WETH 合约的 transfer 方法, 将 0.001 WETH 转账给另一个地址
const tx2 = await writableWETHContract.transfer("0x ...", ethers.utils.parseEther("0.001"));
await tx2.wait(); // 等待链上确认
console.log("transfer tx2:", JSON.stringify(tx2, null, 4));

const balance3 = await writableWETHContract.balanceOf(wallet.address);
console.log(`WETH 余额: ${ethers.utils.formatEther(balance3)}`);
```

注意事项：

1.  交易操作会返回交易信息，但不返回函数执行结果。如需获取交易执行结果，需使用事件（Event）。

2.  view / pure 函数会直接返回结果，其他函数则返回交易信息。

3.  如需知晓函数执行过程中合约变量的变化，可监听事件获取交易详细信息。

<br><br>

# 部署智能合约

在以太坊上，智能合约的部署是一种特殊的交易：将编译后的合约字节码发送到 0 地址。如果合约构造函数有参数，需要用 abi.encode 将参数编码为字节码，并附加到合约字节码末尾。

**合约工厂**：

EthersJS 提供了 ContractFactory 类，简化了合约部署过程。

1. 创建合约工厂实例

```js
const contractFactory = new ethers.ContractFactory(abi, bytecode, signer);
```

注意：如果合约的构造函数有参数，那么在 abi 中必须包含构造函数。

2. 部署合约

创建好合约工厂实例后，可以调用它的 deploy 函数并传入合约构造函数的参数 args 来部署并获得合约实例

```js
const contractInstance = await contractFactory.deploy(...args);
```

3. 等待合约部署

```js
await contractInstance.deployed();
// 或
await contractInstance.deployTransaction.wait();
```

**demo - 部署 ERC20 代币合约**：

1. 创建 provider 和 wallet

```js
import { ethers } from "ethers";

const infuraKey = "infuraKey...";
const provider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${infuraKey}`);

const privateKey = "钱包账户的私钥...";
const wallet = new ethers.Wallet(privateKey, provider);
```

2. 准备 ERC20 合约 ABI 和字节码

因为 ERC20 的构造函数含有参数，因此我们必须把构造函数包含在 ABI 中。

合约的字节码可以从 remix 的编译面板中点击 Bytecode 按钮，把它复制下来。如果是部署在链上的合约，可以在 Etherscan 的 Contract 页面的 Contract Creation Code 中找到。

```js
const ERC20ABI = [
    "constructor(string memory name_, string memory symbol_)",
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint)",
    "function transfer(address to, uint256 amount) external returns (bool)",
    "function mint(uint amount) external",
];

const ERC20Bytecode = "6080604052...";
```

3. 创建合约工厂实例

```js
const ERC20Factory = new ethers.ContractFactory(ERC20ABI, ERC20Bytecode, wallet);
```

4. 调用工厂合约的 deploy 函数并填入构造函数的参数（代币名称和代号），部署 ERC20 代币合约并获得合约实例

```js
const ERC20Contract = await ERC20Factory.deploy("MyToken", "MTK");
await ERC20Contract.deployed(); // 等待合约部署在链上确认
console.log(`ERC20 合约信息: ${JSON.stringify(ERC20Contract, null, 4)}`);
```

5. 合约上链后，可以查看合约信息

```js
const name = await ERC20Contract.name();
console.log(`name: ${name}`);
const symbol = await ERC20Contract.symbol();
console.log(`symbol: ${symbol}`);
const address = ERC20Contract.address;
console.log(`address: ${address}`);
```

6.  调用 mint 函数给自己铸造 10,000 枚代币

```js
const mintTx = await ERC20Contract.mint(10000);
await mintTx.wait(); // 等待链上确认
console.log("mintTx:", JSON.stringify(mintTx, null, 4));

const balance1 = await ERC20Contract.balanceOf(wallet.address);
console.log(`钱包余额: ${ethers.utils.formatEther(balance1)}`);
```

7.  调用 transfer 函数，将 1,000 枚代币转账给另一个地址

```js
const tx = await ERC20Contract.transfer("0x ...", ethers.utils.parseEther("1000"));
await tx.wait(); // 等待链上确认
console.log("tx:", JSON.stringify(tx, null, 4));

const balance2 = await ERC20Contract.balanceOf(wallet.address);
console.log(`钱包余额: ${ethers.utils.formatEther(balance2)}`);
```

<br><br>
