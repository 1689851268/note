# EthersJS

EthersJS 用于与以太坊区块链及其生态系统进行交互。

与更早出现的 Web3JS 相比，EthersJS 具有以下优势：

1. 代码更加紧凑：Web3JS 大小为 590.6 kB；而 EthersJS 为 116.5 kB 。

2. 安全性更高：Web3JS 假设用户会在本地部署以太坊节点，并由该节点管理私钥和网络连接状态（实际情况并非如此）；EthersJS 则通过 Provider 类管理网络连接状态，通过 Wallet 类管理密钥，既安全又灵活。

3. 原生支持 ENS：EthersJS 原生支持以太坊名称服务（ENS），使得与 ENS 的交互更加便捷。

<br><br>

# HelloVitalik

现在，让我们用 Ethers 编写第一个程序 HelloVitalik，查询以太坊创始人 Vitalik 的 ETH 余额并输出到控制台。

```shell
pnpm install ethers
```

```js
import { ethers } from "ethers";

// 创建一个默认的以太坊提供者 (Provider), 这个提供者会连接到以太坊主网 (homestead)
const provider = ethers.getDefaultProvider();

const main = async () => {
    // 使用 provider 获取指定 ENS 名称 (vitalik.eth) 的以太坊余额
    const balance = await provider.getBalance(`vitalik.eth`);
    // 将获取到的余额从 Wei 单位转换为 Ether 单位, 并打印到控制台
    console.log(`Vitalik Buterin 的以太坊地址余额: ${ethers.utils.formatEther(balance)} ETH`);
};

main();
```

在 Ethers 中，Provider 类是一个用于连接以太坊网络的抽象类，它提供对区块链及其状态的只读访问。Ethers 内置了一些公共 RPC，方便用户连接以太坊。但 Ethers 内置的 RPC 访问速度有限制，仅供测试使用。在生产环境中，建议申请个人 RPC，例如 Infura 或 Alchemy。

我们可以使用 getBalance 函数来查询指定地址的 ETH 余额。由于 Ethers 原生支持 ENS 域名，我们不需要知道具体地址，只需使用 ENS 域名 vitalik.eth 就可以查询到 Vitalik 的余额。

从链上获取的以太坊余额以 wei 为单位，而 1 ETH = 10^18 wei 。Ethers 提供了 formatEther 函数，可以将 wei 转换为 ETH 。

<br><br>

# Provider 提供器

在 Ethers 中，Provider 不接触用户私钥，只能读取链上信息，不能进行写入操作，这使得它比 Web3JS 更加安全。

除了之前提到的默认提供者 defaultProvider 以外，Ethers 中最常用的提供者是 JsonRpcProvider，它允许用户连接到特定节点。

**连接节点**：

我们可以在节点服务商的网站 (如 Infura 或 Alchemy) 注册并创建 API Key。此外，我们还可以在 [Chainlist](https://chainlist.org/) 找到各个链的公开节点。

这里，我们以 Chainlist 上的公开节点为例。在找到合适的 RPC 之后，可以利用 `ethers.providers.JsonRpcProvider()` 方法来创建 provider ，该方法以节点服务的 URL 链接为参数。以下是分别连接到 ETH 主网和 Sepolia 测试网的 provider 创建示例：

```js
// 定义以太坊主网和 Sepolia 测试网的 RPC URL
const ETH_MAINNET_RPC_URL = "https://rpc.ankr.com/eth";
const SEPOLIA_TESTNET_RPC_URL = "https://rpc.sepolia.org";

// 创建连接以太坊主网的 provider
const mainnetProvider = new ethers.providers.JsonRpcProvider(ETH_MAINNET_RPC_URL);

// 创建连接 Sepolia 测试网的 provider
const sepoliaProvider = new ethers.providers.JsonRpcProvider(SEPOLIA_TESTNET_RPC_URL);
```

**利用 provider 读取链上数据**：

1. getBalance：查询指定地址的 ETH 余额（测试网目前不支持 ENS 域名，只能用钱包地址查询）：

```js
const mainnetBalance = await mainnetProvider.getBalance(`vitalik.eth`);
console.log(`Vitalik Buterin 在主网的余额: ${ethers.utils.formatEther(mainnetBalance)} ETH`);

const sepoliaBalance = await sepoliaProvider.getBalance(`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`);
console.log(`Vitalik Buterin 在 Sepolia 测试网的余额: ${ethers.utils.formatEther(sepoliaBalance)} ETH`);
```

2. getNetwork：查询当前连接的网络信息（`name: homestead` 表示 ETH 主网）：

```js
const mainnetNetwork = await mainnetProvider.getNetwork();
console.log(`主网 provider 连接到的网络信息: ${JSON.stringify(mainnetNetwork)}`);

const sepoliaNetwork = await sepoliaProvider.getNetwork();
console.log(`Sepolia 测试网 provider 连接到的网络信息: ${JSON.stringify(sepoliaNetwork)}`);
```

3. getBlockNumber：查询当前区块高度

```js
const mainnetBlockNumber = await mainnetProvider.getBlockNumber();
console.log(`主网 provider 当前区块高度: ${mainnetBlockNumber}`);

const sepoliaBlockNumber = await sepoliaProvider.getBlockNumber();
console.log(`Sepolia 测试网 provider 当前区块高度: ${sepoliaBlockNumber}`);
```

4. getTransactionCount：查询指定地址的交易次数

```js
const mainnetTransactionCount = await mainnetProvider.getTransactionCount(`vitalik.eth`);
console.log(`Vitalik Buterin 在主网的交易次数: ${mainnetTransactionCount}`);

const sepoliaTransactionCount = await sepoliaProvider.getTransactionCount(`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`);
console.log(`Vitalik Buterin 在 Sepolia 测试网的交易次数: ${sepoliaTransactionCount}`);
```

5. getFeeData：查询当前建议的 gas 费用数据

```js
const mainnetFeeData = await mainnetProvider.getFeeData();
console.log(`主网 provider 当前建议的 gas 费用数据: ${JSON.stringify(mainnetFeeData)}`);

const sepoliaFeeData = await sepoliaProvider.getFeeData();
console.log(`Sepolia 测试网 provider 当前建议的 gas 费用数据: ${JSON.stringify(sepoliaFeeData)}`);
```

6. getBlock：查询指定区块的信息

```js
const mainnetBlock = await mainnetProvider.getBlock(0);
console.log(`主网 provider 区块 0 的信息: ${JSON.stringify(mainnetBlock)}`);

const sepoliaBlock = await sepoliaProvider.getBlock(0);
console.log(`Sepolia 测试网 provider 区块 0 的信息: ${JSON.stringify(sepoliaBlock)}`);
```

7. getCode：查询指定地址的合约字节码：

```js
// 本例使用主网 WETH 的合约地址
const mainnetCode = await mainnetProvider.getCode(`0xc778417e063141139fce010982780140aa0cd5ab`);
console.log(`主网 WETH 的合约字节码: ${mainnetCode}`);
```

<br><br>

# Contract 合约

在 Ethers 中，Contract 类是以太坊网络上合约（EVM 字节码）的抽象。通过它，开发者可以轻松地读取合约信息进行读取 call 和交易 transaction 。注意：Ethers 中的 call 指的是只读操作，与 Solidity 中的 call 不同。

contract 分为 2 类：

-   只读 contract：只能读取链上合约信息，执行 call 操作，即调用合约中的 `view` 和 `pure` 函数，不能执行交易。创建时需要传入合约地址、合约 ABI 和 provider 。

-   可写 contract：可以读取和写入链上合约信息，执行交易。创建时需要传入合约地址、合约 ABI 和 signer。`Signer` 是 Ethers 中的另一个类，用于签名交易，我们稍后会讲解。

**创建只读 contract 实例**：

ABI（Application Binary Interface） 是与以太坊智能合约交互的标准。Ethers 支持两种 ABI 格式：

1. 直接输入合约 ABI：可以从 Remix 的编译页面复制，或在本地编译合约时生成的 artifact 文件夹中的 JSON 文件中找到，也可以从 Etherscan 开源合约的代码页面获取。

```js
const abiWETH =
    '[{"constant":true,"inputs":[],"name":"name","outputs":...太长了可以从 https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code 获取';
const addressWETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const contractWETH = new ethers.Contract(addressWETH, abiWETH, provider);
```

2. Human-Readable ABI（人类可读 ABI）：由于传统 ABI 的可读性较差，Ethers 引入了 Human-Readable ABI。开发者可以通过函数签名和事件签名来编写 ABI 。

```js
const abiWETH = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint256)",
];
const addressWETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const contractWETH = new ethers.Contract(addressWETH, abiWETH, provider);
```

**读取 WETH 和 DAI 的链上信息**：

我们可以利用只读 Contract 实例调用合约的 view 和 pure 函数，获取链上信息：

```js
console.log(`合约地址: ${addressWETH}`);

const nameWETH = await contractWETH.name();
console.log(`名称: ${nameWETH}`);

const symbolWETH = await contractWETH.symbol();
console.log(`代号: ${symbolWETH}`);

const totalSupplyWETH = await contractWETH.totalSupply();
console.log(`总供给: ${totalSupplyWETH}`);

const balanceWETH = await contractWETH.balanceOf("vitalik.eth");
console.log(`Vitalik 持仓: ${ethers.utils.formatEther(balanceWETH)}`);
```

<br><br>
