# 利用签名发放白名单

这种方法通常用于确保只有经过预先批准的地址才能参与某些操作, 比如铸造 NFT.

以下是完整的流程, 包括签名生成,验证和实际操作.

1. 生成消息哈希

生成一个唯一的消息哈希, 这个哈希将用于签名和验证. 通常, 这个哈希包含用户地址和特定的操作参数 (例如 tokenId).

```solidity
function getMessageHash(address _account, uint256 _tokenId) public pure returns (bytes32) {
    return keccak256(abi.encodePacked(_account, _tokenId));
}
```

2. 签名消息哈希

在前端, 使用钱包 (如 MetaMask) 对消息哈希进行签名. 签名者通常是一个可信的服务器或管理员账户.

```javascript
import { ethers } from "ethers";

async function signMessage(account, tokenId) {
    const messageHash = ethers.utils.solidityKeccak256(["address", "uint256"], [account, tokenId]);
    const signature = await signer.signMessage(ethers.utils.arrayify(messageHash));
    return signature;
}
```

3. 验证签名

在智能合约中, 我们需要验证签名是否由预先设定的签名者生成. 首先, 将消息哈希转换为以太坊签名消息格式, 然后使用 `ecrecover` 恢复签名者地址.

```solidity
function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {
    return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
}

function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool) {
    return _msgHash.toEthSignedMessageHash().recover(_signature) == signer;
}
```

4. 执行操作 (例如铸造 NFT)

如果签名验证通过, 并且地址未执行过该操作, 则允许执行特定操作 (例如铸造 NFT).

```solidity
function mint(address _account, uint256 _tokenId, bytes memory _signature) external {
    bytes32 _msgHash = getMessageHash(_account, _tokenId);
    require(verify(_msgHash, _signature), "Invalid signature");
    require(!mintedAddress[_account], "Already minted!");
    _mint(_account, _tokenId);
    mintedAddress[_account] = true;
}
```

**关键步骤总结:**

1. 生成消息哈希: 在智能合约和前端都使用相同的哈希方法.

2. 签名消息: 在前端使用钱包 (如 MetaMask) 签名消息哈希.

3. 验证签名: 在智能合约中验证签名是否由预先设定的签名者生成.

4. 执行操作: 如果签名有效且地址未执行过该操作, 则允许执行特定操作 (例如铸造 NFT).

**安全性和最佳实践**

-   签名者地址: 确保签名者地址是可信的, 并且在合约部署时正确设置.

-   消息哈希: 使用安全的哈希算法 (如 `keccak256`) 生成消息哈希.

-   签名验证: 在智能合约中严格验证签名, 防止未经授权的地址执行操作.

通过这种方式, 可以确保只有经过预先批准的地址才能参与特定操作, 增强了系统的安全性和可靠性.

<br><br>

# 代码示例

**智能合约部分**:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract WhitelistMint is ERC721 {
    using ECDSA for bytes32;

    address public immutable signer;
    mapping(address => bool) public mintedAddress;

    constructor(
        string memory _name,
        string memory _symbol,
        address _signer
    ) ERC721(_name, _symbol) {
        signer = _signer;
    }

    function getMessageHash(
        address _account,
        uint256 _tokenId
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_account, _tokenId));
    }

    function toEthSignedMessageHash(
        bytes32 hash
    ) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
            );
    }

    function verify(
        bytes32 _msgHash,
        bytes memory _signature
    ) public view returns (bool) {
        return _msgHash.toEthSignedMessageHash().recover(_signature) == signer;
    }

    function mint(
        address _account,
        uint256 _tokenId,
        bytes memory _signature
    ) external {
        bytes32 _msgHash = getMessageHash(_account, _tokenId);
        require(verify(_msgHash, _signature), "Invalid signature");
        require(!mintedAddress[_account], "Already minted!");
        _mint(_account, _tokenId);
        mintedAddress[_account] = true;
    }
}
```

**前端部分**:

在前端, 我们需要生成签名并与智能合约交互. 以下是一个使用 `ethers.js` 的示例:

```javascript
import { ethers } from "ethers";
import WhitelistMint from "./artifacts/contracts/WhitelistMint.sol/WhitelistMint.json";

const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();
const contractAddress = "YOUR_CONTRACT_ADDRESS";
const contract = new ethers.Contract(contractAddress, WhitelistMint.abi, signer);

async function mintNFT(account, tokenId) {
    const messageHash = ethers.utils.solidityKeccak256(["address", "uint256"], [account, tokenId]);
    const signature = await signer.signMessage(ethers.utils.arrayify(messageHash));

    const tx = await contract.mint(account, tokenId, signature);
    await tx.wait();
    console.log("NFT minted successfully!");
}

// Example usage
const account = "0xYourAccountAddress";
const tokenId = 1;
mintNFT(account, tokenId);
```

<br><br>
