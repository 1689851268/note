# Hardhat 项目

Hardhat 是一个以太坊软件的开发环境, 用于编辑、编译、调试和部署 DApp / 智能合约.

搭建 Hardhat 项目:

1. 执行以下命令:

```
mkdir hardhat-demo
cd hardhat-demo
pnpm init
pnpm i hardhat -D
npx hardhat init
```

2. 选择项目类型（本例选择 "Create a JavaScript project"）, 一路回车即可

创建好的 Hardhat 项目主要包含以下文件(夹):

```
hardhat-demo
├── contracts // 合约文件夹
│   └── Lock.sol
├── ignition // 启动文件夹
│   └── modules
│       └── Lock.js
├── test // 测试文件夹
│   └── Lock.js
└── hardhat.config.js // 配置文件
```

查看配置文件 hardhat.config.js:

```js
require("@nomicfoundation/hardhat-toolbox");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
    solidity: "0.8.27", // 编译器版本
};
```

<br><br>

# Hardhat Task

可以使用 `npx hardhat` 查看当前所有可用的任务及其描述:

```
Hardhat version 2.22.11

Usage: hardhat [GLOBAL OPTIONS] [SCOPE] <TASK> [TASK OPTIONS]

GLOBAL OPTIONS:

  --config              A Hardhat config file.
  --emoji               Use emoji in messages.
  --flamegraph          Generate a flamegraph of your Hardhat tasks
  --help                Shows this message, or a task's help if its name is provided
  --max-memory          The maximum amount of memory that Hardhat can use.
  --network             The network to connect to.
  --show-stack-traces   Show stack traces (always enabled on CI servers).
  --tsconfig            A TypeScript config file.
  --typecheck           Enable TypeScript type-checking of your scripts/tests
  --verbose             Enables Hardhat verbose logging
  --version             Shows hardhat's version.


AVAILABLE TASKS:

  check                 Check whatever you need
  clean                 Clears the cache and deletes all artifacts
  compile               Compiles the entire project, building all artifacts
  console               Opens a hardhat console
  coverage              Generates a code coverage report for tests
  flatten               Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened.
  gas-reporter:merge
  help                  Prints this message
  node                  Starts a JSON-RPC server on top of Hardhat Network
  run                   Runs a user-defined script after compiling the project
  test                  Runs mocha tests
  typechain             Generate Typechain typings for compiled contracts
  verify                Verifies a contract on Etherscan or Sourcify


AVAILABLE TASK SCOPES:

  ignition              Deploy your smart contracts using Hardhat Ignition
  vars                  Manage your configuration variables

To get help for a specific task run: npx hardhat help [SCOPE] <TASK>
```

<br><br>

# 编译合约

查看 contracts/Lock.sol:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "hardhat/console.sol"; // Import the console library

contract Lock {
    uint public unlockTime;
    address payable public owner;

    event Withdrawal(uint amount, uint when);

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);
    }

    function withdraw() public {
        console.log(
            "Unlock time is %o and block timestamp is %o",
            unlockTime,
            block.timestamp
        ); // Log the unlock time and the current block timestamp

        require(block.timestamp >= unlockTime, "You can't withdraw yet");
        require(msg.sender == owner, "You aren't the owner");

        emit Withdrawal(address(this).balance, block.timestamp);

        owner.transfer(address(this).balance);
    }
}
```

执行 `npx hardhat compile` 编译合约:

```
Compiled 2 Solidity files successfully (evm target: paris).
```

在编译前, hardhat 会判断是否有符合要求的编译器, 如果没有则会连网下载编译器.

编译成功后, 会生成 artifacts 目录, 里面的 json 文件就是编译结果, 包含了合约的 ABI 和字节码等信息.

<br><br>

# 测试合约

查看 test/Lock.js:

```js
const { time, loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");
const { anyValue } = require("@nomicfoundation/hardhat-chai-matchers/withArgs");
const { expect } = require("chai");

describe("Lock", function () {
    // We define a fixture to reuse the same setup in every test.
    // We use loadFixture to run this setup once, snapshot that state,
    // and reset Hardhat Network to that snapshot in every test.
    async function deployOneYearLockFixture() {
        const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
        const ONE_GWEI = 1_000_000_000;

        const lockedAmount = ONE_GWEI;
        const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

        // Contracts are deployed using the first signer/account by default
        const [owner, otherAccount] = await ethers.getSigners();

        const Lock = await ethers.getContractFactory("Lock");
        const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

        return { lock, unlockTime, lockedAmount, owner, otherAccount };
    }

    describe("Deployment", function () {
        it("Should set the right unlockTime", async function () {
            const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);
            expect(await lock.unlockTime()).to.equal(unlockTime);
        });

        it("Should set the right owner", async function () {
            const { lock, owner } = await loadFixture(deployOneYearLockFixture);
            expect(await lock.owner()).to.equal(owner.address);
        });

        it("Should receive and store the funds to lock", async function () {
            const { lock, lockedAmount } = await loadFixture(deployOneYearLockFixture);
            expect(await ethers.provider.getBalance(lock.target)).to.equal(lockedAmount);
        });

        it("Should fail if the unlockTime is not in the future", async function () {
            // We don't use the fixture here because we want a different deployment
            const latestTime = await time.latest();
            const Lock = await ethers.getContractFactory("Lock");
            await expect(Lock.deploy(latestTime, { value: 1 })).to.be.revertedWith(
                "Unlock time should be in the future"
            );
        });
    });

    describe("Withdrawals", function () {
        describe("Validations", function () {
            it("Should revert with the right error if called too soon", async function () {
                const { lock } = await loadFixture(deployOneYearLockFixture);
                await expect(lock.withdraw()).to.be.revertedWith("You can't withdraw yet");
            });

            it("Should revert with the right error if called from another account", async function () {
                const { lock, unlockTime, otherAccount } = await loadFixture(deployOneYearLockFixture);
                // We can increase the time in Hardhat Network
                await time.increaseTo(unlockTime);
                // We use lock.connect() to send a transaction from another account
                await expect(lock.connect(otherAccount).withdraw()).to.be.revertedWith("You aren't the owner");
            });

            it("Shouldn't fail if the unlockTime has arrived and the owner calls it", async function () {
                const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);
                // Transactions are sent using the first signer by default
                await time.increaseTo(unlockTime);
                await expect(lock.withdraw()).not.to.be.reverted;
            });
        });

        describe("Events", function () {
            it("Should emit an event on withdrawals", async function () {
                const { lock, unlockTime, lockedAmount } = await loadFixture(deployOneYearLockFixture);
                await time.increaseTo(unlockTime);
                await expect(lock.withdraw()).to.emit(lock, "Withdrawal").withArgs(lockedAmount, anyValue); // We accept any value as `when` arg
            });
        });

        describe("Transfers", function () {
            it("Should transfer the funds to the owner", async function () {
                const { lock, unlockTime, lockedAmount, owner } = await loadFixture(deployOneYearLockFixture);
                await time.increaseTo(unlockTime);
                await expect(lock.withdraw()).to.changeEtherBalances([owner, lock], [lockedAmount, -lockedAmount]);
            });
        });
    });
});
```

执行 `npx hardhat test` 运行测试:

```
  Lock
    Deployment
      ✔ Should set the right unlockTime (1039ms)
      ✔ Should set the right owner
      ✔ Should receive and store the funds to lock
      ✔ Should fail if the unlockTime is not in the future
    Withdrawals
      Validations
Unlock time is '1758446024' and block timestamp is '1726910026'
        ✔ Should revert with the right error if called too soon
Unlock time is '1758446024' and block timestamp is '1758446025'
        ✔ Should revert with the right error if called from another account
Unlock time is '1758446024' and block timestamp is '1758446025'
        ✔ Shouldn't fail if the unlockTime has arrived and the owner calls it
      Events
Unlock time is '1758446024' and block timestamp is '1758446025'
        ✔ Should emit an event on withdrawals
      Transfers
Unlock time is '1758446024' and block timestamp is '1758446025'
        ✔ Should transfer the funds to the owner (39ms)


  9 passing (1s)
```

<br><br>

# 部署合约

查看 ignition/modules/Lock.js:

```js
// This setup uses Hardhat Ignition to manage smart contract deployments.
// Learn more about it at https://hardhat.org/ignition

const { buildModule } = require("@nomicfoundation/hardhat-ignition/modules");

const JAN_1ST_2030 = 1893456000;
const ONE_GWEI = 1_000_000_000n;

module.exports = buildModule("LockModule", (m) => {
    const unlockTime = m.getParameter("unlockTime", JAN_1ST_2030);
    const lockedAmount = m.getParameter("lockedAmount", ONE_GWEI);

    const lock = m.contract("Lock", [unlockTime], {
        value: lockedAmount,
    });

    return { lock };
});
```

执行 `npx hardhat ignition deploy ignition/modules/Lock.js` 部署合约:

```
You are running Hardhat Ignition against an in-process instance of Hardhat Network.
This will execute the deployment, but the results will be lost.
You can use --network <network-name> to deploy to a different network.

Hardhat Ignition 🚀

Deploying [ LockModule ]

Batch #1
  Executed LockModule#Lock

[ LockModule ] successfully deployed 🚀

Deployed Addresses

LockModule#Lock - 0x5FbDB2315678afecb367f032d93F642f64180aa3
```

<br><br>

# 连接 Hardhat 网络

默认情况下, Hardhat 在启动时 会在内存中启动一个新的 Hardhat Network 实例. 也可以独立运行 Hardhat Network, 以便外部客户端 (如钱包、Dapp 前端或 Hardhat Ignition 部署) 连接.

执行 `npx hardhat node` 独立运行 Hardhat Network:

```
Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/

Accounts
========

WARNING: These accounts, and their private keys, are publicly known.
Any funds sent to them on Mainnet or any other live network WILL BE LOST.

Account #0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000 ETH)
Private Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

...

Account #19: 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199 (10000 ETH)
Private Key: 0xdf57089febbacf7ba0bc227dafbffa9fc08a93fdc68e1e42411a14efcf23656e

WARNING: These accounts, and their private keys, are publicly known.
Any funds sent to them on Mainnet or any other live network WILL BE LOST.
```

这将向 Hardhat Network 公开一个 JSON-RPC 接口. 要使用它, 需要将您的钱包或应用程序连接到 http://127.0.0.1:8545

如果要连接 Hardhat 到这个节点, 需要使用 `--network localhost`:

```
npx hardhat ignition deploy ./ignition/modules/Lock.js --network localhost
```

<br><br>
