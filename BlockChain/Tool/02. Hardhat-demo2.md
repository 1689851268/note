# 搭建 Hardhat 项目

```
mkdir hardhat-demo
cd hardhat-demo
pnpm init
pnpm i hardhat -D
npx hardhat
```

整理项目结构:

```
hardhat-demo
├── contracts // 合约文件夹
├── ignition // 启动文件夹
│   └── modules
├── test // 测试文件夹
└── hardhat.config.js // 配置文件
```

<br><br>

# 编写并编译合约

1. 创建 contracts/MyERC20.sol:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; // 需要先 pnpm i @openzeppelin/contracts

contract MyERC20 is ERC20 {
    constructor() ERC20("MyERC20", "MY20") {
        _mint(msg.sender, 1000000 * 10 ** decimals());
    }
}
```

这个合约创建了一个简单的 ERC20 代币, 初始供应量为 1,000,000 个代币.

2. 执行 `npx hardhat compile` 编译合约:

```
Compiled 6 Solidity files successfully (evm target: paris).
```

<br><br>

# 编写单元测试

1. 创建 test/MyERC20.js:

```js
// 导入 Chai 的 expect 断言函数, 用于测试断言
const { expect } = require("chai");
// 从 Hardhat 导入 ethers 库, 用于与以太坊交互
const { ethers } = require("hardhat");

// 描述测试套件
describe("MyERC20 合约测试", () => {
    // 定义一个测试用例
    it("合约部署", async () => {
        // 获取测试账户, owner 是部署合约的账户, addr1 和 addr2 是其他测试账户
        const [owner, addr1, addr2] = await ethers.getSigners();

        // 获取 MyERC20 合约的工厂实例
        const Token = await ethers.getContractFactory("MyERC20");

        // 部署 MyERC20 合约
        const hardhatToken = await Token.deploy();

        // 等待合约部署完成
        await hardhatToken.waitForDeployment();

        // 获取部署后的合约地址
        const ContractAddress = hardhatToken.target;

        // 断言: 检查合约地址是否是有效的以太坊地址
        expect(ContractAddress).to.properAddress;
    });
});
```

这里的单元测试非常简单, 仅包含部署合约并测试合约地址是否合法.

2. 执行 `npx hardhat test` 运行测试:

```
  MyERC20 合约测试
    ✔ 合约部署 (933ms)


  1 passing (936ms)
```

`npx hardhat test` 会执行 test 文件夹下所有的测试文件, 如果只想执行上例的 MyERC20.js, 可以使用 `npx hardhat test test/MyERC20.js`

<br><br>

# 调试合约

在 Hardhat Node 节点上运行合约和测试时, 可以在 Solidity 代码中调用 `console.log` 打印日志.

1. 修改 contracts/MyERC20.sol:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "hardhat/console.sol"; // 导入 Hardhat 的 console 模块

contract MyERC20 is ERC20 {
    constructor() ERC20("MyERC20", "MY20") {
        _mint(msg.sender, 1000000 * 10 ** decimals());
        console.log("msg.sender:", msg.sender); // 打印 msg.sender 信息
    }
}
```

2. 执行 `npx hardhat test --grep MyERC20` 运行测试:

```
Compiled 2 Solidity files successfully (evm target: paris).


  MyERC20 合约测试
msg.sender: 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
    ✔ 合约部署 (934ms)


  1 passing (936ms)
```

可以看到, `console.log` 打印的日志会在测试结果中显示.

<br><br>

# 部署合约

其实我们在测试时, 合约已经部署到了 Hardhat 内置的网络上, 部署合约我们需要编写一个部署脚本.

1. 创建 scripts/deploy.js:

```js
const { ethers } = require("hardhat");

async function main() {
    const Contract = await ethers.getContractFactory("MyERC20");
    const token = await Contract.deploy();
    await token.waitForDeployment();
    console.log("成功部署合约:", token.target);
}

// 运行脚本
main().catch((error) => {
    console.error("error:", error);
    process.exitCode = 1;
});
```

2. 执行 `npx hardhat run scripts/deploy.js` 部署合约到本地测试网络:

```shell
msg.sender: 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
成功部署合约: 0x5FbDB2315678afecb367f032d93F642f64180aa3
```

<br><br>

# 部署合约到 Sepolia 测试网络

前置准备:

1.  申请 Infura 的 API Key, 用于连接以太坊网络

2.  到水龙头领取测试代币

3.  导出 MetaMask 私钥

4.  申请 Etherscan 的 API Key, 用于验证合约

配置网络:

1.  修改 hardhat.config.js:

```js
require("@nomicfoundation/hardhat-toolbox");

const INFURA_API_KEY = "YOUR_INFURA_API_KEY";

const META_MASK_PRIVATE_KEY = "YOUR_META_MASK_PRIVATE_KEY";

const ETHERSCAN_API_KEY = "YOUR_ETHERSCAN_API_KEY";

module.exports = {
    solidity: "0.8.27",
    networks: {
        sepolia: {
            url: `https://sepolia.infura.io/v3/${INFURA_API_KEY}`,
            accounts: [META_MASK_PRIVATE_KEY],
        },
    },
    etherscan: {
        apiKey: ETHERSCAN_API_KEY,
    },
};
```

2.  执行 `npx hardhat run scripts/deploy.js --network sepolia` 部署合约到 Sepolia 测试网络:

```shell
msg.sender: 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
成功部署合约: 0xb9b5835239B98691Fbe48ed82787982258DC0A87
```

可以通过 https://sepolia.etherscan.io 查看合约部署情况

<br><br>

# 代码开源验证

```
npx hardhat verify <deployed-contract-address> "参数(若有)" --network <network-name>
```

上述命令会验证已经部署到区块链网络上的智能合约代码与源代码是否匹配. 完成验证后, 在区块链浏览器中的 "Contract" 上会出现 ✅ 标志.

在部署智能合约时, 合约字节码会被写入到区块链中, 这意味着其他人无法检查合约的源代码. 代码验证的过程是将已部署合约的字节码与原始 Solidity 代码再次编译后与部署的字节码进行比较, 确保它们是一致的.

本例执行 `npx hardhat verify 0xb9b5835239B98691Fbe48ed82787982258DC0A87 --network sepolia`

通过代码验证, 项目可以向用户和投资者展示其透明度和诚信, 这对于建立长期信任和社区支持至关重要.

<br><br>
