# Contract

Contract 类是以太坊智能合约的抽象，用于与链上合约交互。

**contract 类型**：

-   只读 contract：

    -   只能读取链上合约信息，即调用合约中的 view 和 pure 函数；不能执行交易

    -   创建时需传入：合约地址、ABI、provider

-   可写 contract：

    -   可以读取和写入链上合约信息；可以执行交易

    -   创建时需传入：合约地址、ABI、signer

**ABI 格式**：

以 sepolia 测试网的 WETH 合约为例：

1.  标准 JSON 格式

```js
// 从 https://sepolia.etherscan.io/address/0x5f207d42f869fd1c71d7f0f81a2a67fc20ff7323#code 获取
const WETHABI = '[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":""...]';
```

2.  Human-Readable ABI（函数签名列表）

```js
const WETHABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint256)",
    "function deposit() payable",
    "function transfer(address to, uint256 value) returns (bool)",
    // 按需填写...
];
```

**创建合约实例**：

先声明前置数据

```js
import { ethers } from "ethers";

const infuraKey = "infuraKey...";
const provider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${infuraKey}`);

const privateKey = "钱包账户的私钥...";
const wallet = new ethers.Wallet(privateKey, provider);

// sepolia 测试网的 WETH 合约地址
const WETHAddress = "0x5f207d42F869fd1c71d7f0f81a2A67Fc20FF7323";
```

1.  创建只读合约：

```js
const readableWETHContract = new ethers.Contract(WETHAddress, WETHABI, provider);
```

2. 创建可写合约：

```js
// 方法 1:
const writableWETHContract = new ethers.Contract(WETHAddress, WETHABI, wallet);
// 方法 2:
const writableWETHContract = readableWETHContract.connect(wallet);
```

**合约交互**：

我们可以使用 readableWETHContract 调用合约的 view / pure 函数，以获取合约信息 (不需要 gas) ：

```js
const WETHName = await readableWETHContract.name();
console.log(`名称: ${WETHName}`);

const WETHSymbol = await readableWETHContract.symbol();
console.log(`代号: ${WETHSymbol}`);

const WETHTotalSupply = await readableWETHContract.totalSupply();
console.log(`总供给: ${ethers.utils.formatEther(WETHTotalSupply)} ether`);

const WETHBalance = await readableWETHContract.balanceOf("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
console.log(`Vitalik 持仓: ${ethers.utils.formatEther(WETHBalance)} ether`);
```

我们可以使用 writableWETHContract 调用合约函数，以获取合约信息 (不需要 gas) / 执行交易 (需要 gas) ：

```js
const balance1 = await writableWETHContract.balanceOf(wallet.address);
console.log(`WETH 余额: ${ethers.utils.formatEther(balance1)} ether`);

// 调用 WETH 合约的 deposit 方法, 将 0.01 ETH 转换为 WETH
const tx1 = await writableWETHContract.deposit({ value: ethers.utils.parseEther("0.01") });
await tx1.wait(); // 等待链上确认
console.log("deposit tx1:", JSON.stringify(tx1, null, 4));
// { "type": 2, "gasPrice": null, "gasLimit": ..., "to": ..., "value": ..., "hash": ..., ... }

const balance2 = await writableWETHContract.balanceOf(wallet.address);
console.log(`WETH 余额: ${ethers.utils.formatEther(balance2)} ether`);

// 调用 WETH 合约的 transfer 方法, 将 0.001 WETH 转账给另一个地址
const tx2 = await writableWETHContract.transfer("0x ...", ethers.utils.parseEther("0.001"));
await tx2.wait(); // 等待链上确认
console.log("transfer tx2:", JSON.stringify(tx2, null, 4));
// { "type": 2, "gasPrice": null, "gasLimit": ..., "to": ..., "value": ..., "hash": ..., ... }

const balance3 = await writableWETHContract.balanceOf(wallet.address);
console.log(`WETH 余额: ${ethers.utils.formatEther(balance3)} ether`);
```

注意事项：

1.  view / pure 函数会直接返回执行结果，其他函数则返回交易信息。

2.  如需获取其他函数的执行结果，需使用 Event。

3.  如需知晓函数执行过程中合约变量的变化，也需使用 Event。

<br><br>

# ContractFactory

在以太坊上，智能合约的部署是一种特殊的交易：将编译后的合约字节码发送到 0 地址。如果合约构造函数有参数，需要用 abi.encode 将参数编码为字节码，并附加到合约字节码末尾。

EthersJS 提供了 ContractFactory 类，简化了合约部署过程。

1. 创建合约工厂实例

```js
const contractFactory = new ethers.ContractFactory(abi, bytecode, signer);
```

注意：如果合约的构造函数有参数，那么在 abi 中必须包含构造函数。

2. 部署合约

创建好合约工厂实例后，可以调用它的 deploy 方法并传入合约构造函数的参数 args 来部署并获取合约实例

```js
const contractInstance = await contractFactory.deploy(...args);
```

3. 等待合约部署

```js
await contractInstance.deployed();
// 或
await contractInstance.deployTransaction.wait();
```

**demo - 部署 ERC20 代币合约**：

1. 创建 provider 和 wallet

```js
import { ethers } from "ethers";

const infuraKey = "infuraKey...";
const provider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${infuraKey}`);

const privateKey = "钱包账户的私钥...";
const wallet = new ethers.Wallet(privateKey, provider);
```

2. 准备 ERC20 合约 ABI 和字节码

因为 ERC20 的构造函数含有参数，因此我们必须把构造函数包含在 ABI 中。

合约的字节码可以从 remix 的编译面板中点击 Bytecode 按钮，把它复制下来。如果是部署在链上的合约，可以在 Etherscan 的 Contract 页面的 Contract Creation Code 中找到。

```js
const ERC20ABI = [
    "constructor(string memory name_, string memory symbol_)",
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint)",
    "function transfer(address to, uint256 amount) external returns (bool)",
    "function mint(uint amount) external",
];

const ERC20Bytecode = "6080604052...";
```

3. 创建合约工厂实例

```js
const ERC20Factory = new ethers.ContractFactory(ERC20ABI, ERC20Bytecode, wallet);
```

4. 调用工厂合约的 deploy 函数并填入构造函数的参数 (代币名称和代号)，部署 ERC20 代币合约并获得合约实例

```js
const ERC20Contract = await ERC20Factory.deploy("MyToken", "MTK");
await ERC20Contract.deployed(); // 等待合约部署在链上确认
console.log(`ERC20 合约信息: ${JSON.stringify(ERC20Contract, null, 4)}`);
```

5. 合约上链后，可以查看合约信息

```js
const name = await ERC20Contract.name();
console.log(`name: ${name}`);
const symbol = await ERC20Contract.symbol();
console.log(`symbol: ${symbol}`);
const address = ERC20Contract.address;
console.log(`address: ${address}`);
```

6.  调用 mint 函数给自己铸造 10,000 枚代币

```js
const mintTx = await ERC20Contract.mint(10000);
await mintTx.wait(); // 等待链上确认
console.log("mintTx:", JSON.stringify(mintTx, null, 4));

const balance1 = await ERC20Contract.balanceOf(wallet.address);
console.log(`钱包余额: ${ethers.utils.formatEther(balance1)} ether`);
```

7.  调用 transfer 函数，将 1,000 枚代币转账给另一个地址

```js
const tx = await ERC20Contract.transfer("0x ...", ethers.utils.parseEther("1000"));
await tx.wait(); // 等待链上确认
console.log("tx:", JSON.stringify(tx, null, 4));

const balance2 = await ERC20Contract.balanceOf(wallet.address);
console.log(`钱包余额: ${ethers.utils.formatEther(balance2)} ether`);
```

<br><br>
