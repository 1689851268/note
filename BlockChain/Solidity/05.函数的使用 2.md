# Event

事件 (Event) 的用途：

-   事件可以用于记录交易日志，帮助调试和监控合约的运行状态。
-   外部应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件，从而在事件发生时执行相应的操作。

```solidity
contract Demo {
    event Transfer(address indexed from, address indexed to, uint value); // 定义事件

    function transfer(address _to, uint _value) public {
        emit Transfer(msg.sender, _to, _value); // 触发事件
    }
}
```

索引参数：

-   事件参数可以使用 `indexed` 关键字进行索引，最多可以索引三个参数。
-   索引参数可以加快事件的搜索和过滤。

监听事件：

-   eg：外部应用程序（如 DApp）可以使用 Web3.js 等库来监听和处理事件。

```javascript
const event = contractInstance.Transfer();
event.watch(function (error, result) {
    if (!error) {
        console.log(result.args.from, result.args.to, result.args.value);
    }
});
```

<br><br>

# Library

库（Library）用于定义常用的功能函数，能在多个合约中复用。

1.  库不能定义状态变量

2.  库不能继承其他合约，也不能被其他合约继承

3.  库不能接收以太币

4.  推荐使用 internal 修饰 Library 的方法

使用方式 1：

```solidity
library Math {
    function max(uint a, uint b) internal pure returns (uint) {
        return a >= b ? a : b;
    }
}

contract Test {
    function test() public pure returns (uint) {
        return Math.max(1, 2); // 通过库名 Math 调用里面的方法 max
    }
}
```

使用方式 2：

```solidity
library ArrayLib {
    function findIndex(
        uint[] memory arr,
        uint value
    ) internal pure returns (int) {
        for (uint i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return int(i);
            }
        }
        return -1;
    }
}

contract Test {
    using ArrayLib for uint[]; // 通过库名 ArrayLib 增强类型 uint[]

    uint[] public arr = [1, 2, 3, 4, 5];

    function findIndex(uint value) public view returns (int) {
        return arr.findIndex(value); // uint[] 类型的变量可直接调用 ArrayLib 里面的方法 findIndex
    }
}
```

<br><br>

# 流程控制

if-else：

```solidity
function testIf(uint a, uint b) public pure returns (uint) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

三元运算符：

```solidity
function testTernary(uint a, uint b) public pure returns (uint) {
    return a > b ? a : b;
}
```

注意：Solidity 不支持 switch-case 语句

<br>

for 循环：

```solidity
function forLoop() public pure returns (uint) {
    uint sum = 0;
    for (uint i = 0; i < 10; i++) {
        if (i == 3) continue;
        if (i == 5) break;
        sum += i;
    }
    return sum;
}
```

while 循环：

```solidity
function whileLoop() public pure returns (uint) {
    uint sum = 0;
    uint i = 0;
    while (i < 10) {
        if (i == 3) {
            i++;
            continue;
        }
        if (i == 5) break;
        sum += i;
        i++;
    }
    return sum;
}
```

do while 循环：

```solidity
function doWhileLoop() public pure returns (uint) {
    uint sum = 0;
    uint i = 0;
    do {
        if (i == 3) { i++; continue; }
        if (i == 5) break;
        sum += i;
        i++;
    } while (i < 10);
    return sum;
}
```

关键字 continue、break 也可以在 Solidity 中使用。

<br><br>

# Gas Golf

Gas Golf 表示一些优化智能合约的手段，以减少 gas 消耗。

gas 是执行交易和智能合约所需的计算资源的度量单位。通过优化代码，可以显著降低交易成本，提高合约效率。

以下是一些常见的 gas 优化技巧：

1. **使用 calldata 代替 memory**

calldata 表示只读的数据位置，适用于函数参数。

```solidity
function example(uint[] calldata nums) external {
    // 使用 calldata 代替 memory
}
```

2. **使用前置递增运算符**

在循环中，使用 `++i` 代替 `i++` 可以节省 gas 。

```solidity
for (uint i = 0; i < nums.length; ++i) {
    // 使用 ++i 代替 i++
}
```

3. **短路求值**

在逻辑运算中，使用短路求值可以避免不必要的计算，从而节省 gas 。

```solidity
if (condition1 && condition2) {
    // 如果 condition1 为 false，则不会计算 condition2
}
```

4. **使用 unchecked 块**

Solidity 0.8.0 之后，会自动检查数学运算是否溢出。这提高了代码安全性，但也增加了 gas 消耗。如果你确定不会溢出且想节省 gas，可以使用 `unchecked` 跳过检查：

```solidity
function checkedAdd(uint8 a, uint8 b) public pure returns (uint8) {
    return a + b; // 如果 a + b 溢出, 会抛出异常并回滚
}

function uncheckedAdd(uint8 a, uint8 b) public pure returns (uint8) {
    unchecked {
        return a + b; // 如果 a + b 溢出, 会截断结果并返回
    }
}
```

5. **将常访问的值缓存到内存中**

```solidity
uint[] public nums;

function example() external view {
    uint[] memory _nums = nums; // 1️⃣ 缓存常访问的状态变量
    uint len = _nums.length; // 2️⃣ 缓存数组长度
    for (uint i = 0; i < nums.length; i++) {
        uint num = nums[i]; // 3️⃣ 存储尝访问的数组元素
    }
}
```

**demo**：

```solidity
// 未优化的代码
function sumIfEvenAndLessThan99(uint[] memory nums) external {
    for (uint i = 0; i < nums.length; i++) {
        bool isEven = nums[i] % 2 == 0;
        bool isLessThan99 = nums[i] < 99;
        if (isEven && isLessThan99) {
            total += nums[i];
        }
    }
}

// 优化后的代码
function sumIfEvenAndLessThan99(uint[] calldata nums) external {
    uint _total = total;
    uint len = nums.length;
    for (uint i = 0; i < len;) {
        uint num = nums[i];
        if (num % 2 == 0 && num < 99) {
            _total += num;
        }
        unchecked {
            ++i;
        }
    }
    total = _total;
}
```

<br><br>
