# 信息传输

发送方 A:

1. 计算消息 message 的哈希值 H: `hash(message) = H`

2. 私钥 privateKey ➕ 哈希值 H 🟰 签名 signature: `signature = sign(H, privateKey)`

3. 将消息 message 和签名 signature 发送给 B

接收方 B:

1. 计算消息 message 的哈希值 H1: `hash(message) = H1`

2. 公钥 publicKey ➕ 签名 signature 🟰 H2: `H2 = verify(signature, publicKey)`

3. 比较 H1 和 H2, 如果相等 则说明消息未被篡改且确实来自 A

<br><br>

# Keccak256 函数

```solidity
contract HashFunc {
    function hash(
        string memory _testString,
        uint _testUint
    ) public pure returns (bytes32) {
    	// 先对数据进行编码, 再用 keccak256 加密
        return keccak256(abi.encodePacked(_testString, _testUint));
    }
}
```

encodePacked 方法可以对多个参数进行编码, 并压缩编码后的结果, 节省 gas. 但某些情况下会导致哈希碰撞 (哈希冲突).

为了避免哈希碰撞, 可以使用 encode 方法, 它不会压缩编码结果, 但会消耗更多 gas.

```solidity
contract HashFunc {
    function hash(
        string memory _testString,
        uint _testUint
    ) public pure returns (bytes32) {
        // 使用 encode 方法避免哈希碰撞
        return keccak256(abi.encode(_testString, _testUint));
    }
}
```

除了使用 encode 方法, 还可以在 encodePacked 的入参之间插入一个参数, 这样也能避免哈希碰撞.

```solidity
contract HashFunc {
    function hash(
        string memory _string1,
        uint _uint, // 用来避免哈希碰撞的参数
        string memory _string2
    ) public pure returns (bytes32) {
        // 在 encodePacked 的入参之间再插入一个参数, 避免哈希碰撞
        return keccak256(abi.encodePacked(_string1, _uint, _string2));
    }
}
```

<br><br>

# 签名与验证

```solidity
contract VerifySig {
    // 将一个 65 字节长的签名拆分成 r,s,v 三个部分
    function split(
        bytes memory _signature
    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(_signature.length == 65, "invalid signature length");
        assembly {
            // 从 _signature 的第 32 字节开始加载 32 字节的数据, 并将其赋值给 r
            // `从 _signature 的第 32 字节开始` 是因为前 32 字节是 _signature 的长度信息, 从 32 字节开始才是真正的签名数据
            r := mload(add(_signature, 32))
            // 从 _signature 的第 64 字节开始加载 32 字节的数据, 并将其赋值给 s
            s := mload(add(_signature, 64))
            // 从 _signature 的第 96 字节开始加载 32 字节的数据, 并取其第 1 个字节给 v
            v := byte(0, mload(add(_signature, 96)))
            // 在以太坊中, 签名通过椭圆曲线数字签名算法 (ECDSA, Elliptic Curve Digital Signature Algorithm) 创建
            // 其中 r s 是签名的一部分, v 是签名的恢复因子 (为 27 / 28), 用于恢复签名者的公钥
        }
    }

    // 计算给定消息的哈希值
    function getMessageHash(
        string memory _message
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_message));
    }

    // 生成一个符合以太坊签名标准的消息哈希值
    function getEthSignedMessageHash(
        bytes32 _messageHash
    ) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    "\x19Ethereum Signed Message:\n32",
                    // 这是一个固定的前缀, 用于防止签名重用攻击
                    // 这个前缀告诉以太坊客户端这是一个签名消息, 而不是交易或其他数据
                    // \x19 表示消息的长度;  32 表示消息哈希的长度为 32 字节
                    _messageHash
                )
            );
    }

    // 从签名中恢复出签名者的地址
    function recover(
        bytes32 _ethSignedMessageHash,
        bytes memory _signature
    ) public pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = split(_signature);
        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    // 验证消息的有效性 (签名者是否正确,消息是否被篡改)
    function verify(
        address _signer,
        string memory _message,
        bytes memory _signature
    ) public pure returns (bool) {
        bytes32 messageHash = getMessageHash(_message);
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);
        return recover(ethSignedMessageHash, _signature) == _signer;
    }
}
```

**部署合约并测试**:

模拟发送方 A:

1. 将要发送的消息作为参数传入 getMessageHash 方法, 得到消息的哈希值 H, 这里以字符串 "hello" 为例

2. F12 打开控制台, 执行 `ethereum.enable()`; 查看 Promise, 若为 fulfilled 状态则说明 MetaMask 已连接, 可查看 Promise 结果得到 MetaMask 的账号地址 (需要先安装 MetaMask 插件并登录)

3. 执行 `ethereum.request({ method: "personal_sign", params: [步骤 2 得到的 MetaMask 账号地址, 步骤 1 得到的哈希值 H] })`, 会弹出签名框, 点击 sign 进行签名; 查看 Promise, 若为 fulfilled 状态则说明签名成功, 可查看 Promise 结果得到签名 signature

4. 假设 A 将步骤 3 得到的签名 signature 和消息 "hello" 发送给了 B

模拟接收方 B:

1. 将收到的消息 "hello" 作为参数传入 getMessageHash 方法, 得到消息的哈希值

2. 将步骤 1 得到的哈希值作为参数传入 getEthSignedMessageHash 方法, 得到符合以太坊签名标准的消息哈希值 H1

3. 将步骤 2 得到的消息哈希值和收到的签名 signature 作为参数传入 recover 方法, 得到签名者的地址; 比对是否为 A 步骤 2 得到的 MetaMask 账号地址, 如果不一致 则说明信息被篡改 / 消息不是来自 A

步骤 1 2 3 即为 verify 方法的逻辑, 可直接调用 verify 方法进行验证

<br><br>

# 访问控制

```solidity
contract AccessControl {
    // 定义两个角色
    bytes32 public constant ROLE_ADMIN =
        keccak256(abi.encodePacked("ROLE_ADMIN"));
    bytes32 public constant ROLE_USER =
        keccak256(abi.encodePacked("ROLE_USER"));

    // 定义一个双重映射, 用于管理 "角色 - 用户 - 权限"
    mapping(bytes32 => mapping(address => bool)) public roles;

    // 分配权限
    function _grantRole(bytes32 _role, address _account) internal {
        roles[_role][_account] = true;
    }

    // 撤销权限
    function _revokeRole(bytes32 _role, address _account) internal {
        roles[_role][_account] = false;
    }

    // 构造函数
    constructor() {
        _grantRole(ROLE_ADMIN, msg.sender);
    }

    // 函数装饰器, 限制函数仅管理员能调用
    modifier onlyAdmin() {
        require(
            roles[ROLE_ADMIN][msg.sender],
            "AccessControl: sender must be an admin to perform this action"
        );
        _;
    }

    // 分配权限 (外部使用, 仅管理员能调用)
    function grantUserRole(address _account) public onlyAdmin {
        _grantRole(ROLE_USER, _account);
    }

    // 撤销权限 (外部使用, 仅管理员能调用)
    function revokeUserRole(address _account) public onlyAdmin {
        _revokeRole(ROLE_USER, _account);
    }
}
```

1. 部署合约, 部署者将成为管理员

2. 获取编辑器地址和 ROLE_ADMIN 的哈希值, 填入 roles 中查看权限, 此处应为 true

3. 更新编辑器地址, 获取新的编辑器地址和 ROLE_USER 的哈希值, 填入 roles 中查看权限, 此处应为 false

4. 传入新的编辑器地址, 使用管理员地址调用 grantUserRole 方法, 授权新的编辑器地址为 ROLE_USER

5. 获取新的编辑器地址和 ROLE_USER 的哈希值, 填入 roles 中查看权限, 此处应为 true

6. 传入新的编辑器地址, 使用管理员地址调用 revokeUserRole 方法, 取消新的编辑器地址的 ROLE_USER 权限

7. 获取新的编辑器地址和 ROLE_USER 的哈希值, 填入 roles 中查看权限, 此处应为 false

8. 不使用管理员地址调用 grantUserRole 方法, 会报错

<br><br>

# 利用签名发放白名单

NFT 项目方可以使用 ECDSA 发放白名单. 由于签名是链下的, 不需要 gas, 因此这种白名单发放模式比 Merkle Tree 模式还要经济. 方法非常简单, 项目方利用项目方账户把白名单发放地址签名 (可以加上地址可以铸造的 tokenId). 然后 mint 的时候利用 ECDSA 检验签名是否有效, 如果有效, 则给他 mint.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

// 引入 OpenZeppelin 的 ERC721 合约
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

// 定义 ECDSA 库, 用于处理签名相关的操作
library ECDSA {
    // 生成消息哈希
    function getMessageHash(
        address _account,
        uint256 _tokenId
    ) external pure returns (bytes32) {
        // 使用 keccak256 对账户地址和 tokenId 进行哈希
        return keccak256(abi.encodePacked(_account, _tokenId));
    }

    // 将消息哈希转换为以太坊签名消息格式
    function toEthSignedMessageHash(
        bytes32 hash
    ) external pure returns (bytes32) {
        // 使用 keccak256 对特定前缀和哈希进行哈希
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
            );
    }

    // 从签名中恢复签名者地址
    function recoverSigner(
        bytes32 _msgHash,
        bytes memory _signature
    ) private pure returns (address) {
        // 确保签名长度为 65 字节
        require(_signature.length == 65, "invalid signature length");
        bytes32 r;
        bytes32 s;
        uint8 v;
        // 使用内联汇编从签名中提取 r, s, v 值
        assembly {
            r := mload(add(_signature, 0x20))
            s := mload(add(_signature, 0x40))
            v := byte(0, mload(add(_signature, 0x60)))
        }
        // 使用 ecrecover 恢复签名者地址
        return ecrecover(_msgHash, v, r, s);
    }

    // 验证签名是否由指定的签名者签署
    function verify(
        bytes32 _msgHash,
        bytes memory _signature,
        address _signer
    ) external pure returns (bool) {
        // 比较恢复出的地址和提供的签名者地址是否一致
        return recoverSigner(_msgHash, _signature) == _signer;
    }
}

// 定义 SignatureNFT 合约, 继承自 ERC721
contract SignatureNFT is ERC721 {
    // 签名者地址
    address public immutable signer;
    // 记录已经铸造过 NFT 的地址
    mapping(address => bool) public mintedAddress;

    // 构造函数, 初始化合约
    constructor(
        string memory _name,
        string memory _symbol,
        address _signer
    ) ERC721(_name, _symbol) {
        signer = _signer;
    }

    // 验证签名
    function verify(
        bytes32 _msgHash,
        bytes memory _signature
    ) public view returns (bool) {
        // 调用 ECDSA 库的 verify 函数进行验证
        return ECDSA.verify(_msgHash, _signature, signer);
    }

    // 铸造 NFT
    function mint(
        address _account,
        uint256 _tokenId,
        bytes memory _signature
    ) external {
        // 生成消息哈希
        bytes32 _msgHash = ECDSA.getMessageHash(_account, _tokenId);
        // 转换为以太坊签名消息格式
        bytes32 _ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_msgHash);
        // 验证签名
        require(verify(_ethSignedMessageHash, _signature), "Invalid signature");
        // 确保地址未铸造过 NFT
        require(!mintedAddress[_account], "Already minted!");
        // 铸造 NFT
        _mint(_account, _tokenId);
        // 记录地址已铸造
        mintedAddress[_account] = true;
    }
}
```

1. 部署合约, 传入 NFT 的名称, 代号和签名者地址
2. 使用签名者地址调用 mint 方法, 传入铸造地址, tokenId 和签名
3. 查看铸造地址的 NFT 余额, 应为 1
4. 使用其他地址调用 mint 方法, 传入铸造地址, tokenId 和签名, 会报错
