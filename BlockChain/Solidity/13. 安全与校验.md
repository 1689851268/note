# ä¿¡æ¯ä¼ è¾“

å‘é€æ–¹ A:

1. è®¡ç®—æ¶ˆæ¯ message çš„å“ˆå¸Œå€¼ H: `hash(message) = H`

2. ç§é’¥ privateKey â• å“ˆå¸Œå€¼ H ğŸŸ° ç­¾å signature: `signature = sign(H, privateKey)`

3. å°†æ¶ˆæ¯ message å’Œç­¾å signature å‘é€ç»™ B

æ¥æ”¶æ–¹ B:

1. è®¡ç®—æ¶ˆæ¯ message çš„å“ˆå¸Œå€¼ H1: `hash(message) = H1`

2. å…¬é’¥ publicKey â• ç­¾å signature ğŸŸ° H2: `H2 = verify(signature, publicKey)`

3. æ¯”è¾ƒ H1 å’Œ H2, å¦‚æœç›¸ç­‰ åˆ™è¯´æ˜æ¶ˆæ¯æœªè¢«ç¯¡æ”¹ä¸”ç¡®å®æ¥è‡ª A

<br><br>

# Keccak256 å“ˆå¸Œå‡½æ•°

```solidity
contract HashFunc {
    function hash(
        string memory _testString,
        uint _testUint
    ) public pure returns (bytes32) {
    	// å…ˆå¯¹æ•°æ®è¿›è¡Œç¼–ç , å†ç”¨ keccak256 åŠ å¯†
        return keccak256(abi.encodePacked(_testString, _testUint));
    }
}
```

encodePacked æ–¹æ³•å¯ä»¥å¯¹å¤šä¸ªå‚æ•°è¿›è¡Œç¼–ç , å¹¶å‹ç¼©ç¼–ç åçš„ç»“æœ, èŠ‚çœ gas è´¹ç”¨. ä½†æŸäº›æƒ…å†µä¸‹ä¼šå¯¼è‡´å“ˆå¸Œç¢°æ’ (å“ˆå¸Œå†²çª).

ä¸ºäº†é¿å…å“ˆå¸Œç¢°æ’, å¯ä»¥ä½¿ç”¨ encode æ–¹æ³•, å®ƒä¸ä¼šå‹ç¼©ç¼–ç ç»“æœ, ä½†ä¼šæ¶ˆè€—æ›´å¤š gas .

```solidity
contract HashFunc {
    function hash(
        string memory _testString,
        uint _testUint
    ) public pure returns (bytes32) {
        // ä½¿ç”¨ encode æ–¹æ³•é¿å…å“ˆå¸Œç¢°æ’
        return keccak256(abi.encode(_testString, _testUint));
    }
}
```

é™¤äº†ä½¿ç”¨ encode æ–¹æ³•, è¿˜å¯ä»¥åœ¨ encodePacked çš„å…¥å‚ä¹‹é—´æ’å…¥ä¸€ä¸ªå‚æ•°, è¿™æ ·ä¹Ÿèƒ½é¿å…å“ˆå¸Œç¢°æ’.

```solidity
contract HashFunc {
    function hash(
        string memory _string1,
        uint _uint, // ç”¨æ¥é¿å…å“ˆå¸Œç¢°æ’çš„å‚æ•°
        string memory _string2
    ) public pure returns (bytes32) {
        // åœ¨ encodePacked çš„å…¥å‚ä¹‹é—´å†æ’å…¥ä¸€ä¸ªå‚æ•°, é¿å…å“ˆå¸Œç¢°æ’
        return keccak256(abi.encodePacked(_string1, _uint, _string2));
    }
}
```

<br><br>

# ç­¾åä¸éªŒè¯

```solidity
contract VerifySig {
    // å°†ä¸€ä¸ª 65 å­—èŠ‚é•¿çš„ç­¾åæ‹†åˆ†æˆ rã€s å’Œ v ä¸‰ä¸ªéƒ¨åˆ†
    function split(
        bytes memory _signature
    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(_signature.length == 65, "invalid signature length");
        assembly {
            // ä» _signature çš„ç¬¬ 32 å­—èŠ‚å¼€å§‹åŠ è½½ 32 å­—èŠ‚çš„æ•°æ®, å¹¶å°†å…¶èµ‹å€¼ç»™ r
            // è¿™æ˜¯å› ä¸ºå‰ 32 å­—èŠ‚æ˜¯ _signature çš„é•¿åº¦ä¿¡æ¯, ä» 32 å­—èŠ‚å¼€å§‹æ‰æ˜¯çœŸæ­£çš„ç­¾åæ•°æ®
            r := mload(add(_signature, 32))
            // ä» _signature çš„ç¬¬ 64 å­—èŠ‚å¼€å§‹åŠ è½½ 32 å­—èŠ‚çš„æ•°æ®, å¹¶å°†å…¶èµ‹å€¼ç»™ s
            s := mload(add(_signature, 64))
            // ä» _signature çš„ç¬¬ 96 å­—èŠ‚å¼€å§‹åŠ è½½ 32 å­—èŠ‚çš„æ•°æ®, å¹¶å–å…¶ç¬¬ 1 ä¸ªå­—èŠ‚ç»™ v
            v := byte(0, mload(add(_signature, 96)))
            // åœ¨ä»¥å¤ªåŠä¸­, ç­¾åé€šè¿‡æ¤­åœ†æ›²çº¿æ•°å­—ç­¾åç®—æ³• (ECDSA, Elliptic Curve Digital Signature Algorithm) åˆ›å»º
            // å…¶ä¸­ r s æ˜¯ç­¾åçš„ä¸€éƒ¨åˆ†, v æ˜¯ç­¾åçš„æ¢å¤å› å­ (ä¸º 27 / 28), ç”¨äºæ¢å¤ç­¾åè€…çš„å…¬é’¥
        }
    }

    // è®¡ç®—ç»™å®šæ¶ˆæ¯çš„å“ˆå¸Œå€¼
    function getMessageHash(
        string memory _message
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_message));
    }

    // ç”Ÿæˆä¸€ä¸ªç¬¦åˆä»¥å¤ªåŠç­¾åæ ‡å‡†çš„æ¶ˆæ¯å“ˆå¸Œå€¼
    function getEthSignedMessageHash(
        bytes32 _messageHash
    ) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    "\x19Ethereum Signed Message:\n32",
                    // è¿™æ˜¯ä¸€ä¸ªå›ºå®šçš„å‰ç¼€, ç”¨äºé˜²æ­¢ç­¾åé‡ç”¨æ”»å‡»
                    // è¿™ä¸ªå‰ç¼€å‘Šè¯‰ä»¥å¤ªåŠå®¢æˆ·ç«¯è¿™æ˜¯ä¸€ä¸ªç­¾åæ¶ˆæ¯, è€Œä¸æ˜¯äº¤æ˜“æˆ–å…¶ä»–æ•°æ®
                    // \x19 è¡¨ç¤ºæ¶ˆæ¯çš„é•¿åº¦;  32 è¡¨ç¤ºæ¶ˆæ¯å“ˆå¸Œçš„é•¿åº¦ä¸º 32 å­—èŠ‚
                    _messageHash
                )
            );
    }

    // ä»ç­¾åä¸­æ¢å¤å‡ºç­¾åè€…çš„åœ°å€
    function recover(
        bytes32 _ethSignedMessageHash,
        bytes memory _signature
    ) public pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = split(_signature);
        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    // éªŒè¯æ¶ˆæ¯çš„æœ‰æ•ˆæ€§ (ç­¾åè€…æ˜¯å¦æ­£ç¡®ã€æ¶ˆæ¯æ˜¯å¦è¢«ç¯¡æ”¹)
    function verify(
        address _signer,
        string memory _message,
        bytes memory _signature
    ) public pure returns (bool) {
        bytes32 messageHash = getMessageHash(_message);
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);
        return recover(ethSignedMessageHash, _signature) == _signer;
    }
}
```

**éƒ¨ç½²åˆçº¦å¹¶æµ‹è¯•**:

æ¨¡æ‹Ÿå‘é€æ–¹ A:

1. å°†è¦å‘é€çš„æ¶ˆæ¯ä½œä¸ºå‚æ•°ä¼ å…¥ getMessageHash æ–¹æ³•, å¾—åˆ°æ¶ˆæ¯çš„å“ˆå¸Œå€¼ H, è¿™é‡Œä»¥å­—ç¬¦ä¸² "hello" ä¸ºä¾‹

2. F12 æ‰“å¼€æ§åˆ¶å°, æ‰§è¡Œ `ethereum.enable()`; æŸ¥çœ‹ Promise, è‹¥ä¸º fulfilled çŠ¶æ€åˆ™è¯´æ˜ MetaMask å·²è¿æ¥, å¯æŸ¥çœ‹ Promise ç»“æœå¾—åˆ° MetaMask çš„è´¦å·åœ°å€ï¼ˆéœ€è¦å…ˆå®‰è£… MetaMask æ’ä»¶å¹¶ç™»å½•ï¼‰

3. æ‰§è¡Œ `ethereum.request({ method: "personal_sign", params: [æ­¥éª¤ 2 å¾—åˆ°çš„ MetaMask è´¦å·åœ°å€, æ­¥éª¤ 1 å¾—åˆ°çš„å“ˆå¸Œå€¼ H] })`, ä¼šå¼¹å‡ºç­¾åæ¡†, ç‚¹å‡» sign è¿›è¡Œç­¾å; æŸ¥çœ‹ Promise, è‹¥ä¸º fulfilled çŠ¶æ€åˆ™è¯´æ˜ç­¾åæˆåŠŸ, å¯æŸ¥çœ‹ Promise ç»“æœå¾—åˆ°ç­¾å signature

4. å‡è®¾ A å°†æ­¥éª¤ 3 å¾—åˆ°çš„ç­¾å signature å’Œæ¶ˆæ¯ "hello" å‘é€ç»™äº† B

æ¨¡æ‹Ÿæ¥æ”¶æ–¹ B:

1. å°†æ”¶åˆ°çš„æ¶ˆæ¯ "hello" ä½œä¸ºå‚æ•°ä¼ å…¥ getMessageHash æ–¹æ³•, å¾—åˆ°æ¶ˆæ¯çš„å“ˆå¸Œå€¼

2. å°†æ­¥éª¤ 1 å¾—åˆ°çš„å“ˆå¸Œå€¼ä½œä¸ºå‚æ•°ä¼ å…¥ getEthSignedMessageHash æ–¹æ³•, å¾—åˆ°ç¬¦åˆä»¥å¤ªåŠç­¾åæ ‡å‡†çš„æ¶ˆæ¯å“ˆå¸Œå€¼ H1

3. å°†æ­¥éª¤ 2 å¾—åˆ°çš„æ¶ˆæ¯å“ˆå¸Œå€¼å’Œæ”¶åˆ°çš„ç­¾å signature ä½œä¸ºå‚æ•°ä¼ å…¥ recover æ–¹æ³•, å¾—åˆ°ç­¾åè€…çš„åœ°å€; æ¯”å¯¹æ˜¯å¦ä¸º A æ­¥éª¤ 2 å¾—åˆ°çš„ MetaMask è´¦å·åœ°å€, å¦‚æœä¸ä¸€è‡´ åˆ™è¯´æ˜ä¿¡æ¯è¢«ç¯¡æ”¹ / æ¶ˆæ¯ä¸æ˜¯æ¥è‡ª A

æ­¥éª¤ 1 2 3 å³ä¸º verify æ–¹æ³•çš„é€»è¾‘, å¯ç›´æ¥è°ƒç”¨ verify æ–¹æ³•è¿›è¡ŒéªŒè¯

<br><br>

# è®¿é—®æ§åˆ¶

```solidity
contract AccessControl {
    // å®šä¹‰ä¸¤ä¸ªè§’è‰²
    bytes32 public constant ROLE_ADMIN =
        keccak256(abi.encodePacked("ROLE_ADMIN"));
    bytes32 public constant ROLE_USER =
        keccak256(abi.encodePacked("ROLE_USER"));

    // å®šä¹‰ä¸€ä¸ªåŒé‡æ˜ å°„, ç”¨äºç®¡ç† "è§’è‰² - ç”¨æˆ· - æƒé™"
    mapping(bytes32 => mapping(address => bool)) public roles;

    // åˆ†é…æƒé™
    function _grantRole(bytes32 _role, address _account) internal {
        roles[_role][_account] = true;
    }

    // æ’¤é”€æƒé™
    function _revokeRole(bytes32 _role, address _account) internal {
        roles[_role][_account] = false;
    }

    // æ„é€ å‡½æ•°
    constructor() {
        _grantRole(ROLE_ADMIN, msg.sender);
    }

    // å‡½æ•°è£…é¥°å™¨, é™åˆ¶å‡½æ•°ä»…ç®¡ç†å‘˜èƒ½è°ƒç”¨
    modifier onlyAdmin() {
        require(
            roles[ROLE_ADMIN][msg.sender],
            "AccessControl: sender must be an admin to perform this action"
        );
        _;
    }

    // åˆ†é…æƒé™ (å¤–éƒ¨ä½¿ç”¨, ä»…ç®¡ç†å‘˜èƒ½è°ƒç”¨)
    function grantUserRole(address _account) public onlyAdmin {
        _grantRole(ROLE_USER, _account);
    }

    // æ’¤é”€æƒé™ (å¤–éƒ¨ä½¿ç”¨, ä»…ç®¡ç†å‘˜èƒ½è°ƒç”¨)
    function revokeUserRole(address _account) public onlyAdmin {
        _revokeRole(ROLE_USER, _account);
    }
}
```

1. éƒ¨ç½²åˆçº¦, éƒ¨ç½²è€…å°†æˆä¸ºç®¡ç†å‘˜

2. è·å–ç¼–è¾‘å™¨åœ°å€å’Œ ROLE_ADMIN çš„å“ˆå¸Œå€¼, å¡«å…¥ roles ä¸­æŸ¥çœ‹æƒé™, æ­¤å¤„åº”ä¸º true

3. æ›´æ–°ç¼–è¾‘å™¨åœ°å€, è·å–æ–°çš„ç¼–è¾‘å™¨åœ°å€å’Œ ROLE_USER çš„å“ˆå¸Œå€¼, å¡«å…¥ roles ä¸­æŸ¥çœ‹æƒé™, æ­¤å¤„åº”ä¸º false

4. ä¼ å…¥æ–°çš„ç¼–è¾‘å™¨åœ°å€, ä½¿ç”¨ç®¡ç†å‘˜åœ°å€è°ƒç”¨ grantUserRole æ–¹æ³•, æˆæƒæ–°çš„ç¼–è¾‘å™¨åœ°å€ä¸º ROLE_USER

5. è·å–æ–°çš„ç¼–è¾‘å™¨åœ°å€å’Œ ROLE_USER çš„å“ˆå¸Œå€¼, å¡«å…¥ roles ä¸­æŸ¥çœ‹æƒé™, æ­¤å¤„åº”ä¸º true

6. ä¼ å…¥æ–°çš„ç¼–è¾‘å™¨åœ°å€, ä½¿ç”¨ç®¡ç†å‘˜åœ°å€è°ƒç”¨ revokeUserRole æ–¹æ³•, å–æ¶ˆæ–°çš„ç¼–è¾‘å™¨åœ°å€çš„ ROLE_USER æƒé™

7. è·å–æ–°çš„ç¼–è¾‘å™¨åœ°å€å’Œ ROLE_USER çš„å“ˆå¸Œå€¼, å¡«å…¥ roles ä¸­æŸ¥çœ‹æƒé™, æ­¤å¤„åº”ä¸º false

8. ä¸ä½¿ç”¨ç®¡ç†å‘˜åœ°å€è°ƒç”¨ grantUserRole æ–¹æ³•, ä¼šæŠ¥é”™

<br><br>
