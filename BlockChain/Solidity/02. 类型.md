# Value Type

Value Type (值类型) 的变量在赋值或作为函数参数传递时, 会复制其数据的值.

<br>

## 布尔类型

```solidity
contract Demo {
    bool public isActive; // 默认为 false
}
```

布尔值可以进行以下运算:

-   逻辑运算: `!` (逻辑非), `&&` (逻辑与), `||` (逻辑或)

-   比较运算: `==` (等于), `!=` (不等于)

其中, `&&` 和 `||` 是短路运算符, 即如果第一个操作数已经能够确定整个表达式的值, 则不会再计算第二个操作数.

<br>

## 整数类型

-   无符号整数类型: `uint8`, `uint16`, ..., `uint256` (`uint256` 可简写为 `uint`)

-   有符号整数类型: `int8`, `int16`, ..., `int256` (`int256` 可简写为 `int`)

```solidity
contract Demo {
    // 有符号整数类型
    int public signedInt; // 默认为 0, 取值范围为 -2^255 ~ 2^255-1
    // 无符号整数类型
    uint public unsignedInt; // 默认为 0, 取值范围为 0 ~ 2^256-1
}
```

可以直接通过 API 获取指定整数类型的最大最小值:

```solidity
contract Demo {
    uint public maxUint = type(uint).max; // 2^256-1
    uint public minUint = type(uint).min; // 0

    int public maxInt = type(int).max; // 2^255-1
    int public minInt = type(int).min; // -2^255
}
```

整数值可以进行以下运算:

-   算术运算: `+` (加), `-` (减), `*` (乘), `/` (除), `%` (取余), `**` (幂)

-   比较运算: `==` (等于), `!=` (不等于), `<` (小于), `>` (大于), `<=` (小于等于), `>=` (大于等于)

-   位运算: `&` (按位与), `|` (按位或), `^` (按位异或), `~` (按位取反), `<<` (左移), `>>` (右移)

以下是对一些操作的说明:

1. 整数除以 0 会抛出异常.

2. 整数除法通常是截断的, 但如果运算符是字面量则不会截断.

3. 移位运算结果的正负取决于左边的数. `x << y` 与 `x * (2**y)` 相等, `x >> y` 与 `x / (2*y)` 相等.

4. 不能进行负移位, 即操作符右边的数不能为负数, 否则会在运行时抛出异常.

整型溢出问题:

在进行整数操作时, 如果结果不在取值范围内, 就会发生溢出截断. 防止整型溢出的一个方法是对运算的结果进行判断, 防止出现异常值:

```solidity
contract Demo {
    uint public add(uint a,  uint b) public pure returns (uint) {
        uint c = a + b;
        require(c >= a,  "Addition overflow");
        return c;
    }

    uint public sub(uint a,  uint b) public pure returns (uint) {
        require(b <= a,  "Subtraction overflow");
        return a - b;
    }
}
```

<br>

## 地址类型

-   普通 `address` 类型: 20 字节大小, 存储合约或账户的地址

-   `address payable` 类型: 具有成员函数 `transfer` 和 `send`, 用于发送/接收以太币

```solidity
contract Demo {
    address public owner; // 默认为 0x0000000000000000000000000000000000000000,  即 address(0)
}
```

地址类型的值可以进行比较运算: `==` (等于), `!=` (不等于), `<` (小于), `>` (大于), `<=` (小于等于), `>=` (大于等于), 通常用于判断两个地址是否相等.

地址类型成员:

-   balance: `<address>.balance`; 返回 `address` 的余额 (单位为 wei)

-   transfer: `<address payable>.transfer(uint256 amount)`; 向 `address` 发送 `amount` 数量的以太币 (单位为 wei), 如果失败则抛出异常. 消耗固定的 2300 gas.

-   send: `<address payable>.send(uint256 amount) returns (bool)`; 向 `address` 发送 `amount` 数量的以太币 (单位为 wei), 如果失败则返回 `false`. 消耗固定的 2300 gas.

<br>

## 定长字节类型

-   `bytes1`, `bytes2`, ..., `bytes32`

```solidity
contract Demo {
    bytes1 public dataHash1; // 默认为 0x00
    bytes2 public dataHash2; // 默认为 0x0000
    // 可以看出,  1 字节 (byte) - 8 位 (bit) - 2 个十六进制数
    // 因为 2^4 = 16,  即 1 个十六进制数可以表示 4 位二进制数
}
```

```solidity
contract Demo {
    bytes32 public _byte32 = "MiniSolidity";
    // 以字节形式存储字符串 "MiniSolidity"
    // 0x4d696e69536f6c69646974790000000000000000000000000000000000000000

    bytes1 public _byte = _byte32[0]; // 取出第一个字节
    // 0x4d
}
```

<br>

## 枚举类型

-   枚举的默认值是其定义的第一个值

-   枚举值在内部表示为 uint8, 从 0 开始递增

```solidity
contract Demo {
    enum State {
        PENDING,  // 0
        ACTIVE,  // 1
        INACTIVE // 2
    }
    State public state; // 默认值为 PENDING,  即 0
}
```

枚举可以显式地和 uint 相互转换, 且会检查转换的正整数是否在枚举的长度内, 否则会报错:

```solidity
contract Demo {
    enum State {
        PENDING,  // 0
        ACTIVE,  // 1
        INACTIVE // 2
    }
    State public state = State.ACTIVE; // 1

    uint public stateValue = uint(state); // 1
    State public newState = State(stateValue); // ACTIVE,  即 1
}
```

<br><br>

# Reference Type

Reference Type (引用类型) 的变量在赋值或作为函数参数传递时, 会复制存储数据的地址.

<br>

## 字符串类型

```solidity
contract Demo {
    string public stringData; // 默认为空字符串 ""
}
```

<br>

## 动态字节类型

```solidity
contract Demo {
    bytes public byteData; // 默认为 0x
}
```

```solidity
contract Demo {
    bytes public _byte32 = "MiniSolidity";
    // 以字节形式存储字符串 "MiniSolidity"
    // 0x4d696e69536f6c6964697479

    bytes1 public _byte = _byte32[0]; // 取出第一个字节
    // 0x4d
}
```

<br>

## 数组类型

-   固定大小数组类型: `uint[5]` 表示包含 5 个无符号整数的数组

-   动态大小数组类型: `uint[]` 表示大小可变的无符号整数数组

```solidity
contract Demo {
    // 固定大小数组类型
    uint[3] public fixedArray1; // 默认为 [0,  0,  0]
    // 动态大小数组类型
    uint[] public dynamicArray; // 默认为 []

    // 对于固定大小数组类型的变量,  还能如下创建
    uint[] public fixedArray2 = new uint[](3); // 默认为 [0,  0,  0]
}
```

<br>

## 结构体类型

用于将不同类型的数据组合在一起

```solidity
contract Demo {
    struct Person {
        string name;
        uint age;
    }
    Person public person;
    // 数据的默认值为对应类型的默认值,  这里 name 默认为空字符串 "",  age 默认为 0
}
```

<br><br>

# Mapping Type

Mapping Type (映射类型) 是存储键值对的数据结构, 可以理解为哈希表.

```solidity
contract Demo {
    mapping(address => uint) public balances;
    // key-value 中,  value 的默认值为对应类型的默认值,  这里为 uint 的默认值 0
}
```

需要注意: ① 映射的 key 只能是 Solidity 内置的值类型, 如 uint, address; ② 映射类型也属于引用类型的一种; ③ 映射的存储位置必需是 storage .

原理: 映射使用 `keccak256(abi.encodePacked(key,  slot))` 当成 offset 存取 value, 其中 slot 是映射变量定义所在的插槽位置.

<br><br>

# Function Type

Function Type (函数类型) 是 Solidity 的一种特殊类型, 用于存储函数的引用.

```solidity
contract Demo {
    function add(uint a,  uint b) public pure returns (uint) {
        return a + b;
    }
}
```

<br><br>
