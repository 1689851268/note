# Value Type

Value Type (值类型) 的变量在赋值或作为函数参数传递时, 会复制其数据的值.

1.  **布尔类型**:

```solidity
contract Demo {
    bool public isActive; // 默认为 false
}
```

布尔值可以进行以下运算:

-   逻辑运算: `!` (逻辑非)、`&&` (逻辑与)、`||` (逻辑或)

-   比较运算: `==` (等于)、`!=` (不等于)

其中, `&&` 和 `||` 是短路运算符, 即如果第一个操作数已经能够确定整个表达式的值, 则不会再计算第二个操作数.

2.  **整数类型**:

-   无符号整数类型: `uint8`、`uint16`、...、`uint256` (`uint256` 可简写为 `uint`)

-   有符号整数类型: `int8`、`int16`、...、`int256` (`int256`可简写为 `int`)

```solidity
contract Demo {
    // 有符号整数类型
    int public signedInt; // 默认为 0
    // 无符号整数类型
    uint public unsignedInt; // 默认为 0
}
```

可以直接通过 API 获取指定整数类型的最大最小值:

```solidity
contract Demo {
    uint public maxUint = type(uint).max; // 2^256-1
    uint public minUint = type(uint).min; // 0

    int public maxInt = type(int).max; // 2^255-1
    int public minInt = type(int).min; // -2^255
}
```

整数值可以进行以下运算:

-   算术运算: `+` (加)、`-` (减)、`*` (乘)、`/` (除)、`%` (取余)、`**` (幂)

-   比较运算: `==` (等于)、`!=` (不等于)、`<` (小于)、`>` (大于)、`<=` (小于等于)、`>=` (大于等于)

3.  **地址类型**:

-   普通 `address` 类型: 20 字节大小, 存储合约或账户的地址

-   `address payable` 类型: 比 `address` 多了 `transfer` 和 `send` 方法, 用于发送/接收以太币

```solidity
contract Demo {
    address public owner; // 默认为 0x0000000000000000000000000000000000000000, 即 address(0)
}
```

4.  **定长字节类型**:

-   `bytes1`、`bytes2`、...、`bytes32`

```solidity
contract Demo {
    bytes1 public dataHash1; // 默认为 0x00
    bytes2 public dataHash2; // 默认为 0x0000
    // 可以看出, 1 字节 (byte) - 8 位 (bit) - 2 个十六进制数
    // 因为 2^4 = 16, 即 1 个十六进制数可以表示 4 位二进制数
}
```

```solidity
contract Demo {
    bytes32 public _byte32 = "MiniSolidity"; // 以字节形式存储 "MiniSolidity"
    // 0x4d696e69536f6c69646974790000000000000000000000000000000000000000

    bytes1 public _byte = _byte32[0]; // 取出第一个字节
    // 0x4d
}
```

5.  **枚举类型**:

-   枚举的默认值是其定义的第一个值

-   枚举值在内部表示为 uint8, 从 0 开始递增

```solidity
contract Demo {
    enum State {
        PENDING, // 0
        ACTIVE, // 1
        INACTIVE // 2
    }
    State public state; // 默认值为 PENDING, 即 0
}
```

枚举可以显式地和 uint 相互转换, 且会检查转换的正整数是否在枚举的长度内, 否则会报错:

```solidity
contract Demo {
    enum State {
        PENDING, // 0
        ACTIVE, // 1
        INACTIVE // 2
    }
    State public state = State.ACTIVE; // 1

    uint public stateValue = uint(state); // 1
    State public newState = State(stateValue); // ACTIVE, 即 1
}
```

<br><br>

# Reference Type

Reference Type (引用类型) 的变量在赋值或作为函数参数传递时, 会复制存储数据的地址.

1.  **字符串类型**:

```solidity
contract Demo {
    string public stringData; // 默认为空字符串 ""
}
```

2.  **动态字节类型**:

```solidity
contract Demo {
    bytes public byteData; // 默认为 0x
}
```

3.  **数组类型**:

-   固定大小数组类型: `uint[5]` 表示包含 5 个无符号整数的数组

-   动态大小数组类型: `uint[]` 表示大小可变的无符号整数数组

```solidity
contract Demo {
    // 固定大小数组类型
    uint[3] public fixedArray1; // 默认为 [0, 0, 0]
    // 动态大小数组类型
    uint[] public dynamicArray; // 默认为 []

    // 对于固定大小数组类型的变量, 还能如下创建
    uint[] public fixedArray2 = new uint[](3); // 默认为 [0, 0, 0]
}
```

4.  **结构体类型**: 用于将不同类型的数据组合在一起

```solidity
contract Demo {
    struct Person {
        string name;
        uint age;
    }
    Person public person;
    // 数据的默认值为对应类型的默认值, 这里 name 默认为空字符串 "", age 默认为 0
}
```

<br><br>

# Mapping Type

Mapping Type (映射类型) 是存储键值对的数据结构, 可以理解为哈希表.

```solidity
contract Demo {
    mapping(address => uint) public balances;
    // key-value 中, value 的默认值为对应类型的默认值, 这里为 uint 的默认值 0
}
```

需要注意: ① 映射的 key 只能是 Solidity 内置的值类型, 如 uint、address; ② 映射类型也属于引用类型的一种; ③ 映射的存储位置必需是 storage .

原理: 映射使用 `keccak256(abi.encodePacked(key, slot))` 当成 offset 存取 value, 其中 slot 是映射变量定义所在的插槽位置.

<br><br>

# Function Type

Function Type (函数类型) 是 Solidity 的一种特殊类型, 用于存储函数的引用.

```solidity
contract Demo {
    function add(uint a, uint b) public pure returns (uint) {
        return a + b;
    }
}
```

<br><br>
