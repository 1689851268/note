# 监听元素的渲染

我们先用一个示例引出问题：现有一个链接 `http://xxx.com/list?id=3`，用户通过这个链接可以跳到一个列表页，我们想在用户进入列表页后，`id` 为 `3` 的列表项可以滚到可视区。

```html
<!DOCTYPE html>
<html lang="en">
    <style>
        ul {
            background-color: antiquewhite;
            height: 500px;
            list-style: none;
            padding: 0;
            text-align: center;
            line-height: 500px;
        }
        li {
            background-color: aquamarine;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid black;
            margin: 20px 0;
        }
    </style>
    <body>
        <ul>
            Loading...
        </ul>
    </body>
    <script>
        // 模拟异步请求
        (async () => {
            const fetchData = () => {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve(`
                            <li id="1">1</li>
                            <li id="2">2</li>
                            <li id="3">3</li>
                            <li id="4">4</li>
                            <li id="5">5</li>
                        `);
                    }, 1000);
                });
            };
            document.querySelector('ul').innerHTML = await fetchData();
        })();

        const id = 3; // 从 URL 获取
        const element = document.getElementById(id);
        element.scrollIntoView({ behavior: 'smooth' });
    </script>
</html>
```

这里就会出现一个问题：数据请求是异步的，我们在获取元素时，元素还没有渲染完成，`element.scrollIntoView({ behavior: 'smooth' })` 会抛出错误 "TypeError: Cannot read properties of null (reading 'scrollIntoView')"。

碰到这种情况，很多同学可能会选择用定时器来处理：

```js
setTimeout(() => {
    const element = document.getElementById(id);
    element.scrollIntoView({ behavior: 'smooth' });
}, 1000);
```

如果 delay 1000 不行，那就 delay 1500、2000，只要 delay 的时间足够长，总能获取到元素。但这种方法是并不理想，因为在不同的设备、网络环境下，元素的渲染时间是不确定的，所以我们需要监听元素的渲染。

我们有两种方法可以监听元素的渲染：**MutationObserver** 和 **CSS 动画监听**。

<br>

## MutationObserver

[MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver) 是一个很强大的 API，它可以监听 DOM 树的变化。

以下是 MDN 的示例：

```js
// 选择需要观察的节点
const targetNode = document.getElementById('some-id');

// 配置观察器（需要观察什么变动）
const config = { attributes: true, childList: true };

// 观察到变动时执行的回调函数
const callback = function (mutationsList, observer) {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            console.log('A child node has been added or removed.');
        } else if (mutation.type === 'attributes') {
            console.log(
                'The ' + mutation.attributeName + ' attribute was modified.',
            );
        }
    }
};

// 创建一个观察器实例并传入回调函数
const observer = new MutationObserver(callback);

// 以上述配置开始观察目标节点
observer.observe(targetNode, config);

// 之后, 可停止观察
observer.disconnect();
```

OK 现在我们知道 MutationObserver 怎么用了，回到上面的问题，我们可以监听 `ul` 的子节点变化。`<li id="3">3</li>` 渲染完成后，就会触发回调函数，我们就可以在回调函数里执行滚动操作：

```js
// 选择需要观察的节点
const targetNode = document.querySelector('ul');

// 配置观察器（需要观察什么变动）
const config = { childList: true };

// 观察到变动时执行的回调函数
const callback = function (mutationsList, observer) {
    // 选择需要滚动的节点
    const element = document.getElementById(id);
    for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
            // 获取新增的节点
            const addedNodes = Array.from(mutation.addedNodes);
            // 如果新增的节点中包含需要滚动的节点
            if (addedNodes.includes(element)) {
                // 使元素滚动到可视区
                element.scrollIntoView({ behavior: 'smooth' });
                // 停止观察
                observer.disconnect();
            }
        }
    }
};

// 创建一个观察器实例并传入回调函数
const observer = new MutationObserver(callback);

// 以上述配置开始观察目标节点
observer.observe(targetNode, config);
```

可以看到 `<li id="3">3</li>` 渲染完成后就会滚到可视区啦。

<br>

## CSS 动画监听

乍一看，CSS 动画监听似乎与 DOM 的渲染没有什么关联。其实原理很简单：我们给元素添加 CSS 动画，这个动画会在元素渲染完成后开始执行。因此，我们可以监听**动画开始事件**来追踪元素的渲染过程。

实现这个方法的代码也很简单，我们先定义一个不会对视觉效果产生影响的动画：

```css
@keyframes appear {
    to {
        opacity: 0.99;
    }
}
```

然后，我们将这个动画应用到我们想要监听的元素上：

```css
li {
    animation: appear 0.01s;
}
```

最后，在该元素的父级上监听动画开始事件：

```js
parent.addEventListener('animationstart', (ev) => {
    if (ev.animationName == 'appear') {
        console.log('动画开始，元素渲染完成！');
    }
});
```

回到上面的问题，我们可以这样解决：

定义动画 appear，并将其应用到 `li` 元素上：

```css
li {
    animation: appear 0.01s;
}
@keyframes appear {
    to {
        opacity: 0.99;
    }
}
```

接着，我们在所有 `li` 的父级 `ul` 上监听动画开始事件：

```js
const parentDOM = document.querySelector('ul');
parentDOM.addEventListener('animationstart', (e) => {
    if (e.animationName == 'appear' && e.target.id == id) {
        e.target.scrollIntoView({ behavior: 'smooth' });
    }
});
```

经过我的测试发现，即使定义的动画没有配置任何动画效果、即使 animation 没有设置动画时间，也能正常触发 animationstart 事件。所以 CSS 代码还可以简化：

```css
li {
    animation: appear;
}
@keyframes appear {
}
```

<br><br>

# DEMO

我们再来看一个例子：现在我们有两个 `div`，里面的内容是异步请求获取的。在内容加载完成后，我们需要判断这些 `div` 是否需要展开。如果内容超出了 `div` 的默认高度，我们就显示一个 [展开] 按钮供用户点击，否则，我们将 [展开] 按钮隐藏起来。

```html
<!DOCTYPE html>
<html lang="en">
    <style>
        div {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3;
            line-height: 1.5;
            overflow: hidden;
            border: 1px solid #000;
            padding: 5px;
        }
        div[data-can-expand='false'] button {
            display: none;
        }
    </style>
    <body>
        <div>
            <button>展开</button>
            <span>Loading...</span>
        </div>
        -
        <div>
            <button>展开</button>
            <span>Loading...</span>
        </div>
    </body>
    <script>
        // 模拟异步请求
        (async () => {
            const fetchData = () => {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve([
                            `Lorem ipsum dolor sit amet consectetur adipisicing elit. Sed, eaque. Adipisci aut, aspernatur reprehenderit ex sunt tenetur, non architecto porro nam totam cum. Velit repudiandae ipsum rerum perferendis deleniti ut!`,
                            `Lorem ipsum dolor sit amet consectetur adipisicing elit. Ad, sed`,
                        ]);
                    }, 1000);
                });
            };

            const newSpan1 = document.createElement('span');
            const newSpan2 = document.createElement('span');
            newSpan1.dataset.isContent = true;
            newSpan2.dataset.isContent = true;

            const [content1, content2] = await fetchData();
            newSpan1.innerHTML = content1;
            newSpan2.innerHTML = content2;

            const [span1, span2] = document.querySelectorAll('span');
            span1.remove();
            span2.remove();

            const [div1, div2] = document.querySelectorAll('div');
            div1.appendChild(newSpan1);
            div2.appendChild(newSpan2);
        })();

        // TODO
    </script>
</html>
```

如果咱不知道 MutationObserver 和 CSS 动画监听，我们可能又会选择用定时器来处理：

```js
setTimeout(() => {
    const divList = document.querySelectorAll('div');
    divList.forEach((div) => {
        // 为 div 添加自定义属性, 表示是否可以展开
        div.dataset.canExpand = div.scrollHeight > div.clientHeight;
    });
}, 1000);
```

<br>

## 使用 MutationObserver 处理

以 `span` 的父级为观察目标，这里以 `div` 为例：

```js
// 选择需要观察的节点
const targetNode = document.querySelectorAll('div');

// 配置观察器（需要观察什么变动）
const config = { childList: true };

// 观察到变动时执行的回调函数
const callback = function (mutationsList) {
    for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
            // 为 div 添加自定义属性, 表示是否可以展开
            mutation.target.dataset.canExpand =
                mutation.target.scrollHeight > mutation.target.clientHeight;
        }
    }
};

// 创建一个观察器实例并传入回调函数
const observer = new MutationObserver(callback);

// 以上述配置开始观察目标节点
targetNode.forEach((dom) => {
    observer.observe(dom, config);
});
```

<br>

## 使用 CSS 动画监听处理

定义动画 appear，并将其应用到 `span` 元素上：

```css
div span {
    animation: appear;
}
@keyframes appear {
}
```

为 `span` 的父级绑定 animationstart 事件，这里以 document 为例：

```js
document.addEventListener('animationstart', (e) => {
    const dom = e.target;
    if (e.animationName == 'appear' && dom.dataset.isContent) {
        const parentDom = dom.parentElement;
        // 为 div 添加自定义属性，表示是否可以展开
        parentDom.dataset.canExpand =
            parentDom.scrollHeight > parentDom.clientHeight;
    }
});
```

<br><br>

# CSS 动画监听的注意事项

在 Vue 中使用 CSS 动画监听时，我们可以将这个监听直接绑定到组件上：

```vue
<template>
    <div @animationstart="handleAnimationStart">
        <span>Loading...</span>
    </div>
</template>
```

编写 CSS 时，我们可能会使用 `scoped` 属性来限制 CSS 的作用范围：

```vue
<style scoped>
div span {
    animation: appear;
}
@keyframes appear {
}
</style>
```

由于我们使用了 `scoped` 属性，所以在编译后，动画名称会被加上一个 hash 后缀，形如 `appear-xxxxxx`。

因此，当我们监听动画开始事件时，需要使用 `animationName.startsWith('appear')` 来判断动画名称：

```js
const handleAnimationStart = (e) => {
    if (e.animationName.startsWith('appear')) {
        // do something
    }
};
```

<br><br>

# 总结

在数据驱动的视图框架中，直接访问 DOM 元素可能会带来一些挑战。由于视图是根据数据动态生成的，数据可能已经发生了变化，但 DOM 还未及时更新。为了解决这个问题，我们可以借助 **MutationObserver** 和 **CSS 动画监听**来监控元素的渲染状态，确保我们能在适当的时机获取到所需的 DOM 元素。

<br>
