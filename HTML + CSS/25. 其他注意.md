# CSS 代码顺序

1. 布局定位属性
2. 自身属性
3. 文本样式属性
4. CSS3 样式

# H5 标签

一些 h5 标签：即**有语义化的 div**，提高搜索引擎权重

```html
<header>页眉，也可用于块头部</header>
<nav>导航</nav>
<section>页面上的板块</section>
<article>用来在页面中表示一套结构完整且独立的内容部分</article>
<aside>侧边栏</aside>
<footer>页面的底部或者板块的底部</footer>
```

```html
<!-- 引入视频 -->
<video src="" controls></video>

<!-- 引入音频 -->
<audio src="" controls></audio>

<!-- controls 显示默认控件；便签自身设置 cavnas，可用 js 生成 -->
```

<br><br>

# @规则

```css
@charset 'utf-8'; /* 设置样式表的编码 */
@import '文件名'; /* 导入其他样式文件 */
@media xxx; /* 媒体查询，查询用户设备的屏幕大小 */
```

<br><br>

# 媒体查询

```css
@media media_type and (media_feature) {
    /* 样式规则 */
}
```

<br>

常见的 `media_type`：

-   `all`：所有设备（默认）
-   `print`：打印设备
-   `screen`：屏幕设备
-   `speech`：语音合成器设备

<br>

常见的 media_feature：

-   `width`：视口的宽度
-   `height`：视口的高度
-   `device-width`：设备屏幕的宽度
-   `device-height`：设备屏幕的高度
-   `orientation`：设备的方向（横向或纵向）
-   `aspect-ratio`：视口的宽高比
-   `color`：设备的颜色位深度
-   `resolution`：设备的分辨率

-   `min-width`: 最小的宽度
-   `max-width`: 最大的宽度

<br>

```css
/* 屏幕设备的宽度为 1000~1500 像素时，样式生效 */
@media screen and (min-width: 1000px) and (max-width: 1500px) {
    /* 样式规则 */
}
```

```css
/* 所有媒体类型下，宽度小于等于 600 像素时，样式生效 */
@media (max-width: 600px) {
    /* 样式规则 */
}
```

<br><br>

# 网页图标的引入

-   图标格式：.ico
-   图标存放位置：根目录

```html
<link rel="icon" href="favicon.ico" />
```

<br><br>

# base 标签

base 标签有一个必需的属性 `href`，用于指定基准路径的 URL。所有相对 URL 将相对于该 URL 进行解析。

例如，使用以下 base 标签：

```html
<base href="https://example.com/" />
```

那么在页面中的所有相对 URL 将相对于 `https://example.com/` 进行解析。例如，如果有一个相对链接 `<a href="/about">About</a>`，那么它将被解析为 `https://example.com/about`。

<br>

base 标签还可以有其他可选的属性，如 `target`，用于指定链接的默认打开方式。

例如，可以使用 `<base target="_blank">` 来指定页面中的所有链接在新标签页中打开。

<br>

base 标签通常位于 head 标签中，并且一般都位于其他元素之前，例如 `<link>`、`<style>` 或 `<script>` 标签。

需要注意的是，每个页面只能有一个 base 标签。

<br><br>

# 浏览器的渲染流程

1. 构建文档对象模型 (DOM)：浏览器解析 HTML 文件，将其转换为 DOM 树，表示网页的结构和内容。
2. 构建样式对象模型 (CSSOM)：浏览器解析 CSS 文件，将其转换为 CSSOM 树，表示网页的样式信息。
3. 构建渲染树 (Render Tree)：合并 DOM 树和 CSSOM 树形成渲染树，渲染树只包含需要显示的元素和样式信息。
4. 布局 (Layout)：计算渲染树中每个元素的大小、位置和排列方式，确定它们在屏幕上的位置。
5. 绘制 (Painting)：根据布局计算得出的位置信息，将渲染树中的元素绘制到屏幕上。
6. 合成 (Composition)：将绘制得到的各个层 (Layout) 按照正确的顺序合成到屏幕上，形成最终的可视化输出。
7. 反复重绘与重排 (Repaint & Reflow)：当 DOM 或 CSSOM 发生变化时，浏览器会重新执行布局和绘制过程，将更改后的内容呈现在屏幕上。

<br><br>

# 颜色设置

1. 英文单词：`red`、`green`、`blue`
2. 六位十六进制的数值：`#000000 ~ #ffffff`，形如 `#aabbcc` 的值可简写成 `#abc`
3. rgb：`rgb(0 ~ 255, 0 ~ 255, 0 ~ 255)`
4. rgba：`rgba(0 ~ 255, 0 ~ 255, 0 ~ 255, 0 ~ 1)`，最后一个控制透明度

<br><br>

# 空格

在 HTML 中，空格包括以下几种类型：

1. 空格符（Space）：用于在文本中创建水平间距，但连续的多个空格符会被合并为一个空格。
2. 制表符（Tab）：用于创建更大的水平间距，通常用于代码缩进。
3. 换行符（Line Break）：用于换行显示文本内容，可以通过 `<br>` 标签在 HTML 中插入换行符。
4. 空白符（White Space）：包括空格符、制表符和换行符的总称。

<br>

在 HTML 中，连续的空格、制表符和换行符会被浏览器合并为一个空格。

<br><br>

# 特殊字符

```html
<!-- < 小于号 (less than) -->
&lt;

<!-- > 大于号 (greater than) -->
&gt;

<!-- 不断行的空白 (non-breaking space) -->
&nbsp;

<!-- & 并 -->
&amp;

<!-- “ 引号 (quotation) -->
&quot;

<!-- ® 已注册 (registration) -->
&reg;

<!-- © 版权 (copyright) -->
&copy;

<!-- ™ 商标 (trademark) -->
&trade;

<!-- 半个空白位 -->
&ensp;

<!-- 一个空白位 -->
&emsp;
```

<br><br>

# SEO

SEO（Search Engine Optimization，搜索引擎优化）是一系列的策略和技术，旨在让网站在搜索引擎中获得更好的排名。通过优化网站的内容、结构、技术等方面，使其能够符合搜索引擎的算法和标准，从而更好地被搜索引擎索引和理解，从而吸引更多的有针对性的有机流量。

<br>

一些可用的手段：

1.  避免嵌套过深的 HTML 结构层级
2.  SE 会特别 "关照" 一些标签，比如：title、h1 ~ h6，权重依次递减。
3.  给页面设置合适的 meta 标签信息也有助于 SEO。

<br><br>

# @import

可以在一个 CSS 文件的开头使用 `@import` 指定一个或多个要导入的 CSS 文件的 URL：

```css
@import url('base.css');
@import url('theme.css');
@import url('layout.css');
```

这样，导入的 CSS 文件中的样式规则就会应用到当前的 CSS 文件中。

<br>

导入的 CSS 文件可以使用相对路径或绝对路径，也可以省略 `url("")`：

```css
@import 'base.css';
@import 'https://example.com/theme.css';
```

<br>

导入的 CSS 文件还可以指定一个或多个媒体查询条件，用于决定在什么情况下应用导入的样式规则：

```css
@import url('print.css') print;
@import url('mobile.css') screen and (max-width: 768px);
```

当媒体类型为 print（打印机）时，应用 print.css 文件中的样式规则。这可以用于为打印页面设置不同的样式，例如隐藏一些不必要的元素，调整字体大小和颜色等。

当媒体类型为 screen（屏幕）并且最大宽度不超过 768 像素时，应用 mobile.css 文件中的样式规则。这可以用于为移动设备设置不同的样式，例如调整布局和响应式设计等。

<br>

这种方法的优点是简单易用，缺点是可能影响页面加载速度，因为浏览器需要先下载当前的 CSS 文件，然后再根据 `@import` 指令下载其他的 CSS 文件。

<br><br>

# 包含块

包含块的英语全称为 containing block，包含块分为两种：

一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（**initial containing block**）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。

另外一种是对于非根元素，需要通过这个元素的 `position` 属性确定其包含块：

1. `static` / `relative` / `sticky`：包含块是最近的祖先块元素 (`inline-block` / `block`) 。
2. `absolute`：包含块就是最近的 `position` 的值不是 `static` (`fixed` / `absolute` / `relative` / `sticky`) 的祖先元素。
3. `fixed`：在连续媒体 (`continuous media`) 的情况下，包含块是视窗 (`viewport`)；在分页媒体(`paged media`) 的情况下包含块是分页区域 (`page area`)。
4. `absolute` / `fixed`：包含块还可能是满足以下条件的最近的祖先块元素（优先级较高）
    1. `filter` 的值不是 `none`，或者 `will-change` 的值是 `filter`。(仅 Firefox 生效)
    2. `will-change` 的值是 `transform` 或 `perspective`。
    3. `transform` / `perspective` 的值不是 `none`。
    4. `contain` 的值是 `paint`。

<br><br>

# 显示 / 隐藏

`display: none`、`visibility: hidden`、`opacity: 0` 都能将元素隐藏。不论设置哪个属性，都还是可以在控制台看见其标签元素的。

<br>

## 结构

-   `display: none`：**不**占据空间，**不能**点击，**不**支持 transition。
-   `visibility: hidden`：占据空间，**不能**点击，支持 transition。
-   `opacity: 0`：占据空间，**能**点击，支持 transition。

<br>

## 继承

-   `display: none`：**非继承**属性，但子孙节点也会消失，且无法再显示。
-   `opacity: 0`：**非继承**属性，但元素和它的子元素都会具有相同的透明度，哪怕该元素和它的子元素有不同的 opacity 属性值。
-   `visibility: hidden`：**继承**属性，由于继承了父级的样式，子孙节点也会消失。
    但可以给子孙节点重置样式，让子孙节点显示。

<br>

## 性能

-   `display: none`：会造成文档**回流**，性能消耗较大。
-   `opacity: 0`：只会造成**重绘**，消耗性能较少。
-   `visibility: hidden`：只会造成**重绘**，性能消耗较少。

<br><br>

# 面试题

## 如何使 div 占满全屏

1. 给 html、body 标签设置 height 为 100%

```css
* {
    margin: 0;
    padding: 0;
}

html,
body {
    height: 100%;
}

div {
    height: 100%;
    background: steelblue;
}
```

2. 使用绝对定位

```css
* {
    margin: 0;
    padding: 0;
}

div {
    width: 100%;
    height: 100%;
    position: absolute;
    background: steelblue;
}
```

<br>

## 不添加元素，如何使页面的中间区域可点击

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>document</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }

            html,
            body {
                height: 100%;
            }

            body {
                background: steelblue;
            }
        </style>
    </head>

    <body id="app"></body>

    <script>
        app.addEventListener('click', e => {
            console.log('e', e);
        });
        // clientX、clientY  - 显示区域的左上角（与页面是否有滚动无关）
        // pageX、pageY - 页面的左上角，会加上滚动的距离
        // offsetX、offsetY - 事件对象的左上角，与点击的坐标
        // layerX、layerY - 找有定位属性的父元素的左上角，直至 body；自身有定位属性的话就是相对于自身
        // screenX、screenY - 全局（屏幕）的左上角；在多屏显示的环境下，范围将增加到屏幕的组合宽高
        // x、y - clientX、clientY 的别名（尚在开发中）
    </script>
</html>
```

<br>
