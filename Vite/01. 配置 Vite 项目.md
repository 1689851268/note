# 搭建第一个 Vite 项目

`yarn create vite`：这里是使用 create-vite 搭建 Vite 项目，类似于使用 vue-cli 搭建 Webpack 项目

-   vue-cli 内置 Webpack；Webpack 支持 ESModule 和 CommonJS
-   create-vite 内置 Vite；Vite 仅支持 ESModule

<br><br>

# 依赖预构建

找到对应的依赖后，Vite 会：

1.  调用 esbuild 将代码都转为 ESModule 规范 - 解决不同依赖包可能使用不同模块化规范的问题
2.  将代码放到 node_modules/.vite/deps 目录下 - 方便路径重写
3.  对各个模块进行统一集成，减少模块数量 - 优化网络多包传输的性能

这个过程就叫做依赖预构建

<br>

## 优化网络多包传输的性能 demo

**vite 优化之后：**

1.  `yarn add lodash-es`
2.  `yarn dev`
3.  查看 "开发者工具 - 网络"

<img src="https://cdn.nlark.com/yuque/0/2023/png/2317274/1675672721623-f2c71f18-ee71-42ae-8057-2c8e4a5bebf0.png?x-oss-process=image%2Fformat%2Cwebp" alt="image.png" />

**vite 优化之前：**

1.  编写 vite 配置文件 vite.cofig.ts：

```ts
export default {
    optimizeDeps: {
        exclude: ["lodash-es"],
    },
};
```

2.  重启项目
3.  查看 "开发者工具 - 网络"

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2317274/1675672699463-b4b48661-c154-4144-a524-ef1ad54310ed.png?x-oss-process=image%2Fformat%2Cwebp)

<br><br>

# 处理静态资源

Vite 对于静态资源，基本上是开箱即用的

<br>

## 图片资源

```ts
import demoImg from "./assets/1.png";

const img = document.createElement("img");
img.src = demoImg;

document.body.appendChild(img);
```

导入的 `demoImg` 是图片所在的路径。

处理 svg 时，除了上例用法，还可以进行如下操作：

```ts
import demoRawImg from "@/1.png?raw"; // 添加 `?raw` 参数

document.body.innerHTML = demoRawImg;

const svgElement = document.getElementsByTagName("svg")[0];
svgElement.addEventListener("mouseenter", () => {
    this.style.fill = "red"; // 更改 svg 的颜色;  注意, 这里更改的是 `fill` attribute
});
```

此时，导入的 `demoRawImg` 是 svg 标签字符串。

<br>

## JSON 资源

```ts
import demoJson from "./demo.json";

console.log("demoJson", demoJson); // { name: 'superman', height: 180 }
```

正常情况下，导入的 `demoJson` 应该是 JSON 字符串。但是在 Vite 中，Vite 会自动将其转为对象。∴ 在 Vite 中还能按需导入 JSON：

```ts
import { name } from "./demo.json";
```

在开发中更推荐按需导入，这能减小项目体积。

<br><br>

# 设置别名

```ts
import { defineConfig } from "vite";
import path from "path";

export default defineConfig({
    resolve: {
        alias: {
            "@": path.resolve(__dirname, "./src"),
        },
    },
});
```

注意：配置时需要使用绝对路径。若使用了相对路径，会自动拼接上 `process.cwd()` 的结果作为根路径。

实际上，给 node 执行的文件，在配置路径时都要使用绝对路径。

<br><br>

# 构建生产环境

## 构建静态资源

执行 `yarn build` 构建项目

package.json：

```ts
"scripts": {
    "dev": "vite",
    "build": "vite build"
},
```

可以看见，静态资源后面都会带上 hash 值。因为浏览器有缓存机制，如果静态资源的名字不变，浏览器就会直接使用缓存，而不会重新加载资源。

在 Vite 项目中，只要更新了静态资源的内容，就会生成新的 hash 值，保证浏览器每次都能拿到最新的数据。如果文件的内容没有被更改，hash 值就不会变，浏览器就能直接使用缓存数据。

<br>

## 配置构建的方式

**build.rollupOptions**：Vite 使用 Rollup 构建生产环境

```ts
import { defineConfig } from "vite";

export default defineConfig({
    build: {
        rollupOptions: {
            // 配置构建后文件的输出方式
            output: {
                assetFileNames: "[name].[hash:5].[ext]", // 静态资源文件命名
            },
        },
    },
});
```

在 Rollup 中，hash 值由文件名和文件内容转换而成。

<br>

**build.assetsInlineLimit**：小于该属性值的图片文件会转成 base64 格式

```ts
import path from "path";
import { defineConfig } from "vite";

export default defineConfig({
    build: {
        assetsInlineLimit: 10240, // 10k; 默认是 4k
    },
});
```

<br>

**build.outDir**：

```ts
import path from "path";
import { defineConfig } from "vite";

export default defineConfig({
    build: {
        outDir: "dist", // 输出文件所在目录; 默认为 'dist'
    },
});
```

<br>

**build.assetsDir**：

```ts
import path from "path";
import { defineConfig } from "vite";

export default defineConfig({
    build: {
        assetsDir: "assets", // 静态文件存放的目录; 默认为 'assets'
    },
});
```

<br>

**build.emptyOutDir**：

```ts
import path from "path";
import { defineConfig } from "vite";

export default defineConfig({
    build: {
        emptyOutDir: true, // 输出文件前, 清空输出目录; 默认为 true
    },
});
```

<br><br>

# TypeScript

Vite 天生支持 TS

1.  将 main.js 改成 mian.ts
2.  将 index.html 中引入的 main.js 也改成 main.ts 即可

但 Vite 仅支持 TS 到 JS 的转换，不提供类型检查

<br>

## vite-plugin-checker

用于支持 TS 语法检查与规范

1.  `yarn add vite-plugin-checker -D`
2.  `yarn add typescript -D`（vite-plugin-checker 依赖于 typescript）
3.  创建 VIte 配置文件 vite.config.ts：

```ts
import path from "path";
import { defineConfig } from "vite";
import checker from "vite-plugin-checker";

export default defineConfig({
    plugins: [
        checker({
            typescript: true, // 开启 Ts 语法检查
        }),
    ],
});
```

4.  创建 TypeScript 配置文件 tsconfig.json：

```json
{
    "compilerOptions": {
        "skipLibCheck": true, // 跳过对 node_modules 目录的检查
        "module": "ESNext" // 使用最新的模块化规范语法
    }
}
```

5.  编写脚本 package.json：

```json
"scripts": {
    "dev": "vite",
    "build": "tsc --noEmit && vite build", // 检查 Ts 无误后构建项目; 若 Ts 检查出错, 则不构建
    "preview": "vite preview" // 预览 `build` 出来的项目
},
```

<br>

## 声明文件

在 TS 环境下的客户端使用环境变量会报错，需要编写声明文件。

环境变量的声明文件的文件名约定为 vite-env.d.ts，VIte 会找到这个文件里面的 `ImportMetaEnv` 接口，将其与环境变量的默认类型进行合并。

1.  创建 .env 文件，写入环境变量：

```
VITE_NUM = 1
```

2.  创建声明文件 vite-env.d.ts：

```ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_NUM: number;
}
```

3.  在 main.ts 中使用环境变量：

```ts
console.log(import.meta.env.VITE_NUM);
```

上例的 `/// <reference types="vite/client" />` 为三斜线指令，一般用于导入声明文件、导入第三方包。可以简单理解为：

-   `<reference path="..." />` 相当于 `import "filename.xxx"`
-   `<reference types="..." />` 相当于 `import lodash from "lodash"`

<br><br>

# 性能优化

1.  开发时态的速度优化
2.  压面性能指标：
    1.  首屏渲染时长 ( fcp - first content paint )
3.  懒加载
    1.  http 优化：强缓存 & 协商缓存
    2.  页面中最大元素的渲染时长 ( lcp - largest content paint )

<br>

强缓存：服务端在响应头添加一些字段 (eg: `expires`)，客户端会记住这些字段。在 `expires` 到期之前，无论如何刷新浏览器页面，浏览器都不会重新请求数据，而是从缓存获取

协商缓存：服务端在响应头添加协商缓存的标记，客户端会记住这些标记。在刷新页面时，浏览器会发送一个协商请求给服务器。如果请求的资源被更新了，服务器就响应最新的内容；如果请求的资源没有变化，则响应 304

<br>

一些 JS 编写习惯：

1.  离开页面 / 销毁组件时，清除定时器
2.  动画渲染可以使用 `requestAnimationFrame` `requestIdCallback`
    1.  浏览器的刷新帧率大约为 16.6ms，如果 JS 执行逻辑超过 16.6ms 就会掉帧
3.  防抖、节流可以使用 lodash 中写好的，因为自己写的可能会有性能问题
4.  当数组中的数据量很大时，不要直接使用 `forEach` 遍历。可以使用 `lodash.forEach`，因为 lodash 做了很多性能优化
5.  对作用域的控制：

```ts
const arr = [];
for (let i = 0, len = arr.length; i < len; i++) {} // 将 arr.length 存到 len 中
```

<br>

一些 CSS 编写习惯：

1.  关注继承属性，能继承的属性 (eg: `font-size`) ，就不需要自己再写一遍了
2.  避免过深的 CSS 嵌套

<br>

构建优化：Vite (Rollup)、Webpack

1.  优化体积：压缩、Tree Shaking、图片资源压缩、CDN 加载、分包

<br>

## 分包策略

1.  `yarn add lodash`
2.  下载 lodash 类型文件
3.  配置 tsconfig.json：

```json
{
    "compilerOptions": {
        "moduleResolution": "node" // 指定 TypeScript 如何从给定的模块说明符查找文件
    }
}
```

4.  编写代码：

```ts
import { forEach } from "lodash";

const arr: number[] = [];

forEach(arr, (ele) => {
    console.log("ele", ele);
});
```

5.  配置 vite.config.js：

```ts
import { defineConfig } from "vite";

export default defineConfig({
    build: {
        minify: false, // 关闭代码压缩
    },
});
```

6.  `yarn build`

可以看见，被打包出来的文件非常大，Vite 引入了几千行的 lodash 代码

如果我们需要更新的业务代码，且改动比较小，那我们打包进来的 lodash 代码是一样的。但重新打包后，构建出来的文件名会不一样，浏览器就会重新请求。如此，这些一样的 lodash 代码就会被重复请求，这就会造成不必要的性能开销

<br>

**分包**：

1.  配置 tsconfig.json：

```json
{
    "compilerOptions": {
        "moduleResolution": "node", // 指定 TypeScript 如何从给定的模块说明符查找文件
        "lib": ["esnext", "dom"], // 指定在项目中要使用的库
        "module": "commonjs", // 指定生成什么模块代码
        "skipLibCheck": true // 跳过 node_modules 目录的类型检查
    }
}
```

2.  配置 vite.config.js：

```ts
import { defineConfig } from "vite";

export default defineConfig({
    rollupOptions: {
        output: {
            manualChunks: (id) => {
                console.log("id", id); // 被构建的文件的路径
                /* 将 node_modules 目录下的文件都构建到 'shrinkwrap' 包下 */
                if (id.includes("node_modules")) {
                    return "shrinkwrap";
                }
            },
        },
    },
});
```

如此，只要依赖的 node_modules 目录下的文件没有被更新，`shrinkwrap` 包就不会被重新构建，浏览器就会直接使用缓存

<br>

## gzip 压缩

对所有的静态资源进行压缩，以减少体积

补充知识："入口文件 → 一系列依赖 → JS 文件" 这么个过程叫做 **块 (chunk)**

<br>

使用 [GitHub - vite-compression-plugin](https://github.com/nonzzz/vite-compression-plugin) 进行压缩

<br>

服务端读取到 gzip 文件会设置 content-encoding 响应头，浏览器接收到响应结果 并发现 gzip 对应的响应头后，会对 .gzip 文件进行解压。所以浏览器需要一定的解压时间

如果体积不是很大的话，不推荐压缩。因为浏览器解压也是需要时间的，如果文件不大，有可能会降低性能

<br>

## 动态导入

动态导入是 ES6 的一个新特性

```ts
() => import("XXX");
```

Vue-Router 路由懒加载的原理：将组件的引入放到 script 标签中，在页面访问该路由时，再将该 script 标签放进 index.html 的 head 标签中

<br>

## CDN 加速

CDN - content delivery network（内容分发网络）

构建项目时，项目依赖的文件会被打包放到服务器上。如果客户端离服务器很远，那请求数据就会非常耗时。此时 我们能以 CDN 的形式使用依赖包，以减少项目体积。

以 CDN 形式请求的数据，会直接找最近的服务器获取。

<br>

使用 [GitHub - vite-plugin-cdn-import](https://github.com/MMF-FE/vite-plugin-cdn-import) 进行 CDN 加速

1.  `yarn add vite-plugin-cdn-import -D`
2.  配置 vite.config.js

```ts
import { defineConfig } from "vite";
import importToCDN from "vite-plugin-cdn-import";

export default defineConfig({
    plugins: [
        importToCDN({
            modules: [
                {
                    // 依赖包名
                    name: "lodash",
                    // 引入项目时使用的别名
                    var: "_",
                    // CDN 链接
                    path: `https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js`,
                },
            ],
        }),
    ],
});
```

原理：创建 script 标签引入 CDN 链接，然后在 index.html 的 head 标签中注入 script 标签

<br><br>

# 跨域处理

假如我们执行 `fetch('/api')`，浏览器就会向 `http:127.0.0.1:80/api` 发起请求

我们设置如下代理服务器：

```ts
import { defineConfig } from "vite";

export default defineConfig({
    server: {
        proxy: {
            "/api": "http://localhost:4567",
        },
    },
});
```

再执行 `fetch('/api')`，浏览器就会向代理服务器请求 `http:127.0.0.1:80/api`，代理服务器再向 `http://localhost:4567/api` 发请求，服务器之间没有跨域问题，请求就能被正常响应，代理服务器拿到数据后，再将数据响应给浏览器

<br>

可以写成对象的形式：

```ts
'/api': {
    target: 'http://jsonplaceholder.typicode.com',
    changeOrigin: true,
    rewrite: path => path.replace(/^\/api/, ''),
},
```

此时执行 `fetch('/api')`，浏览器就会向代理服务器请求 `http:127.0.0.1:80/api`，代理服务器再向 `http://jsonplaceholder.typicode.com` 发请求，注意 这里的 `/api` 被删掉了。

就是说，这种写法下 `/api` 仅用作代理服务器的标识，不作为请求路径使用。

<br>

开发时态：使用 Vite / Webpack 代理服务器

生产时态：交给后端处理（ngnix 代理服务器、Access-Control-Allow-Origin 配置身份标记）

<br>
