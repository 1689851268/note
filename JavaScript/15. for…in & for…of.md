# JS 操作符 `in`

用于检查某个属性键是否存在于对象本身或其原型链上, 返回布尔值.

```javascript
propertyKey in object;
```

-   **propertyKey**: 属性键, 可为字符串或 `Symbol`. 非 `Symbol` 值会按 ToPropertyKey 规则转换为字符串 (如数字索引会转成字符串).
-   **object**: 目标对象; 若为 `null` 或 `undefined`, 将抛出 `TypeError`.

<br>

## 行为要点

-   **检查原型链**: 不仅检查自有属性, 也会沿原型链向上查找.
-   **数组索引**: 对数组检查的是 "索引键是否存在", 可识别稀疏数组中的 "洞".
-   **与 `hasOwnProperty` 的区别**: `in` 会查原型链; `hasOwnProperty` 仅查自有属性.
-   **与 `undefined` 的关系**: 属性存在但值为 `undefined` 时, `in` 仍为 `true`.
-   **支持 `Symbol` 键**: `Symbol` 键需使用同一 `Symbol` 实例进行检查.

<br>

## 示例

```javascript
// 1) 对象与原型链
const car = { make: "Toyota", model: "Camry" };
console.log("make" in car); // true (自有属性)
console.log("toString" in car); // true (来自原型)

// 2) 数组索引与稀疏数组
const numbers = [1, 2, 3];
console.log(1 in numbers); // true (存在索引 1)
console.log(3 in numbers); // false (无索引 3)

const sparse = [];
sparse[2] = 42;
console.log(0 in sparse); // false (索引 0 是 "洞")
console.log(2 in sparse); // true

// 3) in vs hasOwnProperty
const base = { inherited: "v" };
const obj = Object.create(base);
obj.own = "v";
console.log("own" in obj); // true
console.log("inherited" in obj); // true (来自原型)
console.log(obj.hasOwnProperty("own")); // true
console.log(obj.hasOwnProperty("inherited")); // false

// 4) 值为 undefined 仍视为存在
const x = { p: undefined };
console.log("p" in x); // true

// 5) Symbol 属性键
const S = Symbol("id");
const y = { [S]: 1 };
console.log(S in y); // true
console.log("Symbol(id)" in y); // false (字符串不同于 Symbol)

// 6) 安全使用: 避免对 null/undefined 右操作数
const maybe = null;
// 'p' in maybe; // TypeError
if (maybe != null && "p" in maybe) {
    // ...
}
```

<br>

## 常见误区与对比

-   **值包含 vs 键存在**: `Array.prototype.includes` 检查 "值是否存在"; `in` 检查 "键是否存在".

```javascript
[10, 20, 30].includes(20); // true (值 20)
1 in [10, 20, 30]; // true (键 1)
20 in [10, 20, 30]; // false (不存在键 '20')
```

-   **仅需自有属性时**: 使用 `Object.prototype.hasOwnProperty.call(obj, key)`.

-   **嵌套属性检查**: `'a.b' in obj` 无效. 需要逐层检查, 如 `obj.a != null && 'b' in obj.a`.

<br>

## 适用场景建议

-   **判断键是否存在 (含继承)**: 首选 `in`.
-   **仅限对象自有键**: 使用 `hasOwnProperty`.
-   **数组 "洞" 识别**: 使用 `in` 区分 "未设置的索引" 与 "已设置但值为 undefined".
-   **检查值是否存在于数组**: 使用 `includes` / `indexOf` (按值语义).

<br><br>

# for … in

-   可遍历非符号类型的 key (适用于遍历 Object)
-   可遍历所有的可枚举属性, 包括原型原型上的可枚举属性
-   ECMAScript 中对象的属性是无序的, 因此 for-in 语句不能保证返回对象属性的顺序. 换句话说, 所有可枚举的属性都会返回一次, 但返回的顺序可能会因浏览器而异.

<br>

## 遍历对象

```js
const obj = {
    name: "superman",
    age: 18,
    height: 180,
};
for (let key in obj) {
    console.log(key, obj[key]);
    // name superman
    // age 18
    // height 180
}
```

<br>

## 遍历数组

```js
const arr = ["a", "b", "c"];
for (let key in arr) {
    console.log(key, arr[key]);
    // 0 a
    // 1 b
    // 2 c
}
```

<br><br>

# for … of

-   可遍历 value 值 (适用于遍历 Array,String,Map,Set 等可迭代对象; 不能遍历 Object, 因为 Object 不是可迭代对象)
-   只遍历可迭代对象自己的 value, 不会遍历其原型对象上的 value
-   for-of 循环会按照可迭代对象的 next 方法产生值的顺序迭代元素.

```js
for (let element of [2, 4, 6, 8]) {
    console.log(element); // 2 4 6 8
}
```

数据结构只要设置了 `Symbol.iterator` 属性, 就被视为具有 iterator 接口, 就可以用 `for … of` 遍历其成员;
就是说, `for … of` 内部调用的是 `Symbol.iterator` 方法.

<br>

## 遍历对象

`for … of` 不能直接遍历对象, 但可以通过以下 3 个方法遍历:

1. **`Object.keys(obj)`**: 以数组的形式, 返回对象的**属性**
2. **`Object.values(obj)`**: 以数组的形式, 返回对象的**属性值**
3. **`Object.entries(obj)`**: 以数组的形式, 返回对象的**键值对** (键值对也是数组的形式)

这 3 个方法挂在构造函数 Object 身上, 需要通过 `Object.方法名(obj)` 调用
[数组] 也有这 3 个方法, 不过数组是挂在其原型对象身上, 所以数组可以直接通过 `实例.方法名()` 调用

```js
const obj = {
    name: "superman",
    showName() {
        console.log(this.name, this.age);
    },
};
console.log(Object.keys(obj)); // [ 'name', 'showName' ]
console.log(Object.values(obj)); // [ 'superman', [Function: showName] ]
console.log(Object.entries(obj)); // [ [ 'name', 'superman' ], [ 'showName', [Function: showName] ] ]
```

**可配合 `for … of` 遍历对象的属性**:

```js
for (const key of Object.keys(obj)) {
    console.log(key); // name    showName
}

for (const val of Object.values(obj)) {
    console.log(val); // superman    [Function: showName]
}

for (const item of Object.entries(obj)) {
    console.log(item); // [ 'name', 'superman' ]    [ 'showName', [Function: showName] ]
}
```

<br>

可以使用 Object.fromEntries 将 Object.entries 的返回值转为对应的对象:

```js
const obj = {
    children: {
        name: "superman",
    },
};

const obj2 = Object.fromEntries(Object.entries(obj)); // 浅拷贝 obj
obj2.children.name = "batman";

console.log("obj", obj);
console.log("obj2", obj2);
```

<br>

## 遍历数组

-   `arr.keys()`: 获取数组的下标
-   `arr.values()`: 获取数组的元素
-   `arr.entries()`: 获取数组的键值对 (下标, 元素)

它们都返回一个迭代器对象, 可以用 `for … of` 进行遍历:

```js
let arr = ["apple", "banana", "orange"];

for (let index of arr.keys()) {
    // 通过 keys 获取下标
    console.log(index); // 0 1 2
}

for (let val of arr.values()) {
    // 通过 values 获取值
    console.log(val); // apple banana orange
}

for (let item of arr.entries()) {
    // 通过 entries 获取键值对
    console.log(item); // [0, "apple"] [1, "banana"] [2, "orange"]
}
```

可以直接使用 `for…of` 遍历数组, 与使用 `for…of` 遍历 `arr.values()` 等效:

```js
for (let val of arr) {
    // 直接获取值
    console.log(val); // apple banana orange
}
```

<br>
