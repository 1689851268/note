# var 变量

用关键字 `var` 定义变量时，系统会申请一块内存，用于存放变量值。

<br>

## var 的使用

1. 可同时定义多个变量，变量之间用 `,` 隔开。
2. 变量的定义与赋值可以同时进行。

```javascript
var a = 1,
    b = 2,
    c = 3;
console.log(a, b, c); // 1 2 3
```

3. 不用 `var` 定义的变量为全局变量 ( 仅供了解，不建议这样使用 )。

```javascript
a = 10;
console.log(a); // 10
```

4. 变量必须声明才能使用，否则会报错。

```js
console.log(n); // Uncaught ReferenceError: n is not defined
```

5. 变量的默认值是 `undefined`。

```javascript
var a;
console.log(a); // undefined
```

<br>

## var 的特点

1. **声明提升**：JS 会先执行 `var` 语句，所以变量可以先使用再声明。

```javascript
a = 10;
var a;
console.log(a); // 10
```

注意：只能提升**定义变量**的语句，不能提升给变量赋值的语句。以下 2 种写法等价：

```javascript
console.log(a); // undefined
var a = 200;
```

```js
var a;
console.log(a); // undefined
a = 200;
```

<br>

2. **可重复声明**：同一变量可以使用 `var` 声明多次。

```js
var a = 1;
console.log(a); // 1
var a = 2;
console.log(a); // 2
```

<br>

3. **函数作用域**。

```js
function fun() {
    for (var i = 0; i < 3; i++) {
        console.log(i); // 0    1    2
    }
    console.log(i); // 3
}
fun();
```

<br><br>

# let 变量

1. `let` 变量不会进行声明提升，必须先声明再使用。

```js
console.log(a); // Uncaught ReferenceError
let a;
```

**暂时性死区 (TDZ，Temporal Dead Zone)**：指变量没有被 `let` 声明之前的区域。在 TDZ 内，该变量都不能使用。

<br>

2. 在同一作用域内，变量**不能重复用 `let` 定义**。

```js
let a;
let a; // Uncaught SyntaxError
```

<br>

3. **块级作用域**。

```js
let a = 1;
if (true) {
    let a = 2;
    console.log(a); // 2
}
```

<br><br>

# const 常量

1.  `let` 变量的特性 `const` 常量都有（有 TDZ、不能重复定义、块级作用域）。

<br>

2.  `const` 定义的是常量，常量必须在定义时就初始化，且初始化后不能再修改常量值。

```js
const NUM = 10;
NUM = 20; // TypeError
```

注意：对于引用类型的数据，运算符操作的是内存地址：

```js
const NUM = [10];
NUM.push(20);
console.log(NUM); // [10, 20]
```

在此过程中，内存地址没有发生改变，所以可以改变数组内容（对象同理）。

<br><br>

# 全局变量与顶层对象

**顶层对象**：在浏览器环境中，顶层对象指的是 `window` 对象；在 Node.js 中，顶层对象指的是 `global` 对象。

<br>

ES5 中，使用 `var` 声明的全局变量就是 [顶层对象] 的属性：

```js
var a = 1;
console.log(window.a); // 1
```

ES6 中，使用 `let` 、`const` 声明的全局变量、全局常量不再是 [顶层对象] 的属性：

```js
let a = 1;
console.log(window.a); // undefined
```

<br><br>

# 特殊的全局变量

没有使用 `var` 关键字声明的变量，会被自动绑定到全局对象上（在浏览器环境中是 `window` 对象）。

```js
function fn() {
    a = 1; // 全局变量 a
}

fn(); // 调用函数, 全局变量 a 开始生效;  注意: 在函数里面, 不调用则不会生效
console.log(a); // 输出全局变量值 1
```

一般情况下，所有的变量都应该先显式定义再使用。

<br>

在写**连续赋值操作**时要注意，后面的变量没有显式声明，则是一个全局变量：

```js
function text() {
    var a = (b = 123); // b 没有显式声明, 式子会先把值 123 赋给 b, 再赋给 a
    console.log(a, b); // 123 123
}
text(); // 调用函数, 全局变量 b 开始生效
console.log(window.b); // 123
```

<br><br>

# 标识符的命名规范

1.  由 `字母`、`数字`、下划线 `_`、美元符 `$` 组成，且不以`数字`开头。
2.  标识符区分大小写。
3.  不能是关键字和保留字。

<br><br>

# 面试题解

如果使用 `var` 实现事件的批量绑定，会出问题：

```html
<body>
    <button>a</button>
    <button>b</button>
    <button>c</button>
</body>

<script>
    // 获取所有的 button 标签
    const allButton = document.querySelectorAll('button');

    // 批量绑定事件
    for (var i = 0; i < allButton.length; i++) {
        allButton[i].onclick = () => {
            console.log(i);
        };
    }
</script>
```

此时我们点击任意 `button` 标签，会发现，所有打印结果都是 `3`。
这是因为，事件是异步操作。JS 会先走完同步代码，再执行异步操作的回调函数。
所以，执行异步操作时，同步操作 `for` 循环已经走完了，此时 `i` 为 `3`。

<br>

解决方法 ①：在绑定事件函数时，将需要用到的值，以属性的形式存储起来。需要用到时再取出：

```js
for (var i = 0; i < allButton.length; i++) {
    allButton[i].id = i;
    allButton[i].onclick = function () {
        console.log(this.id);
    };
}
```

<br>

解决方法 ②：使用 IIEF 添加一层作用域。在事件函数执行时，就会获取到对应作用域内的数值：

```js
for (var i = 0; i < allButton.length; i++) {
    (function (j) {
        allButton[j].onclick = () => {
            console.log(j);
        };
    })(i);
}
```

<br>

解决方法 ③：使用 `let` 实现事件的批量绑定。因为 `let` 拥有块级作用域：

```js
for (let i = 0; i < allButton.length; i++) {
    allButton[i].onclick = () => {
        console.log(i);
    };
}
```

注意：因为 `let` 拥有块级作用域，所以在 `for` 循环内，`{}` 中的变量会覆盖 `()` 中的同名变量。

```js
for (let i = 0; i < 10; i++) {
    let i = 10;
    console.log(i); // 会打印 10 个 10
}
```

<br>
