# 使用定时器

1. `[window.]setTimeout()` 延迟定时器
2. `[window.]setInterval()` 循环定时器（间隔器）

-   这两个是 **window 的方法**，所以 this → window 对象，`window.` 可以不写
-   主要接收 2 个参数：`回调函数`、`间隔时间`

<br>

## 回调函数

1. 匿名函数

```js
setTimeout(function () {
    console.log('superman');
}, 2000);
```

2. 函数

```js
setTimeout(function out() {
    console.log('superman');
}, 2000);
```

3. 函数名

```js
function out() {
    console.log('superman');
}
setTimeout(out, 2000);
```

4. 能被当成 JS 语句执行的字符串

```js
setTimeout('console.log("superman")', 2000);
```

5. 箭头函数

```js
setTimeout(() => {
    console.log('superman');
}, 2000);
```

<br>

## 间隔时间

```js
setInterval(function () {
    console.log('superman');
}, 500);
```

-   如果省略该参数，则使用值 `0`，表示 0ms，即 “立即” 执行。
-   根据 W3C 的标准，当嵌套层级 >= 5 层时，计时器的最小时间会被设置为 4ms。

<br>

## 其他参数

第 3 个及之后的参数都会被传入回调函数：

```js
const fun = (a, b) => {
    console.log(a, b);
};
setTimeout(fun, 2000, 10, 20);
```

<br><br>

# 清除定时器

使用定时器时，会返回该定时器的标识（其实就是定时器的序号）：

```js
let timer1 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer1); // 1

let timer2 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer2); // 2

let timer3 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer3); // 3
```

<br>

使用完定时器后，可以通过定时器的标识清除定时器：

1. `clearTimeout(timer)` → 清除 `setTimeout()`
2. `clearInterval(timer)` → 清除 `setInterval()`

```js
let timer1 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer1); // 1
clearTimeout(timer1);

let timer2 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer2); // 2
clearTimeout(timer2);
```

<br><br>

# 面试题

> #### 计时器是否能精确计时？为什么？

不能。原因如下：

1.  根据 W3C 的标准，当嵌套层级 >= 5 层时，计时器的最小时间会被设置为 4ms。
2.  由于事件循环机制，可能计时器的事件到了，其回调函数还需要经过排队才会被执行。

<br>
