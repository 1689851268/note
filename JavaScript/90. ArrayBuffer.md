# ArrayBuffer

`ArrayBuffer` 对象用来表示通用的、固定长度的**原始二进制数据缓冲区**. `ArrayBuffer` 的内容不能直接操作, 只能通过 `DataView` / `TypedArray` 对象来访问. 这些对象用于读取和写入缓冲区内容.

-   **TypedArray**: 用来生成内存的视图, 通过 9 个构造函数, 可以生成 9 种数据格式的视图
-   **DataView**: 用来生成内存的视图, 可以自定义格式和字节序

`TypedArray` 视图和 `DataView` 视图的区别主要是**字节序**, 前者的数组成员都是同一个数据类型, 后者的数组成员可以是不同的数据类型.

根据 `ArrayBuffer` 和 `Blob` 的特性, `Blob` 作为一个整体文件, 适合用于传输; 当需要对二进制数据进行操作时 (比如要修改某一段数据时), 就可以使用 `ArrayBuffer`.

<br>

## 创建 ArrayBuffer

```js
new ArrayBuffer(byteLength);
```

**参数:**

-   `byteLength`: 要创建的 `ArrayBuffer` 的大小, 单位为字节

**返回值:**

-   一个指定大小的新 `ArrayBuffer` 对象, 初始内容为 `0`

```js
const buffer = new ArrayBuffer(16);
console.log(buffer.byteLength); // 16
```

<br>

## 基本特性

-   `ArrayBuffer` 一经创建就不能再调整大小
-   可以使用 `slice()` 复制其全部或部分到一个新实例中
-   `ArrayBuffer` 在分配失败时会抛出错误
-   `ArrayBuffer` 分配的内存不能超过 `Number.MAX_SAFE_INTEGER` (`2^53-1`) 字节
-   声明 `ArrayBuffer` 会将所有二进制位初始化为 `0`
-   通过声明 `ArrayBuffer` 分配的堆内存可以被当成垃圾回收, 不用手动释放

```js
const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4, 12);
console.log(buf2.byteLength); // 8
```

要读取或写入 `ArrayBuffer`, 就必须通过视图.

<br><br>

# TypedArray

`TypedArray` 对象一共提供 9 种类型的视图, 每一种视图都是一种构造函数.

| **元素** | **类型化数组**    | **字节** | **描述**        |
| -------- | ----------------- | -------- | --------------- |
| Int8     | Int8Array         | 1        | 8 位有符号整数  |
| Uint8    | Uint8Array        | 1        | 8 位无符号整数  |
| Uint8C   | Uint8ClampedArray | 1        | 8 位无符号整数  |
| Int16    | Int16Array        | 2        | 16 位有符号整数 |
| Uint16   | Uint16Array       | 2        | 16 位无符号整数 |
| Int32    | Int32Array        | 4        | 32 位有符号整数 |
| Uint32   | Uint32Array       | 4        | 32 位无符号整数 |
| Float32  | Float32Array      | 4        | 32 位浮点       |
| Float64  | Float64Array      | 8        | 64 位浮点       |

-   **Uint8Array**: 将 `ArrayBuffer` 中的每个字节视为一个整数, 可能的值从 0~255 (1 个字节 8 位). 这样的值称为 "8 位无符号整数"
-   **Uint16Array**: 将 `ArrayBuffer` 中任意 2 个字节视为一个整数, 可能的值从 0~65535. 这样的值称为 "16 位无符号整数"
-   **Uint32Array**: 将 `ArrayBuffer` 中任何 4 个字节视为一个整数, 可能值从 0~4294967295, 这样的值称为 "32 位无符号整数"

这些构造函数生成的对象统称为 `TypedArray` 对象. 它们和正常的数组很类似, 都有 `length` 属性, 都能用索引获取数组元素, 所有数组的方法都可以在类型化数组上面使用.

类型化数组和数组的区别:

1. 类型化数组的元素都是连续的, 不会为空
2. 类型化数组的所有成员的类型和格式相同
3. 类型化数组元素默认值为 `0`
4. 类型化数组本质上只是一个视图层, 不会存储数据, 数据都存储在更底层的 `ArrayBuffer` 对象中

<br>

## 创建 TypedArray

```js
new TypedArray(length); // 通过分配指定长度内容进行构造
new TypedArray(typedArray); // 接收一个视图实例作为参数
new TypedArray(array); // 参数可以是一个普通数组
new TypedArray(buffer [, byteOffset [, length]]);
```

-   使用 `new Int8Array(array)` 创建的类型化数组也能转换回普通数组 `Array.prototype.slice.call(view)`
-   `TypeArray(buffer [, byteOffset [, length]])`:
    1. `buffer`: 一个 `ArrayBuffer` 对象
    2. `byteOffset`: 视图开始的字节序号, 默认从 0 开始
    3. `length`: 视图包含的数据个数, 默认直到本段内存区域结束

```js
// 创建一个 12 字节的缓冲
const buf = new ArrayBuffer(12);
// 创建一个引用该缓冲的 Int32Array
const ints = new Int32Array(buf);
// 这个定型数组知道自己的每个元素需要 4 字节
// 因此长度为 3
console.log(ints.length); // 3

// 创建一个长度为 6 的 Int32Array
const ints2 = new Int32Array(6);
// 每个数值使用 4 字节, 因此 ArrayBuffer 是 24 字节
console.log(ints2.length); // 6
// 类似 DataView, 定型数组也有一个指向关联缓冲的引用
console.log(ints2.buffer.byteLength); // 24

// 创建一个包含 [2, 4, 6, 8] 的 Int32Array
const ints3 = new Int32Array([2, 4, 6, 8]);
console.log(ints3.length); // 4
console.log(ints3.buffer.byteLength); // 16
console.log(ints3[2]); // 6

// 通过复制 ints3 的值创建一个 Int16Array
const ints4 = new Int16Array(ints3);
// 这个新类型数组会分配自己的缓冲
// 对应索引的每个值会相应地转换为新格式
console.log(ints4.length); // 4
console.log(ints4.buffer.byteLength); // 8
console.log(ints4[2]); // 6

// 基于普通数组来创建一个 Int16Array
const ints5 = Int16Array.from([3, 5, 7, 9]);
console.log(ints5.length); // 4
console.log(ints5.buffer.byteLength); // 8
console.log(ints5[2]); // 7

// 基于传入的参数创建一个 Float32Array
const floats = Float32Array.of(3.14, 2.718, 1.618);
console.log(floats.length); // 3
console.log(floats.buffer.byteLength); // 12
console.log(floats[2]); // 1.6180000305175781
```

<br>

## TypedArray 的属性 & 方法

### BYTES_PER_ELEMENT

每种视图的构造函数都有一个 `BYTES_PER_ELEMENT` 属性, 表示这种数据类型占据的字节数:

```js
Int8Array.BYTES_PER_ELEMENT; // 1
Uint8Array.BYTES_PER_ELEMENT; // 1
Int16Array.BYTES_PER_ELEMENT; // 2
Uint16Array.BYTES_PER_ELEMENT; // 2
Int32Array.BYTES_PER_ELEMENT; // 4
Uint32Array.BYTES_PER_ELEMENT; // 4
Float32Array.BYTES_PER_ELEMENT; // 4
Float64Array.BYTES_PER_ELEMENT; // 8
```

### byteLength 和 length

-   `byteLength`: `TypedArray` 占据的字节数
-   `length`: `TypedArray` 元素个数

### buffer

`TypedArray` 实例的 `buffer` 属性会返回内存中对应的 `ArrayBuffer` 对象; 为只读属性.

```js
const a = new Uint32Array(8);
const b = new Int32Array(a.buffer);
console.log(a, b);
```

### slice()

`TypeArray` 实例的 `slice` 方法可以返回一个指定位置的新的 `TypedArray` 实例.

```js
const view = new Int16Array(8);
console.log(view.slice(0, 5));
```

<br>

## TypedArray 行为

从很多方面看, 定型数组与普通数组都很相似. 定型数组支持如下操作符,方法和属性:

-   `[]`: 读取或写入数组元素
-   `length`: 数组长度
-   `copyWithin()`: 复制数组元素
-   `entries()`: 返回一个迭代器, 用于遍历数组的索引和值
-   `every()`: 判断数组是否满足某个条件
-   `fill()`: 填充数组
-   `filter()`: 返回满足某个条件的数组元素
-   `find()`: 返回满足某个条件的第一个数组元素
-   `findIndex()`: 返回满足某个条件的第一个数组元素的索引
-   `forEach()`: 遍历数组
-   `indexOf()`: 返回数组元素的索引
-   `join()`: 将数组元素连接成字符串
-   `keys()`: 返回一个迭代器, 用于遍历数组的索引
-   `lastIndexOf()`: 返回数组元素的最后一个索引
-   `map()`: 返回一个新数组, 新数组的元素是对原数组元素的处理结果
-   `reduce()`: 从左到右遍历数组, 将数组元素组合成一个值
-   `reduceRight()`: 从右到左遍历数组, 将数组元素组合成一个值
-   `reverse()`: 反转数组元素的顺序
-   `slice()`: 返回数组的一个片段
-   `some()`: 判断数组是否有元素满足某个条件
-   `sort()`: 对数组元素进行排序
-   `toLocaleString()`: 返回数组元素的本地化字符串
-   `toString()`: 返回数组元素的字符串表示
-   `values()`: 返回一个迭代器, 用于遍历数组的值

其中, 返回新数组的方法也会返回包含同样元素类型 (element type) 的新定型数组:

```js
const ints = new Int16Array([1, 2, 3]);
const doubleints = ints.map((x) => 2 * x);
console.log(doubleints instanceof Int16Array); // true
```

定型数组有一个 `Symbol.iterator` 符号属性, 因此可以通过 `for..of` 循环和扩展操作符来操作:

```js
const ints = new Int16Array([1, 2, 3]);
for (const int of ints) {
    console.log(int); // 1 2 3
}
console.log(Math.max(...ints)); // 3
```

<br>

## 合并,复制和修改定型数组

定型数组同样使用数组缓冲来存储数据, 而数组缓冲无法调整大小. 因此, 下列方法不适用于定型数组:

-   `concat()`: 合并数组
-   `push()`: 向数组末尾添加元素
-   `pop()`: 从数组末尾删除元素
-   `shift()`: 从数组开头删除元素
-   `unshift()`: 向数组开头添加元素
-   `splice()`: 从数组中删除元素

不过, 定型数组也提供了两个新方法, 可以快速向外或向内复制数据: `set` 和 `subarray`.

### set 方法

`set` 从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置:

```js
// 创建长度为 8 的 int16 数组
const container = new Int16Array(8);

// 把定型数组复制为前 4 个值
// 偏移量默认为索引 0
container.set(Int8Array.of(1, 2, 3, 4));
console.log(container); // [1,2,3,4,0,0,0,0]

// 把普通数组复制为后4 个值
// 偏移量4 表示从索引4 开始插入
container.set([5, 6, 7, 8], 4);
console.log(container); // [1,2,3,4,5,6,7,8]

// 溢出会抛出错误
container.set([5, 6, 7, 8], 7); // RangeError
```

### subarray 方法

`subarray` 会基于从原始定型数组中复制的值返回一个新定型数组. 复制值时的开始索引和结束索引是可选的:

```js
const source = Int16Array.of(2, 4, 6, 8);

// 把整个数组复制为一个同类型的新数组
const fullCopy = source.subarray();
console.log(fullCopy); // [2, 4, 6, 8]

// 从索引 2 开始复制数组
const halfCopy = source.subarray(2);
console.log(halfCopy); // [6, 8]

// 从索引 1 开始复制到索引 3
const partialCopy = source.subarray(1, 3);
console.log(partialCopy); // [4, 6]
```

### 手动拼接定型数组

定型数组没有原生的拼接能力, 但使用定型数组 API 提供的很多工具可以手动构建:

```js
// 第一个参数是应该返回的数组类型
// 其余参数是应该拼接在一起的定型数组
function typedArrayConcat(typedArrayConstructor, ...typedArrays) {
    // 计算所有数组中包含的元素总数
    const numElements = typedArrays.reduce((x, y) => (x.length || x) + y.length);
    // 按照提供的类型创建一个数组, 为所有元素留出空间
    const resultArray = new typedArrayConstructor(numElements);
    // 依次转移数组
    let currentOffset = 0;
    typedArrays.map((x) => {
        resultArray.set(x, currentOffset);
        currentOffset += x.length;
    });
    return resultArray;
}
const concatArray = typedArrayConcat(
    Int32Array,
    Int8Array.of(1, 2, 3),
    Int16Array.of(4, 5, 6),
    Float32Array.of(7, 8, 9)
);
console.log(concatArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(concatArray instanceof Int32Array); // true
```

<br>

## 下溢和上溢

定型数组中值的下溢和上溢不会影响到其他索引, 但仍然需要考虑数组的元素应该是什么类型. 定型数组对于可以存储的每个索引只接受一个相关位, 而不考虑它们对实际数值的影响. 以下代码演示了如何处理下溢和上溢:

```js
// 长度为 2 的有符号整数数组
// 每个索引保存一个二补数形式的有符号整数
// 范围是 -128 (-1 * 2^7) ~ 127 (2^7-1)
const ints = new Int8Array(2);

// 长度为 2 的无符号整数数组
// 每个索引保存一个无符号整数
// 范围是 0 ~ 255 (2^7-1)
const unsignedInts = new Uint8Array(2);

// 上溢的位不会影响相邻索引
// 索引只取最低有效位上的 8 位
unsignedInts[1] = 256; // 0x100
console.log(unsignedInts); // [0, 0]
unsignedInts[1] = 511; // 0x1FF
console.log(unsignedInts); // [0, 255]

// 下溢的位会被转换为其无符号的等价值
// 0xFF 是以二补数形式表示的 -1 (截取到 8 位),
// 但 255 是一个无符号整数
unsignedInts[1] = -1; // 0xFF (truncated to 8 bits)
console.log(unsignedInts); // [0, 255]

// 上溢自动变成二补数形式
// 0x80 是无符号整数的 128, 是二补数形式的 -128
ints[1] = 128; // 0x80
console.log(ints); // [0, -128]

// 下溢自动变成二补数形式
// 0xFF 是无符号整数的 255, 是二补数形式的 -1
ints[1] = 255; // 0xFF
console.log(ints); // [0, -1]
```

除了 8 种元素类型, 还有一种 "夹板" 数组类型: `Uint8ClampedArray`, 不允许任何方向溢出. 超出最大值 255 的值会被向下舍入为 255, 而小于最小值 0 的值会被向上舍入为 0.

```js
const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256]);
console.log(clampedInts); // [0, 0, 255, 255]
```

按照 JS 之父 Brendan Eich 的说法: "Uint8ClampedArray 完全是 HTML5canvas 元素的历史留存. 除非真的做跟 canvas 相关的开发, 否则不要使用它."

<br><br>

# DataView

`DataView` 视图是一个可以从二进制 `ArrayBuffer` 对象中读写多种数值类型的底层接口, 使用它时, 不用考虑不同平台的字节序问题; `DataView` 视图提供更多操作选项, 且支持设定字节序.

`ArrayBuffer` 对象的各种 `TypedArray` 视图, 本来是用于向网卡,声卡之类的本机设备传送数据, 所以使用本机的字节序就可以了; 而 `DataView` 视图的设计目的, 是用来处理网络设备传来的数据, 所以大端字节序或小端字节序是可以自行设定的.

<br>

## 创建 DataView

```js
new DataView(buffer [, byteOffset [, byteLength]])
```

1. `buffer`: 一个已经存在的 `ArrayBuffer` 对象, `DataView` 对象的数据源
2. `byteOffset`: 可选, 此 `DataView` 对象的第 1 个字节在 buffer 中的字节偏移. 如果未指定, 则默认从第 1 个字节开始
3. `byteLength`: 可选, 此 `DataView` 对象的字节长度. 如果未指定, 这个视图的长度将匹配 buffer 的长度

```js
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);
console.log(view);
```

<br>

## DataView 属性

-   `buffer`: 返回对应的 `ArrayBuffer` 对象
-   `byteLength`: 返回占据的内存字节长度
-   `byteOffset`: 返回当前视图从对应的 `ArrayBuffer` 对象的哪个字节开始

```js
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);
view.buffer;
view.byteLength;
view.byteOffset;
```

<br>

## 读取内存

`DataView` 实例提供了以下方法来读取内存, 它们的参数都是一个字节序号, 表示开始读取的字节位置:

-   `getInt8`: 读取 1 个字节, 返回一个 8 位整数
-   `getUint8`: 读取 1 个字节, 返回一个无符号的 8 位整数
-   `getInt16`: 读取 2 个字节, 返回一个 16 位整数
-   `getUint16`: 读取 2 个字节, 返回一个无符号的 16 位整数
-   `getInt32`: 读取 4 个字节, 返回一个 32 位整数
-   `getUint32`: 读取 4 个字节, 返回一个无符号的 32 位整数
-   `getFloat32`: 读取 4 个字节, 返回一个 32 位浮点数
-   `getFloat64`: 读取 8 个字节, 返回一个 64 位浮点数

```js
const buffer = new ArrayBuffer(24);
const view = new DataView(buffer);

// 从第 1 个字节读取一个 8 位无符号整数
const view1 = view.getUint8(0);

// 从第 2 个字节读取一个 16 位无符号整数
const view2 = view.getUint16(1);

// 从第 4 个字节读取一个 16 位无符号整数
const view3 = view.getUint16(3);
```

<br>

## 写入内存

`DataView` 实例提供了以下方法来写入内存:
它们都接受 2 个参数: ① 开始写入数据的字节序号,② 写入的数据

-   `setInt8`: 写入 1 个字节的 8 位整数
-   `setUint8`: 写入 1 个字节的 8 位无符号整数
-   `setInt16`: 写入 2 个字节的 16 位整数
-   `setUint16`: 写入 2 个字节的 16 位无符号整数
-   `setInt32`: 写入 4 个字节的 32 位整数
-   `setUint32`: 写入 4 个字节的 32 位无符号整数
-   `setFloat32`: 写入 4 个字节的 32 位浮点数
-   `setFloat64`: 写入 8 个字节的 64 位浮点数

<br>

## ElementType

`DataView` 对存储在缓冲内的数据类型没有预设. 它暴露的 API 强制开发者在读,写时指定一个 ElementType, 然后 `DataView` 就会忠实地为读,写而完成相应的转换.

ES6 支持 8 种不同的 ElementType:

| 类型    | 字节 | 描述                  | 范围                            |
| ------- | ---- | --------------------- | ------------------------------- |
| Int8    | 1    | 8 位有符号整数        | -128 到 127                     |
| Uint8   | 1    | 8 位无符号整数        | 0 到 255                        |
| Int16   | 2    | 16 位有符号整数       | -32,768 到 32,767               |
| Uint16  | 2    | 16 位无符号整数       | 0 到 65,535                     |
| Int32   | 4    | 32 位有符号整数       | -2,147,483,648 到 2,147,483,647 |
| Uint32  | 4    | 32 位无符号整数       | 0 到 4,294,967,295              |
| Float32 | 4    | 32 位 IEEE-754 浮点数 | 1.2×10^-38 到 3.4×10^38         |
| Float64 | 8    | 64 位 IEEE-754 浮点数 | 5.0×10^-324 到 1.8×10^308       |

`DataView` 为上表中的每种类型都暴露了 get 和 set 方法, 这些方法使用 byteOffset (字节偏移量) 定位要读取或写入值的位置. 类型是可以互换使用的, 如下例所示:

```js
// 在内存中分配两个字节并声明一个 DataView
const buf = new ArrayBuffer(2);
const view = new DataView(buf);

// 说明整个缓冲确实所有二进制位都是 0
// 检查第一个和第二个字符
console.log(view.getInt8(0)); // 0
console.log(view.getInt8(1)); // 0

// 检查整个缓冲
console.log(view.getInt16(0)); // 0

// 将整个缓冲都设置为 1
// 255 的二进制表示是 11111111 (2^8-1)
view.setUint8(0, 255);

// DataView 会自动将数据转换为特定的 ElementType
// 255 的十六进制表示是 0xFF
view.setUint8(1, 0xff);

// 现在, 缓冲里都是 1 了
// 如果把它当成二补数的有符号整数, 则应该是 -1
console.log(view.getInt16(0)); // -1
```

<br>

## 字节序

前面例子中的缓冲有意回避了字节序的问题. "字节序" 指的是计算系统维护的一种字节顺序的约定. `DataView` 只支持两种约定: 大端字节序和小端字节序. 大端字节序也称为 "网络字节序", 意思是最高有效位保存在第一个字节, 而最低有效位保存在最后一个字节. 小端字节序正好相反, 即最低有效位保存在第一个字节, 最高有效位保存在最后一个字节.

JS 运行时所在系统的原生字节序决定了如何读取或写入字节, 但 `DataView` 并不遵守这个约定. 对一段内存而言, `DataView` 是一个中立接口, 它会遵循你指定的字节序. `DataView` 的所有 API 方法都以大端字节序作为默认值, 但接收一个可选的布尔值参数, 设置为 true 即可启用小端字节序.

```js
// 在内存中分配两个字节并声明一个 DataView
const buf = new ArrayBuffer(2);
const view = new DataView(buf);

// 填充缓冲, 让第一位和最后一位都是 1
view.setUint8(0, 0x80); // 设置最左边的位等于 1
view.setUint8(1, 0x01); // 设置最右边的位等于 1
// 缓冲内容 (为方便阅读, 人为加了空格)
// 0x8   0x0   0x0   0x1
// 1000000000000001

// 按大端字节序读取 Uint16
// 0x80 是高字节, 0x01 是低字节
// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769
console.log(view.getUint16(0)); // 32769

// 按小端字节序读取 Uint16
// 0x01 是高字节, 0x80 是低字节
// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384
console.log(view.getUint16(0, true)); // 384

// 按大端字节序写入 Uint16
view.setUint16(0, 0x0004);
// 缓冲内容 (为方便阅读, 人为加了空格)
// 0x0   0x0   0x0   0x4
// 0000000000000100
console.log(view.getUint8(0)); // 0
console.log(view.getUint8(1)); // 4

// 按小端字节序写入Uint16
view.setUint16(0, 0x0002, true);
// 缓冲内容 (为方便阅读, 人为加了空格)
// 0x0   0x2   0x0   0x0
// 0000001000000000
console.log(view.getUint8(0)); // 2
console.log(view.getUint8(1)); // 0
```

<br>

## 边界情形

`DataView` 完成读,写操作的前提是必须有充足的缓冲区, 否则就会抛出 RangeError:

```js
const buf = new ArrayBuffer(6);
const view = new DataView(buf);

// 尝试读取部分超出缓冲范围的值
view.getInt32(4); // RangeError

// 尝试读取超出缓冲范围的值
view.getInt32(8); // RangeError

// 尝试读取超出缓冲范围的值
view.getInt32(-1); // RangeError

// 尝试写入超出缓冲范围的值
view.setInt32(4, 123); // RangeError
```

`DataView` 在写入缓冲里会尽最大努力把一个值转换为适当的类型, 后备为 0. 如果无法转换, 则抛出错误:

```js
const buf = new ArrayBuffer(1);
const view = new DataView(buf);

view.setInt8(0, 1.5);
console.log(view.getInt8(0)); // 1

view.setInt8(0, [4]);
console.log(view.getInt8(0)); // 4

view.setInt8(0, "f");
console.log(view.getInt8(0)); // 0

view.setInt8(0, Symbol()); // TypeError
```

<br><br>

# ArrayBuffer 实例方法

## slice 方法

`ArrayBuffer.prototype.slice()` 用来截取 `ArrayBuffer` 实例, 返回一个新的 `ArrayBuffer` 实例.

```js
const buffer = new ArrayBuffer(16);
console.log(buffer.slice(0, 8)); // 16
```

上例中, 从 buffer 对象上将前 8 个字节截取出来, 生成一个新的 `ArrayBuffer` 对象. 这个方法实际上有 2 步操作: ① 分配一段指定长度的内存,② 拷贝原来 `ArrayBuffer` 对象的指定部分.

<br>

## isView 方法

`ArrayBuffer.isView()` 如果参数是 `ArrayBuffer` 的视图实例则返回 `true`, 例如类型数组对象或 `DataView` 对象; 否则返回 `false`. 简单来说, 这个方法就是用来判断参数是为 [TypedArray 实例] / [DataView 实例].

```js
const buffer = new ArrayBuffer(16);
ArrayBuffer.isView(buffer); // false

const view = new Uint32Array(buffer);
ArrayBuffer.isView(view); // true
```

<br><br>

# 格式转换

## ArrayBuffer → Blob

```js
const blob = new Blob([new Uint8Array(buffer, byteOffset, length)]);
```

<br>

## ArrayBuffer → Base64

```js
const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));
```

<br>

## ArrayBuffer → String

```js
// 使用 TextDecoder (推荐)
function arrayBufferToString(buffer) {
    const decoder = new TextDecoder();
    return decoder.decode(buffer);
}

// 使用传统方法
function arrayBufferToStringLegacy(buffer) {
    return String.fromCharCode.apply(null, new Uint8Array(buffer));
}
```

<br>

## String → ArrayBuffer

```js
// 使用 TextEncoder (推荐)
function stringToArrayBuffer(str) {
    const encoder = new TextEncoder();
    return encoder.encode(str).buffer;
}

// 使用传统方法
function stringToArrayBufferLegacy(str) {
    const buffer = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节
    const bufferView = new Uint16Array(buffer);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufferView[i] = str.charCodeAt(i);
    }
    return buffer;
}
```

<br><br>

# 实际应用场景

## 1. 文件处理

```js
// 读取文件内容为 ArrayBuffer
function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(file);
    });
}

// 使用示例
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (file) {
        const buffer = await readFileAsArrayBuffer(file);
        console.log("文件大小:", buffer.byteLength);
    }
});
```

<br>

## 2. 网络数据传输

```js
// 发送 ArrayBuffer 数据
async function sendArrayBuffer(buffer) {
    const response = await fetch("/api/upload", {
        method: "POST",
        headers: { "Content-Type": "application/octet-stream" },
        body: buffer,
    });
    return response.json();
}

// 接收 ArrayBuffer 数据
async function receiveArrayBuffer() {
    const response = await fetch("/api/download");
    const buffer = await response.arrayBuffer();
    return buffer;
}
```

<br>

## 3. 图像处理

```js
// 处理图像数据
function processImageData(imageData) {
    const buffer = imageData.data.buffer;
    const view = new Uint8Array(buffer);

    // 对像素数据进行处理
    for (let i = 0; i < view.length; i += 4) {
        // 处理 RGBA 数据
        const r = view[i];
        const g = view[i + 1];
        const b = view[i + 2];
        const a = view[i + 3];

        // 应用滤镜效果
        view[i] = Math.min(255, r * 1.2);
        view[i + 1] = Math.min(255, g * 1.2);
        view[i + 2] = Math.min(255, b * 1.2);
    }

    return imageData;
}
```

<br>

## 4. 音频处理

```js
// 处理音频数据
function processAudioData(audioBuffer) {
    const buffer = audioBuffer.getChannelData(0).buffer;
    const view = new Float32Array(buffer);

    // 应用音频效果
    for (let i = 0; i < view.length; i++) {
        view[i] = view[i] * 0.5; // 降低音量
    }

    return audioBuffer;
}
```

<br><br>

# 性能优化

## 1. 内存管理

```js
// 及时释放不需要的 ArrayBuffer
function processData(data) {
    const buffer = new ArrayBuffer(data.length);
    const view = new Uint8Array(buffer);

    // 处理数据
    for (let i = 0; i < data.length; i++) {
        view[i] = data[i];
    }

    // 处理完成后, 让垃圾回收器回收
    return view;
}
```

<br>

## 2. 大文件处理

```js
// 分块处理大文件
async function processLargeFile(file, chunkSize = 1024 * 1024) {
    const totalChunks = Math.ceil(file.size / chunkSize);

    for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);

        const buffer = await readFileAsArrayBuffer(chunk);
        await processChunk(buffer);

        // 显示进度
        console.log(`处理进度: ${((i + 1) / totalChunks) * 100}%`);
    }
}
```

<br>

## 3. 流式处理

```js
// 使用 ReadableStream 处理数据
async function processStream(stream) {
    const reader = stream.getReader();
    const chunks = [];

    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            chunks.push(value);
        }

        // 合并所有块
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
        const combined = new Uint8Array(totalLength);
        let offset = 0;

        for (const chunk of chunks) {
            combined.set(new Uint8Array(chunk), offset);
            offset += chunk.byteLength;
        }

        return combined.buffer;
    } finally {
        reader.releaseLock();
    }
}
```

<br><br>

# 注意事项

## 1. 内存限制

-   `ArrayBuffer` 分配的内存不能超过 `Number.MAX_SAFE_INTEGER` (`2^53-1`) 字节
-   在实际应用中, 浏览器可能对单个 `ArrayBuffer` 的大小有更严格的限制

## 2. 类型安全

-   确保 `TypedArray` 和 `DataView` 的字节偏移量和长度在有效范围内
-   注意不同数据类型的字节长度差异

## 3. 字节序处理

-   在处理网络数据时, 注意字节序的转换
-   使用 `DataView` 时明确指定字节序参数

## 4. 性能考虑

-   对于大量数据的处理, 考虑使用 `Web Workers` 避免阻塞主线程
-   及时释放不需要的 `ArrayBuffer` 引用, 让垃圾回收器回收内存

## 5. 安全考虑

-   在处理用户上传的文件时, 验证文件类型和大小
-   避免将敏感数据存储在 `ArrayBuffer` 中而不进行适当的清理

通过 `ArrayBuffer` 对象, 开发者可以方便地处理二进制数据, 实现文件上传、图像处理、音频处理等功能, 为 Web 应用提供强大的数据处理能力.

<br>
