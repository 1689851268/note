# Blob

`Blob` (Binary Large Object) 对象表示一个不可变、原始数据的类文件对象. 它的数据可以按文本或二进制的格式进行读取, 也可以转换成 `ReadableStream` 来用于数据操作.

Blob 表示的不一定是 JavaScript 原生格式的数据. `File` 接口基于 `Blob`, 继承了 `Blob` 的功能并将其扩展使其支持用户系统上的文件.

<br><br>

# 创建 Blob 实例

## 基本语法

```js
new Blob(array[, options])
```

**参数:**

-   `array`: 可迭代对象, 比如 `Array`、`TypedArray`、`ArrayBuffer`、`DataView`、`Blob`、`String` 等等
-   `options`: 可选参数对象
    -   `type`: 将会被存储到 blob 中的数据的 MIME 类型. 默认为 `""`, 表示一个无类型的 `Blob`, 此时文件不会损毁, 也无法被正常识别
    -   `endings`: 用于指定文本的行结束符. `"transparent"` - 保持 blob 中的行结束符不变 (默认); `"native"` - 行结束符会被更改为适合宿主文件系统的换行符

<br>

## 基本示例

```js
// 创建文本 Blob
const textBlob = new Blob(["Hello World"], { type: "text/plain" });
console.log(textBlob.size); // 11
console.log(textBlob.type); // "text/plain"

// 创建 JSON Blob
const jsonBlob = new Blob([JSON.stringify({ name: "张三", age: 25 })], {
    type: "application/json",
});

// 创建 HTML Blob
const htmlBlob = new Blob(["<h1>Hello World</h1>"], { type: "text/html" });
```

<br><br>

# Blob 实例属性

## size

数据的字节数, 只读属性.

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });
console.log(blob.size); // 11
```

<br>

## type

数据的 MIME 类型, 只读属性. 如果类型未知, 则为空字符串.

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });
console.log(blob.type); // "text/plain"

const unknownBlob = new Blob(["Hello World"]);
console.log(unknownBlob.type); // ""
```

<br><br>

# Blob 实例方法

## `slice()`

`slice([start [, end [, contentType]]])`: 返回一个新的 Blob 实例

**参数:**

-   `start`: 切片的开始下标; 默认为 `0`; 可以为负数
-   `end`: 切片的结束下标; 默认为 `blob.size`; 可以为负数
-   `contentType`: 设置新 Blob 实例的 MIME 类型; 默认为 `""`

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });
const subBlob = blob.slice(0, 5);
console.log(subBlob.size); // 5
console.log(subBlob.type); // ""

// 使用负数索引
const endBlob = blob.slice(-5); // 从倒数第 5 个字符开始到结尾
console.log(endBlob.size); // 5

// 指定新的 MIME 类型
const typedBlob = blob.slice(0, 5, "text/html");
console.log(typedBlob.type); // "text/html"
```

<br>

## `text()`

返回一个 Promise 对象, 会兑现一个包含 blob 内容的 UTF-8 格式的字符串.

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });

// 使用 async/await
const text = await blob.text();
console.log(text); // "Hello World"

// 使用 Promise
blob.text().then((text) => {
    console.log(text); // "Hello World"
});
```

<br>

## `arrayBuffer()`

返回一个 Promise 对象, 会兑现一个包含 blob 二进制数据内容的 ArrayBuffer 对象.

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });

// 使用 async/await
const buffer = await blob.arrayBuffer();
console.log(buffer.byteLength); // 11

// 使用 Promise
blob.arrayBuffer().then((buffer) => {
    console.log(buffer.byteLength); // 11
});
```

<br>

## `stream()`

返回一个 ReadableStream 对象, 读取它将返回包含在 Blob 中的数据.

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });

// 获取 ReadableStream
const stream = blob.stream();
const reader = stream.getReader();

// 读取数据
reader.read().then(({ value, done }) => {
    if (!done) {
        console.log(new TextDecoder().decode(value)); // "Hello World"
    }
});

// 或者使用 for await...of
async function readStream() {
    const stream = blob.stream();
    for await (const chunk of stream) {
        console.log(new TextDecoder().decode(chunk)); // "Hello World"
    }
}
```

<br><br>

# 格式转换

## Blob → ArrayBuffer

```js
// 方法 1: 使用 arrayBuffer() 方法 (推荐)
const blob = new Blob(["Hello World"], { type: "text/plain" });
const buffer = await blob.arrayBuffer();

// 方法 2: 使用 FileReader
function blobToArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(blob);
    });
}
const buffer = await blobToArrayBuffer(blob);
```

<br>

## Blob → Base64

```js
// 方法 1: 使用 FileReader
function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}
const base64 = await blobToBase64(blob);
console.log(base64); // "data:text/plain;base64,SGVsbG8gV29ybGQ="

// 方法 2: 使用 arrayBuffer() + btoa()
const buffer = await blob.arrayBuffer();
const base64 = btoa(String.fromCharCode(...new Uint8Array(buffer)));
```

<br>

## Blob → Object URL

```js
const blob = new Blob(["Hello World"], { type: "text/plain" });
const objectUrl = URL.createObjectURL(blob);
console.log(objectUrl); // "blob:http://localhost:3000/550e8400-e29b-41d4-a716-446655440000"

// 使用完毕后释放内存
URL.revokeObjectURL(objectUrl);
```

<br>

## Blob → String

```js
// 方法 1: 使用 text() 方法 (推荐)
const text = await blob.text();

// 方法 2: 使用 FileReader
function blobToString(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(blob);
    });
}
```

<br><br>

# 实际应用场景

## 1. 文件下载

```js
// 创建文本文件并下载
function downloadTextFile(content, filename) {
    const blob = new Blob([content], { type: "text/plain" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
}

// 使用示例
downloadTextFile("Hello World", "hello.txt");
```

<br>

## 2. 图片预览

```js
// 从文件输入创建图片预览
function previewImage(file) {
    const blob = new Blob([file], { type: file.type });
    const url = URL.createObjectURL(blob);

    const img = document.createElement("img");
    img.src = url;
    img.style.maxWidth = "300px";
    document.body.appendChild(img);

    // 图片加载完成后释放 URL
    img.onload = () => {
        URL.revokeObjectURL(url);
    };
}

// 使用示例
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file && file.type.startsWith("image/")) {
        previewImage(file);
    }
});
```

<br>

## 3. 大文件分片上传

```js
// 将大文件分片上传
async function uploadLargeFile(file, chunkSize = 1024 * 1024) {
    const totalChunks = Math.ceil(file.size / chunkSize);

    for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);

        // 上传分片
        await uploadChunk(chunk, i, totalChunks);
    }
}

// 上传单个分片
async function uploadChunk(chunk, index, total) {
    const formData = new FormData();
    formData.append("chunk", chunk);
    formData.append("index", index);
    formData.append("total", total);

    const response = await fetch("/upload", { method: "POST", body: formData });

    return response.json();
}
```

<br>

## 4. 数据压缩

```js
// 使用 CompressionStream 压缩数据
async function compressData(data) {
    const blob = new Blob([data], { type: "application/octet-stream" });
    const stream = blob.stream();

    const compressedStream = stream.pipeThrough(new CompressionStream("gzip"));
    const compressedBlob = await new Response(compressedStream).blob();

    console.log(`原始大小: ${blob.size} 字节`);
    console.log(`压缩后大小: ${compressedBlob.size} 字节`);

    return compressedBlob;
}
```

<br>

## 5. 数据加密

```js
// 使用 Web Crypto API 加密 Blob 数据
async function encryptBlob(blob, password) {
    // 将 Blob 转换为 ArrayBuffer
    const buffer = await blob.arrayBuffer();

    // 生成密钥
    const key = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(password),
        {
            name: "PBKDF2",
        },
        false,
        ["deriveBits", "deriveKey"]
    );

    // 派生加密密钥
    const derivedKey = await crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt: crypto.getRandomValues(new Uint8Array(16)),
            iterations: 100000,
            hash: "SHA-256",
        },
        key,
        {
            name: "AES-GCM",
            length: 256,
        },
        false,
        ["encrypt"]
    );

    // 加密数据
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, derivedKey, buffer);

    // 组合 IV 和加密数据
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);

    return new Blob([combined], { type: "application/octet-stream" });
}
```

<br><br>

# 性能优化

## 内存管理

```js
// 及时释放 Object URL
function createAndUseBlob(data) {
    const blob = new Blob([data], { type: "text/plain" });
    const url = URL.createObjectURL(blob);

    // 使用 URL
    const link = document.createElement("a");
    link.href = url;
    link.download = "file.txt";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // 及时释放内存
    URL.revokeObjectURL(url);
}
```

<br>

## 大文件处理

```js
// 分块处理大文件, 避免内存溢出
async function processLargeBlob(blob, chunkSize = 1024 * 1024) {
    const chunks = [];
    let offset = 0;

    while (offset < blob.size) {
        const chunk = blob.slice(offset, offset + chunkSize);
        const processedChunk = await processChunk(chunk);
        chunks.push(processedChunk);
        offset += chunkSize;
    }

    return new Blob(chunks);
}

// 处理单个分块
async function processChunk(chunk) {
    // 模拟处理逻辑
    const buffer = await chunk.arrayBuffer();
    return new Uint8Array(buffer);
}
```

<br>

## 流式处理

```js
// 使用 ReadableStream 处理大文件
async function processBlobStream(blob) {
    const stream = blob.stream();
    const reader = stream.getReader();
    const chunks = [];

    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            // 处理数据块
            const processedChunk = await processChunkData(value);
            chunks.push(processedChunk);
        }
    } finally {
        reader.releaseLock();
    }

    return new Blob(chunks);
}
```

<br><br>

# 注意事项

## 1. 内存管理

-   使用 `URL.createObjectURL()` 创建的 URL 会占用内存, 使用完毕后应调用 `URL.revokeObjectURL()` 释放
-   大文件处理时应考虑分块处理, 避免一次性加载到内存

## 2. 类型安全

-   确保 Blob 的 MIME 类型正确设置, 以便浏览器正确处理
-   在处理用户上传的文件时, 应验证文件类型和大小

## 3. 异步处理

-   Blob 的 `text()` 和 `arrayBuffer()` 方法返回 Promise, 需要使用 `await` 或 `.then()` 处理
-   错误处理应包含在 Promise 的 `.catch()` 中

## 4. 跨域限制

-   Blob URL 仅在创建它的文档中有效
-   不能跨域共享 Blob 对象

通过 Blob 对象, 开发者可以方便地处理二进制数据, 实现文件上传、下载、预览等功能, 为 Web 应用提供强大的文件处理能力.

<br>
