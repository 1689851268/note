# dispatchEvent 方法

## 概述

`dispatchEvent` 是 `EventTarget` 接口的方法, 用于在指定的 DOM 元素上以编程方式触发事件. 该方法允许开发者手动分发事件对象, 并触发所有注册在该元素上的事件监听器.

<br><br>

# 基本语法

```javascript
target.dispatchEvent(event);
```

-   **target**: 要触发事件的目标元素
-   **event**: 一个 Event 对象或其派生类的实例
-   **返回值**: 布尔值, 如果事件是可取消的且至少一个事件处理器调用了 `Event.preventDefault()`, 则返回 `false`, 否则返回 `true`

<br><br>

# 使用步骤

## 1. 创建事件对象

使用 `Event` 构造函数或其派生类创建事件对象:

```javascript
// 创建普通事件
const event = new Event("click", {
    bubbles: true, // 是否冒泡
    cancelable: true, // 是否可取消
    composed: false, // 是否穿越 Shadow DOM 边界
});

// 创建自定义事件 (可携带数据)
const customEvent = new CustomEvent("myEvent", {
    bubbles: true,
    cancelable: true,
    detail: { message: "Hello World" }, // 自定义数据
});

// 创建鼠标事件
const mouseEvent = new MouseEvent("click", {
    bubbles: true,
    cancelable: true,
    clientX: 100,
    clientY: 200,
});

// 创建键盘事件
const keyEvent = new KeyboardEvent("keydown", {
    bubbles: true,
    cancelable: true,
    key: "Enter",
    code: "Enter",
});
```

<br>

## 2. 触发事件

在目标元素上调用 `dispatchEvent` 方法:

```javascript
const button = document.querySelector("#myButton");
button.dispatchEvent(event);
```

<br><br>

# 实际应用示例

## 示例 1: 模拟按钮点击

```javascript
const button = document.getElementById("submit");

// 添加事件监听器
button.addEventListener("click", function (e) {
    console.log("按钮被点击了!");
});

// 创建并触发点击事件
const clickEvent = new MouseEvent("click", {
    bubbles: true,
    cancelable: true,
});

button.dispatchEvent(clickEvent); // 输出: 按钮被点击了!
```

<br>

## 示例 2: 自定义事件通信

```javascript
// 创建自定义事件
const dataUpdateEvent = new CustomEvent("dataUpdate", {
    bubbles: true,
    detail: {
        userId: 123,
        username: "Alice",
        timestamp: Date.now(),
    },
});

// 监听自定义事件
document.addEventListener("dataUpdate", function (e) {
    console.log("用户数据:", e.detail);
    // 输出: 用户数据: { userId: 123, username: 'Alice', timestamp: ... }
});

// 触发自定义事件
document.dispatchEvent(dataUpdateEvent);
```

<br>

## 示例 3: 表单提交验证

```javascript
const form = document.getElementById("myForm");

form.addEventListener("submit", function (e) {
    console.log("表单提交中...");

    // 验证失败时阻止默认行为
    if (!validateForm()) {
        e.preventDefault();
        console.log("表单验证失败");
    }
});

// 手动触发表单提交
const submitEvent = new Event("submit", {
    bubbles: true,
    cancelable: true,
});

const result = form.dispatchEvent(submitEvent);
console.log("事件是否被阻止:", !result);
```

<br>

## 示例 4: 事件冒泡演示

```javascript
const parent = document.getElementById("parent");
const child = document.getElementById("child");

parent.addEventListener("customEvent", function (e) {
    console.log("父元素捕获到事件");
});

child.addEventListener("customEvent", function (e) {
    console.log("子元素触发事件");
});

// 在子元素上触发事件
const bubbleEvent = new Event("customEvent", {
    bubbles: true, // 开启冒泡
});

child.dispatchEvent(bubbleEvent);
// 输出:
// 子元素触发事件
// 父元素捕获到事件
```

<br><br>

# 重要特性

## 1. 事件冒泡与捕获

`dispatchEvent` 触发的事件会按照 W3C DOM 事件规范的标准事件流执行:

```
捕获阶段 (Capture Phase) → 目标阶段 (Target Phase) → 冒泡阶段 (Bubble Phase)
```

**阶段说明**:

-   **捕获阶段**: 事件从 `window` 向下传播, 经过目标元素的所有祖先元素
-   **目标阶段**: 事件到达目标元素本身
-   **冒泡阶段**: 事件从目标元素向上传播, 回到 `window`

```javascript
const parent = document.getElementById("parent");
const target = document.getElementById("target");

// 父元素 - 捕获阶段
parent.addEventListener(
    "myEvent",
    () => {
        console.log("1. 父元素 - 捕获阶段");
    },
    true
);

// 目标元素 - 冒泡阶段监听器 (先注册)
target.addEventListener("myEvent", () => {
    console.log("3. 目标元素 - 冒泡监听器");
});

// 目标元素 - 捕获阶段监听器 (后注册)
target.addEventListener(
    "myEvent",
    () => {
        console.log("2. 目标元素 - 捕获监听器");
    },
    true
);

// 父元素 - 冒泡阶段
parent.addEventListener("myEvent", () => {
    console.log("4. 父元素 - 冒泡阶段");
});

target.dispatchEvent(new Event("myEvent", { bubbles: true }));

// 输出顺序:
// 1. 父元素 - 捕获阶段
// 2. 目标元素 - 捕获监听器  ← 捕获阶段的监听器先执行
// 3. 目标元素 - 冒泡监听器  ← 冒泡阶段的监听器后执行
// 4. 父元素 - 冒泡阶段
```

**重要**: 在目标元素上, 捕获阶段的监听器 (`useCapture: true`) 会先于冒泡阶段的监听器 (`useCapture: false`) 执行, 而不是按注册顺序.

<br>

## 2. 事件可信度 (isTrusted)

通过 `dispatchEvent` 触发的事件, `isTrusted` 属性为 `false`:

```javascript
button.addEventListener("click", function (e) {
    console.log("事件可信度:", e.isTrusted);
});

// 用户真实点击: isTrusted = true
// 代码触发:
button.dispatchEvent(new Event("click")); // isTrusted = false
```

<br>

## 3. 阻止默认行为

```javascript
const link = document.querySelector("a");

link.addEventListener("click", function (e) {
    e.preventDefault(); // 阻止默认跳转
    console.log("默认行为被阻止");
});

const clickEvent = new MouseEvent("click", {
    cancelable: true, // 必须设置为 true 才能被阻止
});

const result = link.dispatchEvent(clickEvent);
console.log("事件是否被阻止:", !result); // true
```

<br><br>

# 常见应用场景

1. **单元测试**: 模拟用户交互进行组件测试
2. **组件通信**: 跨组件/模块通信, 解耦代码依赖
3. **自动化操作**: 自动填充表单, 自动提交数据
4. **事件转发**: 将一个元素的事件转发到另一个元素
5. **插件系统**: 构建基于事件驱动的插件架构

<br><br>

# 注意事项

1. **事件类型选择**: 根据需要选择合适的事件构造函数

    - 普通事件: `Event`
    - 自定义事件: `CustomEvent`
    - 鼠标事件: `MouseEvent`
    - 键盘事件: `KeyboardEvent`
    - 输入事件: `InputEvent`

2. **bubbles 属性**: 如果需要事件冒泡, 必须显式设置 `bubbles: true`

3. **同步执行**: `dispatchEvent` 是同步执行的, 会立即调用所有监听器

4. **性能考虑**: 频繁触发大量事件可能影响性能, 注意节流/防抖

5. **兼容性**: 现代浏览器均支持, IE9+ 也完全支持

<br><br>

# 与其他方法对比

| 方法            | 用途             | 特点                                 |
| --------------- | ---------------- | ------------------------------------ |
| `dispatchEvent` | 手动触发任意事件 | 灵活, 支持自定义事件, 可控制事件属性 |
| `click()`       | 触发点击事件     | 简单直接, 仅适用于点击               |
| `submit()`      | 触发表单提交     | 不触发 submit 事件监听器             |
| `focus()`       | 设置焦点         | 不触发 focus 事件监听器              |

```javascript
// dispatchEvent 会触发监听器
button.addEventListener("click", () => console.log("clicked"));
button.dispatchEvent(new Event("click")); // 输出: clicked

// click() 也会触发监听器
button.click(); // 输出: clicked

// submit() 不会触发监听器
form.addEventListener("submit", () => console.log("submitted"));
form.submit(); // 不输出任何内容
```

<br><br>

# 参考资源

-   [MDN - EventTarget.dispatchEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent)
-   [MDN - 创建和触发事件](https://developer.mozilla.org/zh-CN/docs/Web/Events/Creating_and_triggering_events)

<br>
