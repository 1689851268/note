# 事件处理模型

单击某个子元素时，该元素称为事件源；单击事件不仅发生在事件源上，也发生在其**所有的父级**上。

**事件流**：捕获阶段 + 冒泡阶段；事件流对应着事件的触发顺序（先捕获、后冒泡）

1. 捕获阶段：父级 → 子级
2. 冒泡阶段：子级 → 父级（浏览器会冒泡到 window 为止）

<img src="picture/image-20210817110017200.png" alt="image-20210817110017200" style="zoom:50%;" />

DOM0 的事件处理函数只能监听冒泡阶段；DOM2 的事件处理函数能监听捕获阶段。

<br>

练一练：

```css
#box1 {
    width: 100px;
    height: 100px;
    background: lightgoldenrodyellow;
}

#box2 {
    width: 50px;
    height: 50px;
    background: lightgreen;
}
```

```html
<div id="box1">
    <div id="box2"></div>
</div>
```

```js
box1.addEventListener(
    'click',
    function () {
        console.log('父级捕获');
    },
    true
);

box2.onclick = function () {
    console.log('子级冒泡');
};

box2.addEventListener(
    'click',
    function () {
        console.log('子级捕获');
    },
    true
);

box1.onclick = function () {
    console.log('父级冒泡');
};
```

<br><br>

# 事件对象

JS 解析引擎会传一个实参给事件处理函数，这个实参就叫做 "事件对象"。通常用形参 `event` 接收：

```html
<div id="box">1</div>
<script>
    box.onclick = function (event) {
        console.log(event);
    };
</script>
```

输出：`PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}`

<br>

事件对象 `event` 中，封装了这次事件的很多细节。eg：点击事件发生时，鼠标当前的位置...

```js
document.addEventListener('mousemove', event => {
    console.log('当前鼠标坐标为' + event.clientX + ',' + event.clientY);
});
```

<br>

## 常用方法

1.  `stopPropagation()` - 阻止事件流。

调用该方法后，事件就不会再沿着事件流继续往后触发 ( propagation 传播 ) ：

```js
box1.addEventListener(
    'click',
    function (event) {
        console.log('父级捕获');
        event.stopPropagation(); // 从这里开始阻止事件流
    },
    true
);

box2.addEventListener(
    'click',
    function () {
        console.log('子级捕获');
    },
    true
);

box2.onclick = function () {
    console.log('子级冒泡');
};

box1.onclick = function () {
    console.log('父级冒泡');
};
```

此时点击子级也不会触发子级的点击事件。

<br>

2.  `preventDefault()` - 阻止默认事件。

在浏览器中，某些元素的某些事件，会有自己的默认行为。比如：

1.  a 元素的 click 事件，会跳转页面
2.  form 元素的 submit 事件，会提交表单，最终导致页面刷新
3.  文本框的 keydown 事件，会将按键文本显示到文本框中

使用 preventDefault 方法即可阻止这些默认行为：

```html
<a id="link" href="http://www.baidu.com">百度</a>
<script>
    link.onclick = function (event) {
        event.preventDefault(); // 超链接的默认点击事件是跳转
        console.log(111);
    };
</script>
```

此时点击超链接也不会跳转页面了。

<br>

## 常用属性

1. `event.type` - 事件的类型。eg：`click`
2. `event.target` - 事件源。即使该元素身上没有监听，也是返回它。
3. `event.currentTarget` - 当前元素，即 `this` 的指向。
4. `event.button` - 区分鼠标左、中、右键（0、1、2）。

<br>

## 常用信息

1. `offsetX` / `offsetY` - - - 鼠标距离 [事件对象] 的左上角

2. `layerX` / `layerY` - - - 鼠标距离 [最近的定位元素] 的左上角（会一直找到 body 标签；自身有定位属性的话就是相对于自身）

3. `clientX` / `clientY` - - - 鼠标距离 [显示区域] 的左上角（与页面是否有滚动无关）

4. `pageX` / `pageY` - - - 鼠标距离 [页面] 的左上角（会加上滚动的距离）

5. `screenX` / `screenY` - - - 鼠标距离 [计算机屏幕] 的左上角（在多屏显示的环境下，范围将增加到屏幕的组合宽高）

6. `x` / `y` - - - `clientX` / `clientY` 的别名（尚在开发中）

-   页面没有滚动时，`page`、`client` 的值相同

<br><br>

# 事件委托

通过事件对象 event 可以得到事件源 target。所以我们可以将子级的事件委托给父级处理。

```html
<ul id="box">
    <li>li1</li>
    <li>li2</li>
    <li>li3</li>
</ul>
<script>
    box.onclick = event => {
        console.log(event.target.innerHTML);
    };
</script>
```

优势：① 不需要循环绑定每个子元素，可以节省浏览器性能；② 添加新元素时，不需要给新元素绑定事件。

<br>
