# Base64

Base64 是一种基于 64 个可打印字符来表示二进制数据的编码方法. 它将任意二进制数据转换为仅包含 ASCII 字符的字符串, 广泛应用于数据传输、存储和处理等领域.

<br><br>

# 编码原理

## 基本概念

Base64 编码使用 64 个可打印字符来表示二进制数据:

-   **大写字母**: A-Z (26 个)
-   **小写字母**: a-z (26 个)
-   **数字**: 0-9 (10 个)
-   **符号**: + 和 / (2 个)
-   **填充符**: = (用于填充)

总计 64 个字符用于编码.

<br>

## 编码过程

1. **分组**: 将原始二进制数据每 3 个字节 (24 位) 分为一组
2. **分割**: 将每组 24 位数据分割成 4 个 6 位的块
3. **映射**: 将每个 6 位块转换为对应的 Base64 字符
4. **填充**: 如果原始数据的字节数不是 3 的倍数, 则在编码结果末尾添加一个或两个 '=' 号

**示例**: 字符串 "Man" 的编码过程

```
M: 01001101 (77)
a: 01100001 (97)
n: 01101110 (110)

合并: 010011010110000101101110
分割: 010011 | 010110 | 000101 | 101110
十进制: 19 | 22 | 5 | 46
Base64: T | W | F | u

结果: "TWFu"
```

<br>

## 数据膨胀

Base64 编码会使数据体积增加约 33% (4/3 倍), 因为每 3 个字节的原始数据会编码为 4 个字符.

<br><br>

# JavaScript 中的 Base64

## 基本 API

JavaScript 提供了两个内置函数进行 Base64 编码和解码:

```js
// 编码: 将字符串转换为 Base64
const encoded = btoa("Hello World");
console.log(encoded); // "SGVsbG8gV29ybGQ="

// 解码: 将 Base64 字符串转换为原始字符串
const decoded = atob("SGVsbG8gV29ybGQ=");
console.log(decoded); // "Hello World"
```

<br>

## Unicode 处理

`btoa()` 和 `atob()` 函数只能处理 ASCII 字符, 对于 Unicode 字符 (如中文) 会抛出错误:

```js
// 错误示例
try {
    btoa("你好"); // 抛出错误
} catch (error) {
    console.error("Unicode 字符编码失败:", error);
    // Unicode 字符编码失败: InvalidCharacterError: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.
}
```

**解决方案**: 使用 `encodeURIComponent()` 和 `decodeURIComponent()` 处理 Unicode:

```js
// 编码 Unicode 字符串
function encodeUnicode(str) {
    return btoa(encodeURIComponent(str));
}

// 解码 Unicode 字符串
function decodeUnicode(str) {
    return decodeURIComponent(atob(str));
}

// 使用示例
const chinese = "你好世界";
const encoded = encodeUnicode(chinese);
console.log(encoded); // "JUU0JUJEJUEwJUU1JUE1JUJEJUU0JUI4JTk2JUU3JTk1JThD"

const decoded = decodeUnicode(encoded);
console.log(decoded); // "你好世界"
```

<br>

## 错误处理

```js
function safeBtoa(str) {
    try {
        return btoa(str);
    } catch (error) {
        console.error("Base64 编码失败:", error);
        return null;
    }
}

function safeAtob(str) {
    try {
        return atob(str);
    } catch (error) {
        console.error("Base64 解码失败:", error);
        return null;
    }
}
```

<br><br>

# 应用场景

## 1. Data URL

将图片等二进制数据嵌入到 HTML 或 CSS 中, 减少 HTTP 请求:

```html
<!-- 直接嵌入图片 -->
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA..." alt="图片" />

<!-- CSS 背景图片 -->
<div style="background-image: url('data:image/jpeg;base64,/9j/4AAQSkZJRgABA...')"></div>
```

<br>

## 2. Canvas 图片导出

```js
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// 绘制内容
ctx.fillRect(0, 0, 100, 100);

// 导出为 Base64
const dataURL = canvas.toDataURL("image/png");
console.log(dataURL); // "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVU..."
```

<br>

## 3. 文件上传预览

```html
<input type="file" id="fileInput" accept="image/*" /> <img id="preview" style="max-width: 300px;" />
```

```js
const fileInput = document.getElementById("fileInput");
const preview = document.getElementById("preview");

fileInput.addEventListener("change", function (e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
            preview.src = e.target.result; // Base64 Data URL
        };
        reader.readAsDataURL(file);
    }
});
```

<br>

## 4. 本地存储

```js
// 将对象序列化并编码存储
function saveToStorage(key, obj) {
    const jsonString = JSON.stringify(obj);
    const encoded = btoa(jsonString);
    localStorage.setItem(key, encoded);
}

// 从存储中读取并解码
function loadFromStorage(key) {
    const encoded = localStorage.getItem(key);
    if (encoded) {
        const jsonString = atob(encoded);
        return JSON.parse(jsonString);
    }
    return null;
}
```

<br><br>

# URL 安全的 Base64 变种

标准 Base64 中的 `+` 和 `/` 字符在 URL 中具有特殊含义, 因此存在 URL 安全的变种:

```js
// URL 安全的 Base64 编码
function base64UrlEncode(str) {
    return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

// URL 安全的 Base64 解码
function base64UrlDecode(str) {
    // 添加填充
    str += "=".repeat((4 - (str.length % 4)) % 4);
    // 替换字符
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return atob(str);
}

// 使用示例
const original = "Hello World!";
const urlSafe = base64UrlEncode(original);
console.log(urlSafe); // "SGVsbG8gV29ybGQ"

const decoded = base64UrlDecode(urlSafe);
console.log(decoded); // "Hello World!"
```

<br><br>

# 性能考虑

## 数据大小影响

Base64 编码会使数据膨胀约 33%, 对于大文件需要谨慎使用:

```js
// 检查数据大小
function checkDataSize(data) {
    const originalSize = new Blob([data]).size;
    const encodedSize = btoa(data).length;
    const inflation = (((encodedSize - originalSize) / originalSize) * 100).toFixed(2);

    console.log(`原始大小: ${originalSize} 字节`);
    console.log(`编码后大小: ${encodedSize} 字节`);
    console.log(`膨胀率: ${inflation}%`);
}
```

<br>

## 内存使用

对于大文件, 建议使用流式处理:

```js
// 分块处理大文件
function encodeLargeFile(file, chunkSize = 1024 * 1024) {
    // 返回一个 Promise, 用于异步处理大文件编码
    return new Promise((resolve, reject) => {
        // 创建 FileReader 实例, 用于读取文件片段
        const reader = new FileReader();
        // 存储每个片段的 Base64 编码结果
        const chunks = [];
        // 当前读取的文件偏移量
        let offset = 0;

        // 递归函数: 读取文件的一个片段
        function readChunk() {
            // 从当前偏移量开始, 读取指定大小的文件片段
            const slice = file.slice(offset, offset + chunkSize);
            // 如果片段大小为 0, 说明文件读取完毕
            if (slice.size === 0) {
                // 将所有片段的 Base64 编码结果连接起来
                resolve(chunks.join(""));
                return;
            }

            // 当文件片段读取完成时的回调函数
            reader.onload = function (e) {
                // 获取读取到的 ArrayBuffer 数据
                const arrayBuffer = e.target.result;
                // 将 ArrayBuffer 转换为 Uint8Array, 再转换为字符串, 最后进行 Base64 编码
                const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                // 将当前片段的 Base64 编码结果添加到数组中
                chunks.push(base64);
                // 更新偏移量, 准备读取下一个片段
                offset += chunkSize;
                // 递归调用, 继续读取下一个片段
                readChunk();
            };

            // 开始读取当前文件片段为 ArrayBuffer 格式
            reader.readAsArrayBuffer(slice);
        }

        // 开始读取第一个文件片段
        readChunk();
    });
}
```

<br><br>

# 安全性注意事项

## 不是加密算法

Base64 仅是一种编码方式, 不提供任何安全性:

```js
// 错误认知: Base64 不是加密
const sensitive = "password123";
const encoded = btoa(sensitive);
console.log("编码后的密码:", encoded); // "cGFzc3dvcmQxMjM="

// 任何人都可以轻松解码
const decoded = atob(encoded);
console.log("解码后的密码:", decoded); // "password123"
```

<br>

## 安全使用建议

```js
// 正确的做法: 先加密再编码
async function secureEncode(data, password) {
    /* 1. 先进行加密 (使用 Web Crypto API) */
    // 导入原始密钥, 将密码转换为 ArrayBuffer 格式
    const key = await crypto.subtle.importKey(
        "raw", // 密钥格式: 原始字节数据
        new TextEncoder().encode(password), // 将密码字符串转换为 Uint8Array
        {
            name: "PBKDF2", // 密钥派生算法名称
        },
        false, // 不允许导出密钥
        ["deriveBits", "deriveKey"] // 允许的操作: 派生位和派生密钥
    );

    // 使用 PBKDF2 算法从原始密钥派生出加密密钥
    const derivedKey = await crypto.subtle.deriveKey(
        {
            name: "PBKDF2", // 密钥派生算法
            salt: new Uint8Array(16), // 随机盐值, 增加安全性
            iterations: 100000, // 迭代次数, 防止暴力破解
            hash: "SHA-256", // 哈希算法
        },
        key, // 原始密钥
        {
            name: "AES-GCM", // 目标加密算法
            length: 256, // 密钥长度 (256 位)
        },
        false, // 不允许导出派生密钥
        ["encrypt"] // 允许的操作: 加密
    );

    // 生成随机初始化向量 (IV), 每次加密都使用不同的 IV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    // 使用 AES-GCM 算法加密数据
    const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv: iv }, // 加密参数: 算法名称和 IV
        derivedKey, // 派生出的加密密钥
        new TextEncoder().encode(data) // 将数据转换为 Uint8Array
    );

    /* 2. 再进行 Base64 编码 */
    // 创建组合数组, 包含 IV 和加密数据
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    // 将 IV 放在数组开头
    combined.set(iv);
    // 将加密数据放在 IV 之后
    combined.set(new Uint8Array(encrypted), iv.length);

    // 将组合数据转换为 Base64 字符串
    return btoa(String.fromCharCode(...combined));
}
```

<br><br>

# 实用工具函数

## 完整的 Base64 工具类

```js
class Base64Utils {
    // 编码字符串
    static encode(str) {
        try {
            return btoa(encodeURIComponent(str));
        } catch (error) {
            console.error("编码失败:", error);
            return null;
        }
    }

    // 解码字符串
    static decode(str) {
        try {
            return decodeURIComponent(atob(str));
        } catch (error) {
            console.error("解码失败:", error);
            return null;
        }
    }

    // URL 安全编码
    static encodeURL(str) {
        const encoded = this.encode(str);
        return encoded ? encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") : null;
    }

    // URL 安全解码
    static decodeURL(str) {
        // 添加填充
        str += "=".repeat((4 - (str.length % 4)) % 4);
        str = str.replace(/-/g, "+").replace(/_/g, "/");
        return this.decode(str);
    }

    // 检查是否为有效的 Base64 字符串
    static isValid(str) {
        if (typeof str !== "string") return false;
        if (str.length % 4 !== 0) return false;
        return /^[A-Za-z0-9+/]*={0,2}$/.test(str);
    }

    // 获取编码后的大小
    static getEncodedSize(originalSize) {
        return Math.ceil((originalSize * 4) / 3);
    }
}

// 使用示例
const text = "Hello 世界!";
const encoded = Base64Utils.encode(text);
console.log("编码:", encoded);

const decoded = Base64Utils.decode(encoded);
console.log("解码:", decoded);

console.log("是否有效:", Base64Utils.isValid(encoded));
```

<br>

## 文件处理工具

```js
// 文件转 Base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// Base64 转 Blob
function base64ToBlob(base64, mimeType = "application/octet-stream") {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);

    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }

    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: mimeType });
}

// 使用示例
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (file) {
        const base64 = await fileToBase64(file);
        console.log("文件 Base64:", base64);

        // 转换回 Blob
        const blob = base64ToBlob(base64.split(",")[1], file.type);
        console.log("转换回 Blob:", blob);
    }
});
```

通过 Base64 编码, 开发者可以方便地在文本环境中处理二进制数据, 实现文件预览、数据传输、本地存储等功能. 但需要注意其安全性和性能影响, 合理选择使用场景.

<br>
