# 变量的生存周期

对于函数内声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。

```js
const func = function () {
    const a = 1; // 退出函数后局部变量 a 将被销毁
    console.log(a); // 1
};

func();
```

<br>

现在来看看下面这段代码：

```js
const func = function () {
    const a = 1;
    return function () {
        a++;
        console.log(a);
    };
};

const f = func();

f(); // 2
f(); // 3
```

当执行 `const f = func()` 时，`f` 返回了一个匿名函数的引用，它可以访问到 `func` 被调用时产生的环境，而局部变量 `a` 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。

<br><br>

# 闭包的使用

闭包（Closure）是指一个函数与其词法环境的组合。

<br>

闭包有以下几个重要特点：

1.  记忆词法环境：闭包函数能够记住它被创建时的词法环境，包括函数内部的变量、参数等。
2.  外部变量访问：闭包函数可以访问和操作其外部函数中的变量，即使外部函数已经执行完毕。
3.  延长变量生命周期：由于闭包函数持有对外部变量的引用，这些变量的生命周期得到了延长，直到闭包函数被销毁。

<br>

利用闭包我们可以完成许多奇妙的工作。

假设页面上有 5 个 div 节点，我们通过循环来给每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出 0，点击第 2 个 div 时弹出 1，以此类推。代码如下：

```html
<div>1</div>
<div>2</div>
<div>3</div>
<div>4</div>
<div>5</div>

<script>
    var nodes = document.getElementsByTagName('div');
    for (var i = 0, len = nodes.length; i < len; i++) {
        nodes[i].onclick = function () {
            console.log(i);
        };
    }
</script>
```

测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是 5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。

解决方法是在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i，如果有 5 个 div，这里的 i 就分别是 0、1、2、3、4：

```js
for (var i = 0, len = nodes.length; i < len; i++) {
    (function (i) {
        nodes[i].onclick = function () {
            console.log(i);
        };
    })(i);
}
```

<br>

每次生成的闭包都是新的！互不干扰！

```js
function outer() {
    let count = 0;

    function inner() {
        count++;
        console.log(count);
    }
    return inner;
}

let inn1 = outer(); // 形成第一个闭包
inn1(); // 1
inn1(); // 2

let inn2 = outer(); // 形成第二个闭包
inn2(); // 1
inn2(); // 2
```

<br>

除了 `return` 以外，还有一些方法可以维持内部函数与外部的联系。比如通过函数表达式，将内部函数赋值给外部变量：

```js
let inner; // 定义全局变量 inner
let aa = 300; // 定义全局变量 aa

function outer() {
    // 定义函数 outer
    let aa = 200;
    inner = function () {
        // 函数表达式定义内部函数
        aa++;
        console.log(aa);
    };
}

outer(); // outer 必须先运行，否则 inner 不是一个函数，就不会形成闭包
inner(); // 直接进入 inner 作用域，打印 201
inner(); // 直接进入 inner 作用域，打印 202
```

<br><br>

# 闭包的作用

## 封装变量

闭包可以把一些不需要暴露在全局的变量封装成 "私有变量"。

假设有一个计算乘积的简单函数：

```js
var mul = function () {
    var a = 1;
    for (var i = 0, l = arguments.length; i < l; i++) {
        a = a * arguments[i];
    }
    return a;
};
```

mul 函数接受一些 number 类型的参数，并返回这些参数的乘积。现在我们觉得对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能：

```js
var cache = {};

var mul = function () {
    var args = Array.prototype.join.call(arguments, ', ');
    if (cache[args]) {
        return cache[args];
    }

    var a = 1;
    for (var i = 0, l = arguments.length; i < l; i++) {
        a = a * arguments[i];
    }

    return (cache[args] = a);
};

alert(mul(1, 2, 3)); // 6
alert(mul(1, 2, 3)); // 6
```

我们看到 cache 这个变量仅仅在 mul 函数中被使用，与其让 cache 变量跟 mul 函数一起平行地暴露在全局作用域下，不如把它封闭在 mul 函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。代码如下：

```js
var mul = (function () {
    var cache = {};

    return function () {
        var args = Array.prototype.join.call(arguments, ', ');
        if (args in cache) {
            return cache[args];
        }

        var a = 1;
        for (var i = 0, l = arguments.length; i < l; i++) {
            a = a * arguments[i];
        }

        return (cache[args] = a);
    };
})();
```

如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。代码如下：

```js
var mul = (function () {
    var cache = {};

    // 封闭 calculate 函数
    var calculate = function () {
        var a = 1;
        for (var i = 0, l = arguments.length; i < l; i++) {
            a = a * arguments[i];
        }
        return a;
    };

    return function () {
        var args = Array.prototype.join.call(arguments, ', ');
        if (args in cache) {
            return cache[args];
        }

        return (cache[args] = calculate.apply(null, arguments));
    };
})();
```

<br>

## 延续局部变量的寿命

img 对象经常用于进行数据上报，如下所示：

```js
var report = function (src) {
    var img = new Image();
    img.src = src;
};

report('http://xxx.com/getUserInfo');
```

但是通过查询后台的记录我们得知，在一些低版本浏览器中使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。

现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题：

```js
var report = (function () {
    var imgs = [];
    return function (src) {
        var img = new Image();
        imgs.push(img);
        img.src = src;
    };
})();
```

<br><br>

# 闭包和面向对象设计

使用闭包可以实现一个完整的面向对象系统。

<br>

下面来看看这段跟闭包相关的代码：

```js
var extent = function () {
    var value = 0;
    return {
        call: function () {
            value++;
            console.log(value);
        },
    };
};

var extent = extent();

extent.call(); // 1
extent.call(); // 2
```

如果换成面向对象的写法，就是：

```js
var extent = {
    value: 0,
    call: function () {
        this.value++;
        console.log(this.value);
    },
};

extent.call(); // 1
extent.call(); // 2
```

或者：

```js
var Extent = function () {
    this.value = 0;
};

Extent.prototype.call = function () {
    this.value++;
};
console.log(this.value);

var extent = new Extent();

extent.call();
extent.call();
```

<br><br>

# 用闭包实现命令模式

我们先用面向对象的方式来编写一段命令模式的代码：

```html
<button id="execute">点击我执行命令</button>
<button id="undo">点击我执行命令</button>

<script>
    var Tv = {
        open: function () {
            console.log('打开电视机');
        },
        close: function () {
            console.log('关上电视机');
        },
    };

    var OpenTvCommand = function (receiver) {
        this.receiver = receiver;
    };

    OpenTvCommand.prototype.execute = function () {
        this.receiver.open(); // 执行命令，打开电视机
    };

    OpenTvCommand.prototype.undo = function () {
        this.receiver.close(); // 撤销命令，关闭电视机
    };

    var setCommand = function (command) {
        document.getElementById('execute').onclick = function () {
            command.execute(); // 输出：打开电视机
        };
        document.getElementById('undo').onclick = function () {
            command.undo(); // 输出：关闭电视机
        };
    };

    setCommand(new OpenTvCommand(Tv));
</script>
```

命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。

用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接收者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来；而在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中，代码如下：

```js
var Tv = {
    open: function () {
        console.log('打开电视机');
    },
    close: function () {
        console.log('关上电视机');
    },
};

var createCommand = function (receiver) {
    var execute = function () {
        return receiver.open(); // 执行命令，打开电视机
    };
    var undo = function () {
        return receiver.close(); // 执行命令，关闭电视机
    };
    return {
        execute: execute,
        undo: undo,
    };
};

var setCommand = function (command) {
    document.getElementById('execute').onclick = function () {
        command.execute(); // 输出：打开电视机
    };
    document.getElementById('undo').onclick = function () {
        command.undo(); // 输出：关闭电视机
    };
};

setCommand(createCommand(Tv));
```

<br><br>

# 闭包与内存管理

局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。但是，使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。

<br>
