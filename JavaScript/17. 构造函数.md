# 构造函数的使用

构造函数用于创建对象。

<br>

1. 系统自带的构造函数：`Number()`、`String()`、`Boolean()`、`Object()`、`Function()`、`Array()`...

2. 自定义构造函数：<br>
   自定义构造函数遵循大驼峰命名规则，eg：`Person()`、`TheFirstName()`... <br>
   普通函数遵循小驼峰命名规则，eg：`person()`、`theFirstName()`...

<br>

调用构造函数要配合 `new` 关键字：

> 配合 `new` 调用构造函数后，构造函数内部会隐式地执行 5 步操作：
>
> 1. 创建一个空对象
> 2. 让空对象的隐式原型 `__proto__` 指向构造函数的原型 `prototype`
> 3. 让 this 指向该对象
> 4. 执行构造函数里面的代码
> 5. 返回 this

```js
function Person(name) {
    this.name = name;
    this.showName = function () {
        console.log(this.name);
    };
}
const student = new Person('superman'); // 创建实例 student
console.log(student); // Person {name: 'superman', showName: ƒ}
```

如果不配合 `new` 关键字调用构造函数，则与调用普通函数无异：

```js
const student = Person('superman');
console.log(student); // undefined -- 说明构造函数没有返回值
```

<br><br>

# 构造函数的返回值

-   构造函数默认返回 this

-   如果人为地设置返回值：
    1. 如果 `return` 基本类型数据 (`boolean` `number` `string` `undefined` `null` `symbol`)，则无效
    2. 如果 `return` 引用类型数据 (`object` `function` `arrow`...)，则会覆盖默认的返回值

```js
function Person() {
    this.name = 'superman';
    return 123; // 相当于没写
}
const student = new Person();
console.log(student); // Person {name: 'superman'}
```

```js
function Person() {
    this.name = 'superman';
    return [123, 321]; // 覆盖默认的返回值 this
}
const student = new Person();
console.log(student); // [123, 321]
```

<br><br>

# 构造函数的参数

构造函数与普通函数一样，都可以传入参数：

```js
function Person(name, age) {
    this.name = name || 'superman'; // 利用短路算法设置属性默认值
    this.age = age || 18;
}

const student1 = new Person('superwomen', null);
const student2 = new Person(undefined, 21);

console.log(student1); // Person {name: 'superwomen', age: 18}
console.log(student2); // Person {name: 'superman', age: 21}
```

> 6 个**负性值**：`0` `NaN` `''` `undefined` `null` `false`

<br><br>

# 实例的属性 & 方法

-   **构造函数里，给 `this` 对象设置的属性 & 方法，就是每个实例自己的属性 & 方法**。
-   每次通过 `new` 关键字调用构造函数，都会创建新的 `this` 对象，所以通过构造函数创建的实例都是不一样的。

```js
function Person() {
    this.num = 0;
    this.addNum = function () {
        console.log(++this.num);
    };
}

const person1 = new Person(); // 创建实例 1
person1.addNum(); // 1
person1.addNum(); // 2

const person2 = new Person(); // 创建实例 2
person2.addNum(); // 1
person2.addNum(); // 2
```

<br><br>

# 包装类

如果尝试把原始类型数据当成对象使用，JS 会自动将其转换为对应包装类的实例。

系统自带的构造函数有：`Number()`、`String()`、`Boolean()`、`Object()`、`Function()`、`Array()`... <br>
可以看到，**原始类型中，Number、String、Boolean 拥有对应的构造函数，所以这些类型的数据拥有对应的包装类**。

对象与原始类型数据的区别：对象有属性 & 方法 ----- 原始类型数据没有属性 & 方法。

```js
const num1 = 10; // 原始类型数据
const num2 = new Number(10); // Number 的实例

console.log(num1); // 10
console.log(num2); // Number {10}

num1.name = 'superman1';
num2.name = 'superman2';

console.log(num1.name); // undefined
console.log(num2.name); // superman2

console.log(num1); // 10
console.log(num2); // Number {10, name: 'superman2'}
```

可以看到，`num1.name` 输出的是 `undefined`，而没有报错，因为 JS 会在必要的时候将原始类型数据转换为对应包装类的实例。

我们看如下解析：

```js
const num = 10;

num.name = 'superman';
// 执行这一步时, 相当于执行 new Number(num).name = 'superman'
// 但是没有变量接收 new Number(num) 这个实例, 所以该实例又会被垃圾回收机制处理掉

console.log(num.name);
// 执行这一步时, 相当于执行 console.log(new Number(num).name)
// 但是这个新建的 Number 实例并没有 name 属性, 所以打印 undefined
```

<br>

再看下面这个例子：

```js
const str1 = '123'; // 原始类型数据
const str2 = new String('123'); // String 的实例

console.log(str1); // 123
console.log(str2); // String {'123'}

console.log(str1.length); // 3
console.log(str2.length); // 3
```

解析：执行 `str1.length` 相当于执行 `new String(str1).length`，所以可以得到 `3`。

<br>

**原始类型数据中，`undefined`、`null` 没有构造函数，所以他们没有包装类**。

没有包装类的原始类型数据被当成对象使用会直接报错：

```js
const a = null;
console.log(a.name); // TypeError: Cannot read properties of null
```

<br><br>

# 面试题

实现 new 的效果：

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}

function myConstructor(target) {
    const obj = {};
    Object.setPrototypeOf(obj, target.prototype);

    const params = Array.prototype.slice.call(arguments, 1);
    const result = target.apply(obj, params);

    if (result && typeof result === /(function|object)/) {
        return result;
    }

    return obj;
}

const person = myConstructor(Person, 'John', 30);
console.log(person); // Person { name: 'John', age: 30 }
```

<br>
