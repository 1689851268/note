# 原型链

<img src="./picture/image-20230902233435876.png" alt="image-20230902233435876" style="zoom:50%;" />

可以发现：`Object.prototype` 是最顶层的隐式原型，`Object.prototype` 的隐式原型为 `null`。

在 JS 中，Object 是其他构造函数的父类，就是说 其他构造函数的原型为 Object 的实例。<br>
因为 `Object` 是其他构造函数的父类，所以其他构造函数的实例都可以访问 `Object.prototype` 身上的属性/方法：

1. `hasOwnProperty(propertyName)`：用于判断当前实例上是否存在给定的属性。`propertyName` 必需是字符串/符号。
2. `isPrototypeOf(object)`：用于检查一个对象是否存在于另一个对象的原型链中。`object` 为要搜索其原型链的对象。
3. `propertyIsEnumerable(propertyName)`：用于判断给定的属性能否使用 for-in 语句枚举。`propertyName` 必需是字符串/符号。
4. `toString()`：返回对象的字符串表示。
5. `valueOf()`：返回对象对应的字符串、数值或布尔值表示。通常与 `toString()` 的返回值相同。

```js
console.log([10, 10].toLocaleString()); // 10,10
console.log([10, 10].toString()); // 10,10
console.log([10, 10].valueOf()); // [ 10, 10 ]
```

注意：严格来讲，ECMA-262 中对象的行为不一定适合 JS 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能不会继承 Object。

<br>

```js
var myObject = { a: 2 };

'a' in myObject; // true
'b' in myObject; // false

myObject.hasOwnProperty('a'); // true
myObject.hasOwnProperty('b'); // false
```

`in` 操作符会检查属性是否在对象及其 `[[Prototype]]` 原型链中。相比之下，`hasOwnProperty(..)` 只会检查属性是否在 `myObject` 对象中，不会检查 `[[Prototype]]` 链。

所有的普通对象都可以通过对于 Object.prototype 的委托来访问 `hasOwnProperty(..)`，但是有的对象可能没有连接到 Object.prototype（通过 `Object.create(null)` 来创建）。在这种情况下，形如 `myObject.hasOwnProperty(..)` 就会失败。

这时可以使用一种更加强硬的方法来进行判断：`Object.prototype.hasOwnProperty.call(myObject, 'a')`，它借用基础的 `hasOwnProperty(..)` 方法并把它显式绑定到 myObject 上。

<br>

```js
var myObject = {};

Object.defineProperty(
    myObject,
    'a',
    // 让 a 像普通属性一样可以枚举
    { enumerable: true, value: 2 }
);

Object.defineProperty(
    myObject,
    'b',
    // 让 b 不可枚举
    { enumerable: false, value: 3 }
);

myObject.propertyIsEnumerable('a'); // true
myObject.propertyIsEnumerable('b'); // false

Object.keys(myObject); // ["a"]
Object.getOwnPropertyNames(myObject); // ["a", "b"]
```

`propertyIsEnumerable(..)` 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 `enumerable: true`。

`Object.keys(..)` 会返回一个数组，包含所有可枚举属性，`Object.getOwnPropertyNames(..)` 会返回一个数组，包含所有属性，无论它们是否可枚举。

`Object.keys(..)` 和 `Object.getOwnPropertyNames(..)` 都只会查找对象直接包含的属性。

<br>

因为构造函数是 Function 创建出来的实例，所以完整的原型链图：

<img src="./picture/image-20230902233513478.png" alt="image-20230902233513478" style="zoom:50%;" />

可以发现 Function 非常特别，它具有隐式原型 `__proto__`，并且它的隐式原型 `__proto__` === 它的原型 `prototype`。

<br><br>

# 实例属性的查找逻辑

访问实例的属性时，先查看该实例自己的属性；若没有，则查看其原型对象的属性；若还是没有，则查看其原型对象的原型对象的属性；以此类推... 直至找到 `Object.prototype` 为止。

-   如果我们给 `Object.prototype` 添加属性，则所有的实例对象都能使用该属性。<br>
    eg：`new Object().toString() === '[object Object]'`

-   如果我们给实例重写了一些的同名属性，会覆盖其原型对象的属性。<br>
    eg：`new Number().toString() === '0'`

可以发现，只要我们更新原型链上的某一节点，就会影响该节点以下的所有实例。

<br>

**查看数据类型**：可以使用 `Object.prototype.toString.call(XX)`。

```js
Object.prototype.toString(); // "[object Object]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call([]); // "[object Array]"

Object.prototype.toString.call(123); // "[object Number]"
Object.prototype.toString.call('123'); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
```

必须通过 `Object.prototype` 调用 `toString()`，因为子类可能重写了该方法。

<br><br>

# 继承

## 原型链继承

思路：因为实例可以获取原型链上的数据，这样我们可以把父类的实例作为子类的构造函数的原型

```js
function People(name) {
    this.name = name; // 设置 People 的实例自己的属性
}

// 给构造函数 People 的原型添加方法, People 创建的所有实例都可调用
People.prototype.sayHello = function () {
    console.log('名字：' + this.name);
};

function Student(name, id) {
    this.name = name; // 给 Student 的实例添加自己的属性
    this.id = id;
}

// 继承：Student 的原型 = People 的实例
Student.prototype = new People('大明'); // 创建父类的实例, 造成父类实例的属性数据冗余

// 给构造函数 Student 的原型添加方法, Student 创建的所有实例都可调用
// 同时也是实例 '大明' 自己的方法, 会优先被调用
Student.prototype.sayHello = function () {
    console.log('姓名：' + this.name, '学号：' + this.id);
};

const Hong = new Student('小红', 1001); // 创建子类的实例

Hong.sayHello(); // 姓名：小红 学号：1001

console.log(Hong.__proto__); // People {name: "大明", sayHello: ƒ} -- 得到 People 的实例 '大明'
Hong.__proto__.sayHello(); // 姓名：大明 学号：undefined -- 调用 '大明' 自己的方法

console.log(Hong.__proto__.__proto__); // {sayHello: ƒ, constructor: ƒ} -- 得到 People 的原型
Hong.__proto__.__proto__.sayHello(); // 名字：undefined -- 调用 People 的原型的方法
```

<img src="./picture/image-20230902223120790.png" alt="image-20230902223120790" style="zoom:50%;" />

<br>

如果父类实例的属性值为引用类型数据，会有 "引用值共享问题"：

```js
function People() {
    this.name = ['superman']; // 实例的属性值是数组
}

function Student() {}

Student.prototype = new People(); // 原型链继承

const Hong = new Student();
const Ming = new Student();

console.log(Hong.name); // ['superman']
console.log(Ming.name); // ['superman']

// 修改原型对象上的属性值
Hong.name.push('hong');
Ming.name.push('ming');

console.log(Hong.name); // ['superman', 'hong', 'ming']
console.log(Ming.name); // ['superman', 'hong', 'ming']
console.log(Object.getPrototypeOf(Ming).name); // ['superman', 'hong', 'ming']
```

<br><br>

## 构造函数继承

思路：复制父类实例的属性给子类实例，解决原型链继承中的 "引用值共享问题"。

-   属性(方法)都在父类的构造函数中定义，**只能继承父类实例的属性(方法)**。<br>
    继承不涉及父类的原型链，不能继承父类的原型链上的属性。
-   在子类里面调用父类的构造函数，需要修改父类构造函数的 `this` 指向子类实例。<br>
    否则父类构造函数默认指向 `window`。

```js
function People(name) {
    this.name = name;
}

People.prototype.sayHello = function () {
    console.log('你好我是' + this.name);
};

function Student(name, id) {
    // 构造函数继承: 调用父类函数
    // 注意: 这里要使用 call 绑定 this 指向 !!!
    People.call(this, name);
    this.id = id;
}

Student.prototype.study = function () {
    console.log('好好学习，天天向上');
};

const hong = new Student('小红', 1001);
console.log(hong.name, hong.id); // 小红 1001
hong.study(); // 好好学习，天天向上
// hong.sayHello() // 会报错, 因为无法访问父类原型上的数据
```

<img src="./picture/image-20230902223749946.png" alt="image-20230902223749946" style="zoom:50%;" />

<br>

## 组合继承 (伪经典继承)

思路：**原型链继承**和**构造函数继承**组合在一起：<br>
通过构造函数继承，继承父类的属性，并解决 "引用值共享问题"。<br>
通过原型链继承，继承父类的原型链的属性。

但是，这会使父类构造函数被执行了两次，就是说创建了两个父类的实例，占用存储空间、影响性能。

```js
function People(name) {
    this.name = name;
    this.arr = [1, 2, 3, 4];
}

People.prototype.sayHello = function () {
    console.log('People 名字：' + this.name);
};

function Student(name, id) {
    People.call(this, name); // 构造函数继承: 执行父类的构造函数
    this.id = id;
}

// 原型链继承: 执行父类的构造函数
Student.prototype = new People('大明');

Student.prototype.showName = function () {
    console.log('Student 名字：' + this.name);
};

const hong = new Student('小红', 1);
const ming = new Student('小明', 2);

// 可以获取原型链上的数据
hong.showName(); // Student 名字：小红
hong.sayHello(); // People 名字：小红

// 解决了 "引用值共享问题"
hong.arr.push(5);
console.log(hong.arr); // [1, 2, 3, 4, 5]
console.log(ming.arr); // [1, 2, 3, 4]
```

<br>

## 寄生组合继承 (经典继承)

思路：定义一个空的构造函数，将其插入到原型链中，再对其做原型链继承。

但是这样会破坏掉原来的原型链结构，导致原型链的属性丢失。

```js
function People(name) {
    this.name = name;
}

People.prototype.sayHello = function () {
    console.log('你好我是' + this.name);
};

function Student(name, id) {
    People.call(this, name); // 构造函数继承
    this.id = id;
}

/* 核心语句 start */
function Fn() {} // 定义空的构造函数，没有任何属性
Fn.prototype = People.prototype; // 插入到父类的原型链中
Student.prototype = new Fn(); // 原型链继承
/* 核心语句 end */

Student.prototype.study = function () {
    console.log('好好学习，天天向上');
};

const hong = new Student('小红', 1001);
hong.sayHello(); // 你好我是小红
```

<img src="./picture/image-20230902224538908.png" alt="image-20230902224538908" style="zoom:50%;" />

<br>

上例的核心语句块，可以用 `Student.prototype = Object.create(People.prototype)` 代劳，等效于：

<img src="./picture/image-20230902225149789.png" alt="image-20230902225149789" style="zoom:50%;" />

`Object.create(XXX)` 会创建一个以 `XXX` 为隐式原型的实例；`XXX` 只能为 `对象` / `null`，否则报错。

<br>

## 圣杯模式

思路：修补好被破坏的原型链，并将 `寄生组合继承` 封装成函数。

```js
function People(name = 'superman') {
    this.name = name;
}

// 构造函数继承属性
function Student(name, id = 1) {
    People.call(this, name);
    this.id = id;
}

// 圣杯模式继承方法
function inherit(People, Student) {
    Student.prototype = Object.create(People.prototype); // 寄生组合继承
    Student.prototype.constructor = Student; // 修补原型链
    Student.prototype.parent = People; // 添加'父类'属性
}

inherit(People, Student);

const stu1 = new Student();
console.log(stu1); // Student {name: "superman", id: 1}
```

<img src="./picture/image-20230902225327890.png" alt="image-20230902225327890" style="zoom:50%;" />

<br>

上例的 `inherit` 方法还能这样实现：

```js
function inherit(People, Student) {
    Object.setPrototypeOf(Student.prototype, People.prototype);
    Student.prototype.parent = People;
}
```

**warning**：Object.setPrototypeOf 可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JS 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 Object.setPrototypeOf 语句那么简单，而是会涉及所有访问了那些修改过 `[[Prototype]]` 的对象的代码。”

<br>
