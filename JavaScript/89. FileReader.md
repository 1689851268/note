# FileReader

文件读取器 FileReader 用于异步读取存储在用户计算机上的文件 (或原始数据缓冲区) 的内容, 使用 File 或 Blob 对象指定要读取的文件或数据.

注意: FileReader 仅用于以安全的方式从用户系统 (远程) 读取文件内容, 不能用于从文件系统中按路径名简单地读取文件. 要在 JS 中按路径名读取文件, 应使用标准 Ajax 解决方案进行服务器端文件读取.

<br><br>

# 创建 FileReader 实例

## 基本语法

```js
const reader = new FileReader();
```

<br>

## 基本使用

```js
input.addEventListener("change", (e) => {
    const reader = new FileReader();
    const file = e.target.files[0];
    reader.readAsDataURL(file); // 读取数据

    // 当资源请求完成时, 将请求的结果赋值给 img 的 src 属性
    reader.addEventListener("load", (e) => {
        const img = new Image();
        img.src = reader.result; // 通过 result 属性获取 readAsDataURL 的结果
        document.body.appendChild(img);
    });
});
```

<br><br>

# FileReader 实例属性

## error

读取文件时发生的错误, 只读属性.

```js
const reader = new FileReader();
reader.onerror = (e) => {
    console.log(reader.error); // 错误信息
};
```

<br>

## result

文件内容; 该属性仅在读取操作完成后才有效, 数据的格式取决于使用哪个方法来启动读取方法.

```js
const reader = new FileReader();
reader.onload = (e) => {
    console.log(reader.result); // 文件内容
};
```

<br>

## readyState

表示 `FileReader` 状态的数字:

-   `EMPTY` - `0` - 还没有加载任何数据
-   `LOADING` - `1` - 数据正在加载
-   `DONE` - `2` - 已完成读取

```js
const reader = new FileReader();
console.log(reader.readyState); // 0 (EMPTY)

reader.onloadstart = () => {
    console.log(reader.readyState); // 1 (LOADING)
};

reader.onload = () => {
    console.log(reader.readyState); // 2 (DONE)
};
```

<br><br>

# FileReader 实例方法

## `readAsArrayBuffer()`

`readAsArrayBuffer(file)`: 完成之后, `result` 属性值为所读取文件的 `ArrayBuffer` 数据对象.

```js
const reader = new FileReader();
reader.onload = (e) => {
    const arrayBuffer = reader.result;
    console.log(arrayBuffer.byteLength); // ArrayBuffer 的字节长度
};
reader.readAsArrayBuffer(file);
```

<br>

## `readAsDataURL()`

`readAsDataURL(file)`: 完成之后, `result` 属性值为 `data:URL` 格式的 Base64 字符串以表示所读取文件的内容.

```js
const reader = new FileReader();
reader.onload = (e) => {
    const dataURL = reader.result;
    console.log(dataURL); // "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA..."

    // 可以直接用作图片的 src
    const img = document.createElement("img");
    img.src = dataURL;
    document.body.appendChild(img);
};
reader.readAsDataURL(file);
```

<br>

## `readAsText()`

`readAsText(file[, encoding])`: 完成之后, `result` 属性值为一个字符串以表示所读取的文件内容.

```js
const reader = new FileReader();
reader.onload = (e) => {
    const text = reader.result;
    console.log(text); // 文件内容字符串
};
reader.readAsText(file, "UTF-8"); // 指定编码, 默认为 UTF-8
```

<br>

## `abort()`

`abort()`: 中止读取操作.

```js
const reader = new FileReader();
reader.readAsText(file);

// 中止读取
reader.abort();
```

<br><br>

# 事件处理

1. `loadstart`: 开始读取时触发
2. `progress`: 读取时触发 (每过 50ms 左右就会触发一次; 对于较大的文件, 可以使用 `progress` 制定进度条)
3. `loadend`: 结束读取时触发
4. `load`: 在读取操作完成时触发
5. `abort`: 在读取操作被中断时触发
6. `error`: 在读取操作发生错误时触发

```js
const reader = new FileReader();

reader.addEventListener("loadstart", () => {
    console.log("开始读取文件");
});

reader.addEventListener("progress", (e) => {
    if (e.loaded && e.total) {
        const percent = (e.loaded / e.total) * 100;
        console.log(`读取进度: ${Math.round(percent)}%`);
    }
});

reader.addEventListener("load", (e) => {
    console.log("文件读取完成");
    console.log(reader.result);
});

reader.addEventListener("error", (e) => {
    console.error("读取文件时发生错误:", reader.error);
});

reader.addEventListener("abort", () => {
    console.log("读取操作被中止");
});

reader.addEventListener("loadend", () => {
    console.log("读取操作结束");
});
```

<br><br>

# 实际应用示例

## 1. 读取文本文件

```html
<input type="file" id="fileInput" accept=".txt,.md,.js,.html,.css" />
<pre id="fileContent"></pre>
```

```js
const fileInput = document.getElementById("fileInput");
const fileContent = document.getElementById("fileContent");

fileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            fileContent.textContent = reader.result;
        };
        reader.onerror = () => {
            fileContent.textContent = "读取文件失败";
        };
        reader.readAsText(file);
    }
});
```

<br>

## 2. 预览图片

```html
<input type="file" id="fileInput" accept="image/*" /> <img id="preview" style="max-width: 300px; height: auto;" />
```

```js
const fileInput = document.getElementById("fileInput");
const preview = document.getElementById("preview");

fileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file && file.type.startsWith("image/")) {
        const reader = new FileReader();
        reader.onload = (e) => {
            preview.src = reader.result;
        };
        reader.readAsDataURL(file);
    }
});
```

<br>

## 3. 监控上传进度

```js
const reader = new FileReader();
reader.onprogress = (e) => {
    if (e.loaded && e.total) {
        // progress 事件提供 2 个属性: loaded (已读取量), total (需读取总量)
        const percent = (e.loaded / e.total) * 100;
        console.log(`上传进度: ${Math.round(percent)} %`);

        // 更新进度条
        const progressBar = document.getElementById("progressBar");
        progressBar.style.width = `${percent}%`;
    }
};
```

<br>

## 4. 处理二进制文件

```js
function processBinaryFile(file) {
    const reader = new FileReader();

    reader.onload = (e) => {
        const arrayBuffer = reader.result;
        const uint8Array = new Uint8Array(arrayBuffer);

        // 处理二进制数据
        console.log("文件大小:", arrayBuffer.byteLength, "字节");
        console.log("前 10 个字节:", Array.from(uint8Array.slice(0, 10)));
    };

    reader.onerror = () => {
        console.error("读取二进制文件失败");
    };

    reader.readAsArrayBuffer(file);
}
```

<br><br>

# 高级应用场景

## 1. 大文件分块读取

```js
function readLargeFileInChunks(file, chunkSize = 1024 * 1024) {
    const chunks = [];
    let offset = 0;

    function readChunk() {
        const chunk = file.slice(offset, offset + chunkSize);
        const reader = new FileReader();

        reader.onload = (e) => {
            chunks.push(e.target.result);
            offset += chunkSize;

            if (offset < file.size) {
                readChunk(); // 继续读取下一个块
            } else {
                console.log("文件读取完成, 共", chunks.length, "个块");
                // 处理所有块
                processChunks(chunks);
            }
        };

        reader.readAsArrayBuffer(chunk);
    }

    readChunk();
}

function processChunks(chunks) {
    // 合并所有块
    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
    const combined = new Uint8Array(totalLength);
    let offset = 0;

    for (const chunk of chunks) {
        combined.set(new Uint8Array(chunk), offset);
        offset += chunk.byteLength;
    }

    console.log("合并后的文件大小:", combined.length);
}
```

<br>

## 2. 文件内容搜索

```js
function searchInFile(file, searchTerm) {
    const reader = new FileReader();

    reader.onload = (e) => {
        const content = reader.result;
        const lines = content.split("\n");
        const matches = [];

        lines.forEach((line, index) => {
            if (line.includes(searchTerm)) {
                matches.push({
                    lineNumber: index + 1,
                    content: line.trim(),
                });
            }
        });

        console.log(`找到 ${matches.length} 个匹配项:`);
        matches.forEach((match) => {
            console.log(`第 ${match.lineNumber} 行: ${match.content}`);
        });
    };

    reader.readAsText(file);
}
```

<br>

## 3. 文件格式转换

```js
function convertImageToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            resolve(e.target.result);
        };

        reader.onerror = () => {
            reject(new Error("文件读取失败"));
        };

        reader.readAsDataURL(file);
    });
}

// 使用示例
async function handleImageUpload(file) {
    try {
        const base64 = await convertImageToBase64(file);
        console.log("Base64 编码:", base64);

        // 可以发送到服务器
        await uploadToServer(base64);
    } catch (error) {
        console.error("转换失败:", error);
    }
}
```

<br>

## 4. 文件内容验证

```js
function validateFileContent(file, expectedType) {
    const reader = new FileReader();

    reader.onload = (e) => {
        const content = reader.result;
        let isValid = false;

        switch (expectedType) {
            case "json":
                try {
                    JSON.parse(content);
                    isValid = true;
                } catch (error) {
                    console.error("不是有效的 JSON 文件");
                }
                break;

            case "xml":
                try {
                    new DOMParser().parseFromString(content, "text/xml");
                    isValid = true;
                } catch (error) {
                    console.error("不是有效的 XML 文件");
                }
                break;

            case "csv":
                const lines = content.split("\n");
                const firstLine = lines[0];
                if (firstLine.includes(",")) {
                    isValid = true;
                } else {
                    console.error("不是有效的 CSV 文件");
                }
                break;
        }

        console.log(`文件验证结果: ${isValid ? "通过" : "失败"}`);
    };

    reader.readAsText(file);
}
```

<br><br>

# 错误处理

## 常见错误类型

```js
const reader = new FileReader();

reader.onerror = (e) => {
    const error = reader.error;

    switch (error.name) {
        case "NotFoundError":
            console.error("文件未找到");
            break;
        case "NotReadableError":
            console.error("文件无法读取");
            break;
        case "AbortError":
            console.error("读取操作被中止");
            break;
        case "SecurityError":
            console.error("安全错误: 文件可能已被修改");
            break;
        default:
            console.error("未知错误:", error.message);
    }
};
```

<br>

## 完整的错误处理示例

```js
function readFileWithErrorHandling(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            resolve(e.target.result);
        };

        reader.onerror = (e) => {
            const error = reader.error;
            let errorMessage = "文件读取失败";

            switch (error.name) {
                case "NotFoundError":
                    errorMessage = "文件未找到";
                    break;
                case "NotReadableError":
                    errorMessage = "文件无法读取, 可能正在被其他程序使用";
                    break;
                case "AbortError":
                    errorMessage = "读取操作被中止";
                    break;
                case "SecurityError":
                    errorMessage = "安全错误: 文件可能已被修改";
                    break;
                default:
                    errorMessage = `读取失败: ${error.message}`;
            }

            reject(new Error(errorMessage));
        };

        reader.onabort = () => {
            reject(new Error("读取操作被用户中止"));
        };

        reader.readAsText(file);
    });
}

// 使用示例
async function handleFileRead(file) {
    try {
        const content = await readFileWithErrorHandling(file);
        console.log("文件内容:", content);
    } catch (error) {
        console.error("读取文件时出错:", error.message);
        // 显示错误信息给用户
        alert(`读取文件失败: ${error.message}`);
    }
}
```

<br><br>

# 性能优化

## 1. 内存管理

```js
// 及时清理 FileReader 实例
function readFile(file) {
    const reader = new FileReader();

    reader.onload = (e) => {
        const result = e.target.result;
        // 处理结果
        processResult(result);

        // 清理引用
        reader.onload = null;
        reader.onerror = null;
        reader.onprogress = null;
    };

    reader.readAsText(file);
}
```

<br>

## 2. 大文件处理

```js
// 使用 Web Workers 处理大文件
function processLargeFileInWorker(file) {
    const worker = new Worker("file-processor.js");

    worker.postMessage({ file: file });

    worker.onmessage = (e) => {
        const result = e.data;
        console.log("处理结果:", result);
        worker.terminate(); // 清理 Worker
    };

    worker.onerror = (error) => {
        console.error("Worker 处理失败:", error);
        worker.terminate();
    };
}
```

<br>

## 3. 流式处理

```js
// 使用 ReadableStream 处理大文件
async function processFileStream(file) {
    const stream = file.stream();
    const reader = stream.getReader();
    const chunks = [];

    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            chunks.push(value);
            console.log(`已处理 ${chunks.length} 个数据块`);
        }

        console.log("文件处理完成");
    } finally {
        reader.releaseLock();
    }
}
```

<br><br>

# 注意事项

## 1. 安全性

-   FileReader 只能访问用户明确选择的文件, 无法通过路径名直接访问用户的文件系统
-   出于安全考虑, 浏览器限制了对本地文件系统的直接访问

## 2. 性能考虑

-   处理大文件时, 应注意内存使用和性能问题
-   建议使用分块读取或流式处理的方式处理大文件
-   及时清理 FileReader 实例, 避免内存泄漏

## 3. 错误处理

-   始终监听 `error` 事件, 处理可能的读取错误
-   提供用户友好的错误信息
-   考虑网络中断、文件损坏等异常情况

## 4. 用户体验

-   对于大文件, 显示读取进度
-   提供取消读取的功能
-   在读取过程中禁用相关按钮, 防止重复操作

通过 FileReader 对象, 开发者可以方便地读取用户选择的文件内容, 实现文件预览、内容分析、格式转换等功能, 为 Web 应用提供强大的文件处理能力.

<br>
