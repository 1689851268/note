# 函数的使用

## 函数的类型

```js
function result() {}
console.log(typeof result); // function
```

<br>

## 声明函数

```js
function name(params) {}
```

1. `name`：自定义的函数名称。
2. `params`：自定义的形式参数名称。形式参数，简称形参；用于接收实参传递过来的数据；多个形参之间用 `,` 隔开。

```javascript
function add(num1, num2) {
    console.log(num1 + num2);
}
```

<br>

函数的形参仅能在函数内使用，属于局部变量。

1.  函数内部不能再用 `let` 定义同名变量：

```js
function show(age = 18) {
    let age = 20; // SyntaxError: Identifier 'age' has already been declared
}
```

2.  如果用 `var` 定义同名变量，变量值会覆盖形参值：

```js
function fn(a) {
    var a = 10;
    console.log(a); // 10
}
fn(1);
```

<br>

如果重复定义函数，后定义的函数体会覆盖先定义的函数体：

```js
function operateData(a, b) {
    return a + b;
}
function operateData(a, b) {
    return a - b;
}
console.log(operateData(2, 1)); // 1
```

<br>

## 调用函数

```js
name(params);
```

1. `params`：函数的实际参数，简称实参；用于给函数传递需要的数据。

```javascript
function add(num1, num2) {
    console.log(num1 + num2); // 3
}
add(1, 2);
```

<br><br>

# 参数的传递

-   形参和实参的位置顺序要对应。
-   形参的类型就是实参的类型，实参的类型由实参值决定。

```js
function add(num1, num2) {
    console.log(num1 + num2);
}
add(1, 2); // 3 传数字，进行数字相加
add('1', 2); // 12 传字符串，进行字符串拼接
```

-   如果传入的是引用类型数据，则操作的是内存地址。

```js
function fun(obj) {
    obj.name = 'superman'; // 操作原来的内存地址

    obj = new Object(); // 覆盖原来的内存地址
    obj.name = 'monster'; // 操作新的内存地址
}
const person = new Object();
fun(person); // 传入的是内存地址
console.log(person.name); // superman
```

<br>

## 参数的个数

1.  if **形参数 > 实参数**：没有实参赋值的形参值是 `undefined`。

```javascript
function fun(hobby1, hobby2, hobby3) {
    console.log('i like', hobby3, hobby1, hobby2); // i like undefined eating sleeping
}
fun('eating', 'sleeping');
```

2.  if **形参数 < 实参数**：没有形参接收的实参会被忽略。

```javascript
function fun(hobby1, hobby2) {
    console.log('i like', hobby1, hobby2); // i like eating sleeping
}
fun('eating', 'sleeping', 'playing');
```

<br>

## arguments 对象

函数内有一个局部变量 arguments，**arguments 是一个类数组对象，以 key-value 的形式存储着所有的实参数据**。

```javascript
function fun(hobby1, hobby2) {
    console.log(arguments); // Arguments(3) ["eating", "sleeping", "playing", ...]
}
fun('eating', 'sleeping', 'playing');
```

<br>

向函数传递参数时，arguments 中对应的单元会和形参建立关联以得到相同的值。相反，不传递参数就不会建立关联。

```javascript
function fun(hobby1, hobby2, hobby3) {
    console.log(arguments[0]); // eating

    hobby1 = 'drinking'; // 修改指定形参的参数值
    console.log(arguments[0]); // drinking
}
fun('eating', 'sleeping', 'playing');
```

但是，在严格模式中并没有建立关联这一说：

```js
function fun(hobby1, hobby2, hobby3) {
    'use strict';
    console.log(arguments[0]); // eating

    hobby1 = 'drinking'; // 修改指定形参名的参数值
    console.log(arguments[0]); // eating
}
fun('eating', 'sleeping', 'playing');
```

因此，在开发中不要依赖这种关联机制。实际上，它是 JS 语言引擎底层实现的一个抽象泄漏（leaky abstraction），并不是语言本身的特性。

<br>

demo：使用 arguments 对象实现一个累加器：

```js
function sum() {
    let result = 0;
    for (let i = 0; i < arguments.length; i++) {
        result += arguments[i];
    }
    console.log(result);
}
sum(1, 2, 3, 4);
```

<br>

对 ES6 中的参数默认值而言，参数被省略或被赋值为 undefined 效果都一样，都是取该参数的默认值。然而某些情况下，它们之间还是有区别的：

```js
function foo(a = 42, b = a + 1) {
    console.log(arguments.length);
    console.log(a, b);
    console.log(arguments[0], arguments[1]);
}

foo();
// 0
// 42 43
// undefined undefined

foo(10);
// 1
// 10 11
// 10 undefined

foo(10, undefined);
// 2
// 10 11
// 10 undefined

foo(10, null);
// 2
// 10 null
// 10 null
```

虽然参数 a 和 b 都有默认值，但是函数不带参数时，arguments 数组为空。

如果向函数传递 undefined 值，则 arguments 数组中会出现一个值为 undefined 的单元，而不是默认值。

<br>

## 模拟 "函数重载"

函数重载是指在同一个作用域中定义多个具有**相同名称**但参数**个数或类型不同**的函数。JS 中并不直接支持函数重载，但可以通过一些技巧模拟函数重载的效果，实现相似的功能。**`arguments.length`** 可以返回类数组对象 arguments 的长度。这样我们就可以根据**实参的数量**，来制定不同的功能代码。

```javascript
function fun() {
    switch (arguments.length) {
        case 1:
            console.log('i like', arguments[0]);
            break;
        case 2:
            console.log('i like', arguments[0], arguments[1]);
            break;
        case 3:
            console.log('i like', arguments[0], arguments[1], arguments[2]);
            break;
    }
}
fun('studying'); // i like studying
fun('writing', 'reading'); // i like writing reading
fun('eating', 'sleeping', 'playing'); // i like eating sleeping playing
```

<br><br>

# 返回值

函数内，程序执行到 `return` 会立即返回结果，并结束函数。

```js
function sum() {
    return 10; // 返回 10，并结束函数
    console.log(11); // return 后面的语句不会被执行
}
const a = sum();
console.log(a); // 10
```

<br>

函数也可以返回一个空值，这样得到的返回值为 `undefined`：

```js
function fun() {
    return; // 返回一个空值
}
console.log(fun()); // undefined
```

返回空值相当于不写 `return` 语句：

```js
function fun() {}
console.log(fun()); // undefined
```

<br>
