<br>

如果词法作用域完全由写代码期间函数所声明的位置来定义，JS 中有 2 种机制来 "修改" / "欺骗" 词法作用域，但是欺骗词法作用域会导致性能下降。

<br><br>

# eval

JS 中的 `eval(..)` 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。

在执行 `eval(..)` 之后的代码时，引擎并不 "知道" 或 "在意" 前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

考虑以下代码：

```js
function foo(str, a) {
    eval(str); // 欺骗！
    console.log(a, b);
}
var b = 2;
foo('var b = 3;', 1); // 1, 3
```

`"var b = 3;"` 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 `b`，因此它对已经存在的 `foo(..)` 的词法作用域进行了修改。这段代码在 `foo(..)` 内部创建了一个变量 `b`，并遮蔽了外部（全局）作用域中的同名变量。

当 `console.log(..)` 被执行时，会在 `foo(..)` 的内部同时找到 `a` 和 `b`，但是永远也无法找到外部的 `b`。因此会输出 `1, 3`。

在这个例子中，为了展示的方便和简洁，我们传递进去的 "代码" 字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。

> 在严格模式中，`eval(..)` 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```js
function foo(str) {
    'use strict';
    eval(str);
    console.log(a); // ReferenceError: a is not defined
}
foo('var a = 2;');
```

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

<br><br>

# with

JS 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是 `with` 关键字。

`with` 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身：

```js
var obj = {
    a: 1,
    b: 2,
    c: 3,
};

// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```

<br>

对 `with` 语句来说，会向作用域链前端添加指定的对象：

```js
function buildUrl() {
    let qs = '? debug=true';
    with (location) {
        let url = href + qs;
    }
    return url;
}
buildUrl(); // Uncaught ReferenceError: url is not defined
```

这里，`with` 语句将 `location` 对象作为上下文，因此 `location` 会被添加到作用域链前端。`buildUrl` 函数中定义了一个变量 `qs`。当 `with` 语句中的代码引用变量 `href` 时，实际上引用的是 `location.href`，也就是自己变量对象的属性。在引用 `qs` 时，引用的则是定义在 `buildUrl` 中的那个变量，它定义在函数上下文的变量对象上。而在 `with` 语句中使用 `var` 声明的变量 `url` 会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用 `let` 声明的变量 `url`，因为被限制在块级作用域，所以在 `with` 块之外没有定义。

<br>

```js
function foo(obj) {
    with (obj) {
        a = 2;
    }
}
var o1 = { a: 3 };
var o2 = { b: 3 };

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2 —— 不好，a 被泄漏到全局作用域上了！
```

这个例子中创建了 `o1` 和 `o2` 两个对象。其中一个具有 `a` 属性，另外一个没有。`foo(..)` 函数接受一个 `obj` 参数，该参数是一个对象引用，并对这个对象引用执行了 `with (obj) {..}`。在 `with` 块内部，我们写的代码看起来只是对变量 `a` 进行简单的词法引用，实际上就是一个 LHS 引用，并将 `2` 赋值给它。

当我们将 `o1` 传递进去，`a = 2` 赋值操作找到了 `o1.a` 并将 `2` 赋值给它，这在后面的 `console.log(o1.a)` 中可以体现。而当 `o2` 传递进去，`o2` 并没有 `a` 属性，因此不会创建这个属性，`o2.a` 保持 `undefined`。

但是可以注意到一个奇怪的副作用，实际上 `a = 2` 赋值操作创建了一个全局的变量 `a`。这是怎么回事？

可以这样理解，当我们传递 `o1` 给 `with` 时，`with` 所声明的作用域是 `o1`，而这个作用域中含有一个同 `o1.a` 属性相符的标识符。但当我们将 `o2` 作为作用域时，其中并没有 `a` 标识符，因此进行了正常的 LHS 标识符查找。

`o2` 的作用域、`foo(..)` 的作用域和全局作用域中都没有找到标识符 `a`，因此当 `a = 2` 执行时，自动创建了一个全局变量（因为是非严格模式）。

> 另外一个不推荐使用 `eval(..)` 和 `with` 的原因是：严格模式不允许使用 `with` 语句；在保留核心功能的前提下，也不允许间接或非安全地使用 `eval(..)`。

<br><br>

# 性能

`eval(..)` 和 `with` 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。

你可能会问，那又怎样呢？如果它们能实现更复杂的功能，并且代码更具有扩展性，难道不是非常好的功能吗？答案是否定的。

JS 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 `eval(..)` 或 `with`，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 `eval(..)` 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 `with` 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 `eval(..)` 或 `with`，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

如果代码中大量使用` eval(..)` 或 `with`，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。

<br>
