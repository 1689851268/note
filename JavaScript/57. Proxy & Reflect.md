# Proxy 代理

```js
const proxyObj = new Proxy(target, handle);
```

1.  `target`：代理对象（目标对象）
2.  `handler`：配置对象（拦截对象），用来定制拦截行为

<br>

**demo：创建空代理**

```js
const target = { id: 'target' };
const handler = {};
const proxy = new Proxy(target, handler);

// id 属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target

// 给目标属性赋值会反映在两个对象上, 因为两个对象访问的是同一个值
target.id = 'foo';
console.log(target.id); // foo
console.log(proxy.id); // foo

// 给代理属性赋值会反映在两个对象上, 因为这个赋值会转移到目标对象
proxy.id = 'bar';
console.log(target.id); // bar
console.log(proxy.id); // bar

// hasOwnProperty 方法在两个地方都会应用到目标对象
console.log(target.hasOwnProperty('id')); // true
console.log(proxy.hasOwnProperty('id')); // true

// Proxy.prototype 是 undefined, 因此不能使用 instanceof 操作符
console.log(target instanceof Proxy); // TypeError: Function has non-object prototype
console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype

// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```

<br>

## 拦截 Object

**`get(target, property[, receiver])` - 用于拦截对属性的 [获取] 操作**

1.  `target`：代理对象（目标对象），就是构造函数 `Proxy()` 的第 1 个参数
2.  `property`：访问的属性名
3.  `receiver`：Proxy 对象 / 继承 Proxy 的对象

需要手动 `return` 返回值：为 [获取] 操作得到的值； 可以返回任何值

```js
const obj = { name: 'superman' };
const handler = {
    // 设置拦截对象
    get(target, property) {
        // getter
        if (property in target) {
            return target[property];
        } else {
            return `你访问的属性 ${property} 不存在！`;
        }
    },
};
const proxyObj = new Proxy(obj, handler);

console.log(proxyObj); // Proxy { name: 'superman' }
console.log(proxyObj.name); // superman
console.log(proxyObj['age']); // 你访问的属性 age 不存在！
```

上述方法中，getter 的参数 `target` 就是代理对象 `obj`；参数 `property` 就是访问的属性名 `name`、`age`

<br>

**`set(target, property, value[, receiver])` - 用于拦截对属性的 [添加]、[修改] 操作**

1.  `target`：目标对象，就是构造函数 `Proxy()` 的第 1 个参数
2.  `property`：操作的属性
3.  `value`：被写入的属性值
4.  `receiver`：Proxy 对象 / 继承 Proxy 的对象

**应当**手动 `return` 返回值：`true`-执行成功、`false`-执行失败；[应当] 的意思是，可以不写。

```js
const obj = { name: 'superwoman' };
const proxyObj = new Proxy(obj, {
    set(target, property, value) {
        if (property == 'age') {
            if (!Number.isInteger(value))
                throw new TypeError(`${property} 必须是整数`);
            if (value > 200) throw new RangeError(`${property} 得小于 200`);
        }
        target[property] = value;
    },
});

proxyObj.name = 'superman'; // 修改属性值
proxyObj.age = 18; // 添加属性
console.log(obj); // { name: 'superman', age: 18 }

// 以下会报错
// proxyObj.age = 12.6; // TypeError: age 必须是整数
// proxyObj.age = 201; // RangeError: age 得小于 200
```

<br>

**`deleteProperty(target, property)` - 用于拦截对属性的 [删除] 操作**

1.  `target`：目标对象，就是构造函数 `Proxy()` 的第 1 个参数
2.  `property`：待删除的属性名

需要手动 `return` 返回值：`true` 表示删除成功；`false` 表示删除失败。

```js
const obj = { name: 'superman', age: 18 };
const proxyObj = new Proxy(obj, {
    deleteProperty(target, prop) {
        console.log(`你要删除 ${prop} 属性`); // 你要删除 age 属性
        return delete target[prop];
    },
});

console.log(obj); // { name: 'superman', age: 18 }
console.log(delete proxyObj.age); // false
console.log(obj); // { name: 'superman' }
```

上述代码中，`deleteProperty` 方法的参数 `target` 就是 `Proxy()` 的第 1 个参数 `obj`；参数 `prop` 就是 `age`

<br>

**`has(target, prop)` 方法 - 用于拦截对属性的 [`in`] 操作**

1.  `target`：目标对象
2.  `prop`：需要检查是否存在的属性

需要手动 `return` 返回值：`true`-目标对象存在该属性；`false`-目标对象不存在该属性。

```js
const obj = { name: 'superman', age: 18 };
const proxyObj = new Proxy(obj, {
    has(target, prop) {
        console.log(`判断属性 ${prop} 是否在此对象中`); // 判断属性 name 是否在此对象中
        return prop in target;
    },
});
console.log('name' in proxyObj); // true
```

<br>

## 拦截 Function

-   所有的代理拦截中，只有 `apply` 和 `construct` 的代理目标是一个函数 Function
-   `apply` 和 `construct` 拦截方法覆写函数内部的 `[[Call]]` 和 `[[Construct]]` 方法

<br>

**`apply(target, thisArg, argumentsList)`- 用于拦截 [直接调用] - 作用于普通函数**

1.  `target`：目标函数，就是构造函数 `Proxy()` 的第 1 个参数
2.  `thisArg`：被调用时的上下文对象 ( this )
3.  `argumentsList`：被调用时的参数数组

返回值：可以返回任何值

```js
function sum(a, b) {
    return a + b;
}

const handler = {
    // 设置拦截对象
    apply(target, thisArg, argumentsList) {
        // 设置拦截对象的 apply 方法
        console.log(`Calculate sum: ${argumentsList}`); // Calculate sum: 1,2
        return target(argumentsList[0], argumentsList[1]) * 10;
    },
};
const proxyObj = new Proxy(sum, handler);

console.log(proxyObj(1, 2)); // 30
```

<br>

**`construct(target, argumentsList[, newTarget])` - 用于拦截 [`new` 操作] - 作用于构造函数**

-   为使 `new` 操作符在生成的 Proxy 对象上生效，目标函数必须具有 `[[Construct]]` 方法（即 `new target()` 必须是有效的）

1.  `target`：目标函数，就是 `Proxy()` 的第 1 个参数
2.  `argumentsList`：被调用时的参数数组
3.  `newTarget`：最初被调用的构造函数

返回值：一个实例对象

```js
function People(name) {
    this.name = name;
}

const handler = {
    // 设置拦截对象
    construct(target, args) {
        // 设置拦截对象的 construct 方法
        console.log('拦截了 new 操作'); // 拦截了 new 操作
        return new target(...args);
    },
};
const ProxyPeople = new Proxy(People, handler);

const p = new ProxyPeople('superman');
console.log(p); // People { name: 'superman' }
```

<br>

## 可撤销代理对象

-   通过 `new Proxy(target, handle)` 创建的代理对象不可撤销
-   创建可撤销的代理对象的方式：`Proxy.revocable(target, handler);`
-   接收 2 个参数：`target`：目标对象；`handler`：拦截对象。
-   返回值：`{"proxy": proxy, "revoke": revoke}`
    1.  `proxy` - 表示新创建的代理对象，和通过 `new Proxy(target, handler)` 创建的代理对象一样，不过它可以被撤销掉
    2.  `revoke` - 撤销方法，直接调用即可撤销掉和它一起生成的那个代理对象

```js
const obj = { name: 'superman' };

const handler = {};
const { proxy, revoke } = Proxy.revocable(obj, handler);

console.log(proxy.name); // superman
revoke(); // 撤销代理
console.log(proxy.name); // 报错
```

<br>

## 捕获器不变式

捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。

比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError：

```js
const target = {};
Object.defineProperty(target, 'foo', {
    configurable: false,
    writable: false,
    value: 'bar',
});
const handler = {
    get() {
        return 'qux';
    },
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // TypeError
```

<br><br>

# Reflect 反射

`Reflect` 是一个内置的对象，提供拦截 JS 操作的方法。

<br>

## defineProperty

`Reflect.defineProperty()` 基本等同于 `Object.defineProperty()` 方法，唯一不同是：前者操作失败时会返回 Boolean 值，而后者操作失败时会抛出错误：

```js
const obj = {};

const res1 = Reflect.defineProperty(obj, 'name', {
    get() {
        console.log('getter1'); // getter1
        return 'superman';
    },
});
console.log('res1', res1); // res1 true —— 执行成功

const res2 = Reflect.defineProperty(obj, 'name', {
    get() {
        console.log('getter2');
        return 'superwoman';
    },
});
console.log('res2', res2); // res2 false —— 执行失败

console.log('obj.name', obj.name); // obj.name superman
```

上例的 `Reflect.defineProperty()` 如果改为 `Object.defineProperty()`，第 2 次调用将会直接抛出错误，代码不会继续往下执行。

执行 `Reflect.defineProperty()` ，会返回一个布尔值：`true`-执行成功、`false`-执行失败。
使用 `Reflect.defineProperty()` 则可通过判断其返回值是否为 `ture`，得知操作是否执行成功，进而确定下一步操作

<br>

以下反射方法都会提供状态标记：

-   Reflect.defineProperty
-   Reflect.preventExtensions
-   Reflect.setPrototypeOf
-   Reflect.set
-   Reflect.deleteProperty

<br>

## 反射 Object

1. `Reflect.get(target, property[, receiver])` - [获取] 属性；
   手动 `return` 返回值：属性的值
2. `Reflect.set(target, property, value[, receiver])` - [添加]、[修改] 属性；
   手动 `return` 返回值：`true`-操作成功、`false`-操作失败
3. `Reflect.deleteProperty(target, property)` - [删除] 属性；
   手动 `return` 返回值：`true`-操作成功、`false`-操作失败
4. `Reflect.has`：可以替代 `in` 操作符或 `with()`

```js
new Proxy(data, {
    // 拦截 [获取] 属性
    get(target, prop) {
        return Reflect.get(target, prop);
    },
    // 拦截 [添加]、[修改] 属性
    set(target, prop, value) {
        Reflect.set(target, prop, value);
    },
    // 拦截 [删除] 属性
    deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    },
});
```

<br>

## 反射 Function

1.  `Reflect.apply(target, thisArg, argumentsList)`- 相当于 `target(...argumentsList)`；
    可以返回任意值
2.  `Reflect.construct(target, argumentsList[, newTarget])` - 相当于 `new target(...argumentsList)`；
    返回一个实例对象

```js
console.log(Math.ceil(4.4)); // 向上取整 5

// 通过 [反射] 调用 Math.ceil；  没有 this 指向，传入 null；  参数数组
const num = Reflect.apply(Math.ceil, null, [5.1]);
console.log(num); // 6
```

其实，只是调用函数的不同的方式而已：

```js
function show(...args) {
    console.log(this);
    console.log(args);
}
// 正常调用
show(1, 2, 3, 4); // this 是 window，args 是 [1,2,3,4]
// call 调用函数
show.call('aaa', 1, 2, 3, 4); // this 是 aaa，args 是 [1,2,3,4]
// apply 调用函数
show.apply('aaa', [1, 2, 3, 4]); // this 是 aaa，args 是 [1,2,3,4]
// reflect.apply 调用函数
Reflect.apply(show, 'aaa', [1, 2, 3, 4]); // this 是 aaa，args 是 [1,2,3,4]
```

<br>

## 代理另一个代理

代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：

```js
const target = { foo: 'bar' };
const firstProxy = new Proxy(target, {
    get() {
        console.log('first proxy');
        return Reflect.get(...arguments);
    },
});
const secondProxy = new Proxy(firstProxy, {
    get() {
        console.log('second proxy');
        return Reflect.get(...arguments);
    },
});
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
```

<br><br>

# 代理的问题与不足

## 代理中的 this

代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：

```js
const target = {
    thisValEqualsProxy() {
        return this === proxy;
    },
};
const proxy = new Proxy(target, {});
console.log(target.thisValEqualsProxy()); // false
console.log(proxy.thisValEqualsProxy()); // true
```

多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。

<br>

demo：

```js
const wm = new WeakMap();

class User {
    constructor(userId) {
        wm.set(this, userId);
    }
    set id(userId) {
        wm.set(this, userId);
    }
    get id() {
        return wm.get(this);
    }
}
```

由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：

```js
const user = new User(123);
console.log(user.id); // 123

const userInstanceProxy = new Proxy(user, {});
console.log(userInstanceProxy.id); // undefined
```

这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：

```js
const UserClassProxy = new Proxy(User, {});
const proxyUser = new UserClassProxy(456);
console.log(proxyUser.id); // 456
```

<br>

## 代理与内部槽位

有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。

一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位 `[[NumberDate]]`。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get 和 set 操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：

```js
const target = new Date();
const proxy = new Proxy(target, {});
console.log(proxy instanceof Date); // true
proxy.getDate(); // TypeError: 'this' is not a Date object
```

<br>
