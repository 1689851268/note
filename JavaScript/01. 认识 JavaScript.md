# 浏览器组成

-   外壳：UI 界面
-   内核：渲染引擎 (我们常说的浏览器内核) + JS 引擎

<br>

渲染引擎负责解析 HTML、CSS 和 JS，并将它们转换为用户可见的网页内容。它处理布局、样式计算、绘制和交互等方面的工作，以呈现出最终的网页效果。

JS 引擎则负责解析和执行 JS 代码，如变量赋值、函数调用、事件处理等。它会将 JS 代码转换成可执行的指令，并执行相应的操作。

在浏览器中，渲染引擎和 JS 引擎紧密协作，相互配合工作。当渲染引擎遇到需要执行 JS 的情况时，会将相关的 JS 代码交给 JS 引擎处理。JS 引擎执行完成后，将结果返回给渲染引擎，以便继续渲染网页内容。

<br><br>

# JavaScript

JavaScript 的特点：

1. 解释执行：JS 是一种解释执行的语言，代码在运行时逐行解析并执行，而不需要预先编译成机器码。
2. 单线程：JS 引擎在执行 JS 代码时，只有一个主线程负责处理所有的任务。这意味着代码指令会按编写的顺序逐个执行。
3. 弱类型：JS 是一种弱类型语言，变量的类型可以随时改变。
4. 动态性：JS 允许在运行时动态地创建、修改和删除对象和函数，以及更改对象的属性和方法。
5. 基于原型的继承：JS 使用原型链实现对象之间的继承关系。对象可以通过原型链访问和继承其他对象的属性和方法。
6. 事件驱动：JS 是一种事件驱动的语言，可以通过监听事件来触发相应的操作。
7. 异步编程：JS 支持异步编程，可以使用回调函数、Promise、Async/Await 等机制处理异步操作。
8. 客户端脚本语言：JS 主要用于前端开发，在浏览器中执行，实现网页的动态交互和行为控制。
9. 跨平台性：JS 不仅可以在浏览器中运行，还可以在服务器端（Node.js）、移动端、桌面应用等各种环境中运行。

<br>

JavaScript 的构成：

1. ECMAScript：JS 的语法标准，包括变量声明、流程控制语句、函数定义等。它定义了编写 JS 代码的规则和结构。
2. DOM（Document Object Model）：DOM 是 JS 操作**网页元素**的接口，通过 JS 可以访问和操作 DOM 元素。
3. BOM（Browser Object Model）：BOM 是 JavaScript 操作**浏览器**的接口，它提供了对历史记录、定时器、对话框等的访问和控制。

<br><br>

# JS 的书写位置

1.  事件处理函数：可以在 HTML 元素的事件属性（例如 `onclick`、`onload` 等）中编写 JS 代码，以响应特定的事件。

```html
<div onclick="alert('hello~')">hello world</div>
```

2.  内联方式：可以在 HTML 文件的 `<script>` 标签内直接编写 JS 代码。

```html
<script>
    // JavaScript 代码
</script>
```

3.  外部文件：将 JS 代码保存到独立的外部文件中，然后通过 `<script>` 标签的 `src` 属性引入。

```html
<script src="./demo.js"></script>
```

<br><br>

# JS 的书写原则

1.  script 标签会阻塞 HTML 的解析，所以尽量放在 HTML 的底部，以免影响页面的首屏渲染。

当浏览器遇到 script 标签时，它会暂停解析 HTML 文档，先去执行 script 标签中的 JS 代码，因为 JS 代码可能会修改 HTML 的结构或内容。这样就会导致页面的渲染被延迟，用户看到的是一个空白的页面，直到 script 标签执行完毕，浏览器才会继续解析 HTML 文档，并渲染页面。所以，为了提高用户体验，我们应该尽量把 script 标签放在 HTML 的底部，这样就可以让浏览器先解析和渲染页面的首屏内容，再去执行 script 标签中的 JS 代码。

假设我们有一个内联的 JS 代码，它会在页面加载时执行一些耗时的逻辑，我们把它放在 head 标签内，比如：

```html
<html>
    <head>
        <!-- 内联 JS 放在 head 标签内, 会阻塞 HTML 的解析和页面的渲染 -->
        <script>
            // 一些耗时的逻辑
            for (var i = 0; i < 1000000000; i++) {}
        </script>
    </head>
    <body>
        <!-- 页面内容 -->
        <h1>Hello World</h1>
    </body>
</html>
```

这样的话，用户打开这个页面时，会看到一个空白的页面，直到内联 JS 执行完毕，才会看到 "Hello World"。

如果我们把内联 JS 放在 body 标签的底部，比如：

```html
<html>
    <head> </head>
    <body>
        <!-- 页面内容 -->
        <h1>Hello World</h1>

        <!-- 内联 JS 放在 body 标签的底部, 不会阻塞 HTML 的解析和页面的渲染 -->
        <script>
            // 一些耗时的逻辑
            for (var i = 0; i < 1000000000; i++) {}
        </script>
    </body>
</html>
```

这样的话，用户打开这个页面时，会先看到 "Hello World"，然后再等待内联 JS 执行完毕。这样就可以提高用户体验。

<br>

2.  如果 script 标签需要在页面加载时执行一些初始化的逻辑，可以放在 head 标签内，但是要注意不要影响 CSS 的加载和解析。

假设我们有一个内联的 JS 代码，它需要在页面加载时执行一些统计的逻辑，我们可以把它放在 head 标签内，但是要注意不要影响 CSS 的加载和解析。比如：

```html
<html>
    <head>
        <!-- 内联 JS 放在 CSS 前面, 可以和网络请求并行执行 -->
        <script type="text/javascript">
            // 一些统计逻辑
        </script>

        <!-- 外链 CSS -->
        <link href="style.css" rel="stylesheet" />
    </head>
    <body>
        <!-- 页面内容 -->
    </body>
</html>
```

如果我们把内联 JS 放在 CSS 后面，那么就会导致页面的渲染被推迟，因为浏览器会等待 CSS 下载完成后，才会执行内联 JS。比如：

```html
<html>
    <head>
        <!-- 外链 CSS -->
        <link href="style.css" rel="stylesheet" />

        <!-- 内联 JS 放在 CSS 后面，会阻塞页面渲染 -->
        <script type="text/javascript">
            // 一些统计逻辑
        </script>
    </head>
    <body>
        <!-- 页面内容 -->
    </body>
</html>
```

<br>

3.  如果 script 标签不依赖于 DOM 元素，可以使用 async 或 defer 属性来异步加载和执行 script 标签，以提高页面的性能。

```html
<html>
    <head>
        <!-- 外链 CSS -->
        <link href="style.css" rel="stylesheet" />
    </head>
    <body>
        <!-- 页面内容 -->

        <!-- 内联 JS 使用 async 属性, 不会阻塞 HTML 的解析, 但是会在下载完成后立即执行 -->
        <script type="text/javascript" async>
            // 一些不依赖 DOM 的逻辑
        </script>

        <!-- 内联 JS 使用 defer 属性, 不会阻塞 HTML 的解析, 但是会在 DOMContentLoaded 事件之前按顺序执行 -->
        <script type="text/javascript" defer>
            // 另一些不依赖 DOM 的逻辑
        </script>
    </body>
</html>
```

<br>
