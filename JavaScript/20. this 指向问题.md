# this 指向

1. 普通函数：this 指向函数调用方。

```js
var name = 'superman';

function showName() {
    console.log('this', this); // this [object Window]
    console.log('this.name', this.name); // this.name superman
}

showName(); // 全局调用, this 指向全局对象; 严格模式下, this 指向 undefiend
```

```js
const obj = {
    name: 'superman',
    objFun() {
        console.log('this', this); // this { name: 'superman', objFun: [Function: fun] }
        console.log('this.name', this.name); // this.name superman
    },
};

obj.objFun(); // obj 调用, this 指向 obj
```

```js
function fun() {
    console.log('this', this); // this { name: 'superman', objFun: [Function: fun] }
    console.log('this.name', this.name); // this.name superman
}

const obj = {
    name: 'superman',
};
obj.objFun = fun;

obj.objFun(); // obj 调用, this 指向 obj
```

2.  构造函数：this 指向实例对象：

```js
function Person(name) {
    this.name = name;
}

const person = new Person('superman'); // new 调用, this 指向实例对象

console.log('person', person); // person Person { name: 'superman' }
console.log('person.name', person.name); // person.name superman
```

<br>

# 修改 this 指向

## call 和 apply

Function.prototype.call 和 Function. prototype.apply 用于改变函数内部的 this 指向，并立即调用该函数。

```javascript
window.name = 'window';
const obj1 = { name: 'sven' };
const obj2 = { name: 'anne' };

const getName = function () {
    alert(this.name);
};

getName(); // window
getName.call(obj1); // sven
getName.call(obj2); // anne
```

<br>

call 和 apply 的区别仅在于传入参数形式的不同：

apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。

call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

```js
function sum(a, b) {
    console.log(this);
    return a + b;
}
sum(10, 20); // [object Window]

const obj = { name: 'obj' };
sum.call(obj, 10, 20); // { name: 'obj' }
sum.apply(obj, [10, 20]); // { name: 'obj' }
```

<br>

对于 call 和 apply 方法的第 1 个参数：
如果是 `Number`、`String`、`Boolean`，包装类会将其转为对象。
如果是 `undefined`、`null`，它们没有包装类，无法转成对象，`this` 指向 `window`。

```js
function fun() {
    console.log(this);
}

fun.call(true); // Boolean { true }
fun.call(null); // [object Window]
```

<br>

当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window：

```js
var func = function (a, b, c) {
    alert(this === window); // true
};

func.apply(null, [1, 2, 3]);
```

但如果是在严格模式下，函数体内的 this 会为 null：

```js
var func = function (a, b, c) {
    'use strict';
    alert(this === null); // true
};

func.apply(null, [1, 2, 3]);
```

有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象：

```js
Math.max.apply(null, [1, 2, 5, 3, 4]); // 5
```

<br>

## bind

Function.prototype.bind 用于硬性绑定函数的 this 指向，且不可更改。

bind 不会执行函数，而是修改 this 指向后，返回一个新的函数。

```js
const newFun = fun.bind(obj);
```

<br>

通过 bind 方法获取的新函数，无法修改 this 指向：

```js
function fun() {
    console.log('this', this);
}

const obj1 = { name: 'obj1' };
const biFun = fun.bind(obj1); // 使用 bind 硬绑定
biFun(); // this { name: 'obj1' }

const obj2 = { name: 'obj2' };
biFun.call(obj2); // this { name: 'obj1' }
```

此时就算使用 `call`、`apply` 方法也修改不了函数 `biFun` 的 `this` 指向。

<br>

# this 指向的优先级

this 指向的优先级：① 构造函数 > ② 显示绑定 (bind > call、apply) > ③ 普通函数

```js
function Person(name) {
    this.name = name;
    console.log(this);
}

let obj = {};

let biPerson = Person.bind(obj);

biPerson('obj'); // { name: 'obj' } （硬绑定）
let newObj = new biPerson('newObj'); // Person {name: 'newObj'} （构造函数）
```

<br><br>

# 特殊函数

## 立即执行函数 IIFE

立即执行函数 IIFE 说白了就是一个普通函数。

```js
const obj = {
    outer() {
        console.log('outer', this); // outer { outer: [Function: outer] }

        // 立即执行函数
        (function () {
            console.log('inner', this); // inner [object Window]
        })(); // 全局调用, this 指向 window
    },
};

obj.outer();
```

<br>

## 闭包

其实就是把函数赋值给变量了，说白了也是普通函数。

```js
const obj = {
    outer() {
        console.log('outerThis', this); // outerThis { outer: [Function: outer] }

        return function () {
            console.log('innerThis', this); // innerThis [object Window]
        };
    },
};

obj.outer()();
```

<br>

## 箭头函数

箭头函数具有词法作用域的特性，不会创建自己的 `this` 值。它们会继承外部作用域的 `this` 值。

```js
const obj = {
    // 使用箭头函数
    objFun: () => {
        console.log('this', this);
    },
};

obj.objFun(); // this [object Window]
```

<br>

因为箭头函数没有自己的 `this`，所以 call & apply、bind 方法对箭头函数都不适用。⭐

```js
// 创建箭头函数
const arrFun = () => {
    console.log('this', this);
};

const obj = {};
const newArrFun = arrFun.bind(obj); // 使用 bind 硬绑定

newArrFun(); // this [object Window]
```

<br><br>

# 面试题

```js
var name = 'window';

var obj1 = {
    name: 'obj1',

    // this → obj1
    fn1() {
        console.log(this.name);
    },

    // this → window
    fn2: () => console.log(this.name),

    // this → obj1
    fn3() {
        // this → window
        return function () {
            console.log(this.name);
        };
    },

    // this → obj1
    fn4() {
        // this → obj1 (跟随 fn4 的 this)
        return () => console.log(this.name);
    },
};

var obj2 = { name: 'obj2' };

obj1.fn1(); // obj1
obj1.fn1.call(obj2); // obj2    ( this → obj2 )

obj1.fn2(); // window
obj1.fn2.call(obj2); // window

obj1.fn3()(); // window
obj1.fn3().call(obj2); // obj2
obj1.fn3.call(obj2)(); // window

obj1.fn4()(); // obj1
obj1.fn4().call(obj2); // obj1
obj1.fn4.call(obj2)(); // obj2
```

<br>

```js
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}

Foo.getName = function () {
    console.log(2);
};

Foo.prototype.getName = function () {
    console.log(3);
};

var getName = function () {
    console.log(4);
};

function getName() {
    console.log(5);
}

Foo.getName(); //  2
getName(); // 4  --  变量 getName 覆盖了函数 getName

Foo().getName(); // 1 -- 这里重写了 window.getName 方法
getName(); // 1

new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
// (有病吧谁会这么写啊！！！)
```

<br>
