# 语法与参数

```javascript
Object.defineProperty(obj, prop, descriptor);
```

-   **obj**: 目标对象.
-   **prop**: 属性名 (string 或 Symbol).
-   **descriptor**: 属性描述符.

描述符分为两类, 互斥使用:

-   **数据描述符**: `value`, `writable`.
-   **访问器描述符**: `get`, `set`.

共同属性: `enumerable`, `configurable`.

默认值提醒: 未显式指定时, `writable`, `enumerable`, `configurable` 默认均为 `false`; `get`/`set` 默认为 `undefined`.

<br><br>

# 数据描述符示例

```javascript
const config = {};

Object.defineProperty(config, "API_URL", {
    value: "https://api.example.com",
    writable: false, // 只读
    enumerable: true, // 可枚举
    configurable: false, // 不可重新配置或删除
});

// 非严格模式下赋值静默失败, 严格模式会抛错
config.API_URL = "https://evil.com";
```

<br><br>

# 访问器描述符示例

```javascript
const user = {};
let _age = 0;

Object.defineProperty(user, "age", {
    get() {
        return _age;
    },
    set(value) {
        if (value < 0) throw new Error("年龄不能为负数");
        _age = value;
    },
    enumerable: true,
    configurable: true,
});
```

<br><br>

# 互斥性

```javascript
// 不能同时指定 value/writable 与 get/set
Object.defineProperty({}, "x", {
    value: 1,
    get() {
        return 2;
    }, // TypeError: 访问器与数据描述符互斥
});
```

<br><br>

# 可枚举性与可配置性

```javascript
const o = { visible: "public" };

Object.defineProperty(o, "hidden", {
    value: "secret",
    enumerable: false, // 不会出现在 Object.keys / JSON.stringify / for...in 中
    configurable: true,
});
```

```javascript
const locked = {};
Object.defineProperty(locked, "permanent", {
    value: "fixed",
    configurable: false,
});

// delete locked.permanent;           // 失败
// Object.defineProperty(locked, 'permanent', { value: 'new' }); // 抛错
```

<br><br>

# 与 preventExtensions、seal、freeze 的关系

-   **Object.preventExtensions(obj)**: 禁止添加新属性; 已有属性仍可改值与删除 (若可配置). `defineProperty` 不能再添加新属性.
-   **Object.seal(obj)**: 在 `preventExtensions` 基础上, 所有现有属性 `configurable` 变为 `false`; 仍可改值 (若 `writable: true`). `defineProperty` 只能改 `value` (不改属性元数据).
-   **Object.freeze(obj)**: 在 `seal` 基础上, 把所有数据属性的 `writable` 也设为 `false`; 彻底只读. 一般无法通过 `defineProperty` 做任何修改.

层级强度: `freeze` > `seal` > `preventExtensions` > 正常.

简例:

```javascript
const a = { x: 1 };
Object.preventExtensions(a); // 不能添加新属性

const b = { x: 1 };
Object.seal(b); // 不能添加/删除/重配描述符, 但可改值

const c = { x: 1 };
Object.freeze(c); // 以上全部禁止, 还不能改值
```

<br><br>

# 典型使用场景

-   **只读常量**: 通过 `writable: false` + `configurable: false` 定义稳定常量.
-   **隐藏实现细节**: 通过 `enumerable: false` 隐藏内部字段, 但仍可直接访问.
-   **输入校验与计算属性**: 使用访问器描述符封装校验与派生值.
-   **轻量响应式**: 小规模属性级监听 (更复杂场景用 `Proxy`).

<br><br>

# 最佳实践

-   **显式声明所有特性**: 避免默认值导致的只读、不可枚举、不可配置.
-   **慎用 `configurable: false`**: 一旦设置将不可逆; 除非是稳定常量或安全边界.
-   **先精细控制, 再整体约束**: 先用 `defineProperty` 定好关键属性, 再按需 `seal` 或 `freeze`.
-   **性能权衡**: getter/setter 有调用开销; 大规模数据建议 `Proxy` 或库方案.
-   **调试与可观察性**: 用 `Object.getOwnPropertyDescriptor` 核对最终特性; 辅助定位权限失败.

<br><br>

# 常见陷阱与对策

-   **数据与访问器互斥**: `value/writable` 不可与 `get/set` 同时出现.
-   **默认都是 false**: 未显式设置将得到只读、不可枚举、不可配置的属性.
-   **非严格模式静默失败**: 如对只读属性赋值或给不可扩展对象加属性.
-   **不可逆操作**: `configurable: false`、`seal`、`freeze` 都不可逆.
-   **数组细节**: 写入超出 `length` 的索引在不可扩展/冻结数组上会失败; 修改 `length` 也受限.
-   **枚举相关**: `JSON.stringify` 与 `Object.keys` 仅包含可枚举属性.

<br><br>

# 实用代码片段

```javascript
// 安全定义属性 (带错误捕获)
function safeDefineProperty(obj, prop, descriptor) {
    try {
        Object.defineProperty(obj, prop, descriptor);
        return true;
    } catch (e) {
        console.warn(`无法定义属性 ${prop}: ${e.message}`);
        return false;
    }
}

// 描述符类型判断
function getDescriptorType(obj, prop) {
    const d = Object.getOwnPropertyDescriptor(obj, prop);
    if (!d) return "not found";
    if ("value" in d || "writable" in d) return "data descriptor";
    if ("get" in d || "set" in d) return "accessor descriptor";
    return "unknown";
}
```

<br><br>

# 嵌套对象 (属性值是对象) 的处理

-   **默认仅控制引用**: `defineProperty` 作用于属性本身, 若属性值是对象, 则默认只限制其 "引用" 的替换, 不会自动限制该对象内部属性的修改.
-   **浅 vs 深**: `preventExtensions` / `seal` / `freeze` 均为浅层操作; 深层需递归处理或使用 `Proxy`.

```javascript
const obj = {};

Object.defineProperty(obj, "profile", {
    value: { name: "Alice", meta: { age: 25 } },
    writable: false, // 禁止替换 obj.profile 的引用
    enumerable: true,
    configurable: false,
});

// ✅ 允许修改内部对象 (因为只是限制了引用, 而不是冻结内部)
obj.profile.name = "Bob";
obj.profile.meta.age = 26;

// ❌ 禁止整体替换引用 (严格模式抛错)
// obj.profile = {};
```

<br>

## 深度只读/不可变的实现方式

1. 递归冻结 (深冻结):

```javascript
function deepFreeze(target, seen = new WeakSet()) {
    if (target && typeof target === "object" && !seen.has(target)) {
        seen.add(target);
        // 先递归
        for (const key of Object.getOwnPropertyNames(target)) {
            deepFreeze(target[key], seen);
        }
        // 再冻结当前层
        Object.freeze(target);
    }
    return target;
}

const cfg = {};
Object.defineProperty(cfg, "settings", {
    value: deepFreeze({ a: 1, b: { c: 2 } }),
    writable: false,
    enumerable: true,
    configurable: false,
});

// 下述所有写入都会失败
// cfg.settings = {};
// cfg.settings.b.c = 3;
```

2. 递归定义只读属性 (更细粒度, 但成本更高):

```javascript
function defineDeepReadonly(obj) {
    if (!obj || typeof obj !== "object") return obj;
    for (const key of Object.getOwnPropertyNames(obj)) {
        const val = obj[key];
        Object.defineProperty(obj, key, {
            value: defineDeepReadonly(val),
            writable: false,
            enumerable: true,
            configurable: false,
        });
    }
    return obj;
}

const data = defineDeepReadonly({ x: { y: 1 } });
// data.x.y = 2; // 失败
```

3. 使用 `Proxy` 做深层拦截与响应式:

```javascript
function reactiveDeep(obj, onSet) {
    if (!obj || typeof obj !== "object") return obj;
    return new Proxy(obj, {
        get(target, key, receiver) {
            const value = Reflect.get(target, key, receiver);
            return typeof value === "object" && value !== null ? reactiveDeep(value, onSet) : value;
        },
        set(target, key, value, receiver) {
            const ok = Reflect.set(target, key, value, receiver);
            if (ok && typeof onSet === "function") onSet(String(key), value);
            return ok;
        },
    });
}

const state = reactiveDeep({ user: { name: "Alice" } }, (k, v) => {
    console.log("set:", k, v);
});
state.user.name = "Bob"; // set: name Bob
```

<br>

## 注意事项

-   `Object.freeze(new Map())` / `Object.freeze(new Set())` 只会冻结对象本身的可扩展性, 不能阻止 `map.set(...)` / `set.add(...)` 改变内部内容; 若需不可变集合, 请使用持久化数据结构库或自定义包装.
-   数组为对象: 冻结数组会禁止增删元素与修改 `length`, 但元素若是对象仍需深度处理.
-   性能权衡: 深冻结/深只读是递归操作, 对大对象有成本; 可结合写时复制或按需冻结策略.

<br><br>

# 状态检测方法

-   **Object.isExtensible(obj)**: 是否仍可添加新属性.
-   **Object.isSealed(obj)**: 是否被密封 (不可扩展, 且所有自有属性 `configurable: false`).
-   **Object.isFrozen(obj)**: 是否被冻结 (在密封基础上, 所有数据属性 `writable: false`).

```javascript
const normal = { x: 1 };
const noExtend = Object.preventExtensions({ x: 1 });
const sealed = Object.seal({ x: 1 });
const frozen = Object.freeze({ x: 1 });

console.log(Object.isExtensible(normal)); // true
console.log(Object.isSealed(normal)); // false
console.log(Object.isFrozen(normal)); // false

console.log(Object.isExtensible(noExtend)); // false
console.log(Object.isSealed(noExtend)); // false (属性仍可配置/可删)
console.log(Object.isFrozen(noExtend)); // false

console.log(Object.isExtensible(sealed)); // false
console.log(Object.isSealed(sealed)); // true
console.log(Object.isFrozen(sealed)); // 取决于属性是否可写 (一般 false)

console.log(Object.isExtensible(frozen)); // false
console.log(Object.isSealed(frozen)); // true
console.log(Object.isFrozen(frozen)); // true
```

补充说明:

-   上述检查仅针对对象 "自有属性" 与当前对象本身, 不会影响原型链上的对象.
-   "冻结/密封/不可扩展" 均为浅层; 嵌套对象需单独处理.

<br>

## 深度冻结检测 (示例)

```javascript
function isDeepFrozen(target, seen = new WeakSet()) {
    if (target === null || typeof target !== "object") return true;
    if (seen.has(target)) return true;
    if (!Object.isFrozen(target)) return false;
    seen.add(target);
    for (const key of Object.getOwnPropertyNames(target)) {
        const value = target[key];
        if (!isDeepFrozen(value, seen)) return false;
    }
    return true;
}

const deep = Object.freeze({ a: Object.freeze({ b: 1 }) });
console.log(isDeepFrozen(deep)); // true
```

注意: 此检测不涵盖 `Map`/`Set` 等内部槽位, 也不处理原型链; 若需对复杂结构做强不变性约束, 建议结合结构化递归策略或使用持久化数据结构库.

<br>
