# File

`File` 对象表示一个文件对象, 通常用于处理用户通过文件输入控件选择的文件或通过拖放操作获取的文件. `File` 对象继承自 `Blob` 对象, 因此具有 `Blob` 的所有属性和方法, 并添加了文件相关的额外属性.

<br><br>

# 创建 File 实例

## 基本语法

```js
new File(bits, filename[, options])
```

**参数:**

-   `bits`: 一个包含 ArrayBuffer, ArrayBufferView, Blob, 或者 DOMString 对象的 Array, 或者任何这些对象的组合. 这是 UTF-8 编码的文件内容
-   `filename`: 文件名称 / 文件路径
-   `options`: 可选参数对象
    -   `type`: 表示将要放到文件中的内容的 MIME 类型. 默认值为 `""`
    -   `lastModified`: 文件的最后修改时间, 默认为 `Date.now()`

<br>

## 基本示例

```js
const file = new File(["Hello World"], "hello.txt", { type: "text/plain" });
console.log(file.size); // 11
console.log(file.type); // "text/plain"
console.log(file.name); // "hello.txt"
console.log(file.lastModified); // 1705146820218
```

<br><br>

# File 实例属性

## 继承自 Blob 的属性

-   `size`: 数据的字节数, 只读属性
-   `type`: 数据的 MIME 类型, 只读属性

## File 特有的属性

-   `name`: 文件名, 不包含路径信息
-   `lastModified`: 文件的最后修改时间, 表示为自 1970 年 1 月 1 日以来的毫秒数
-   `lastModifiedDate`: 文件的最后修改时间, 返回一个 `Date` 对象 (已废弃)

```js
const file = new File(["Hello World"], "hello.txt", { type: "text/plain" });

console.log(file.size); // 11 (继承自 Blob)
console.log(file.type); // "text/plain" (继承自 Blob)
console.log(file.name); // "hello.txt" (File 特有)
console.log(file.lastModified); // 时间戳 (File 特有)
console.log(file.lastModifiedDate); // Date 对象 (已废弃)
```

<br><br>

# File 实例方法

## 继承自 Blob 的方法

File 对象可以使用 Blob 的所有方法:

-   `slice([start [, end [, contentType]]])`: 返回一个新的 Blob 实例
-   `text()`: 返回一个 Promise, 兑现包含文件内容的 UTF-8 格式字符串
-   `arrayBuffer()`: 返回一个 Promise, 兑现包含文件二进制数据的 ArrayBuffer
-   `stream()`: 返回一个 ReadableStream 对象

```js
const file = new File(["Hello World"], "hello.txt", { type: "text/plain" });

// 使用继承的方法
const text = await file.text();
console.log(text); // "Hello World"

const buffer = await file.arrayBuffer();
console.log(buffer.byteLength); // 11

const stream = file.stream();
const reader = stream.getReader();
```

<br><br>

# 获取 File 对象

## 1. 通过 input 元素获取

```html
<input type="file" id="fileInput" multiple="multiple" />
```

```js
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", (e) => {
    console.log(e.target.files); // FileList 对象
    const file = e.target.files[0]; // 获取第一个文件
    console.log(file.name); // 文件名
    console.log(file.size); // 文件大小
    console.log(file.type); // MIME 类型
});
```

上传文件后, 控制台就会输出一个 FileList 数组, 这个数组的每个元素都是一个 File 对象, 一个上传的文件就对应一个 File 对象.

<br>

## 2. 通过拖放操作获取

```html
<div id="dropZone" style="width: 300px; height: 200px; border: 2px dashed #ccc;">拖放文件到这里</div>
```

```js
const dropZone = document.getElementById("dropZone");

dropZone.addEventListener("dragover", (e) => {
    e.preventDefault();
});

dropZone.addEventListener("drop", (e) => {
    e.preventDefault();
    console.log(e.dataTransfer.files); // FileList 对象
    const file = e.dataTransfer.files[0]; // 获取第一个文件
    console.log(file.name); // 文件名
});
```

注意: 这里 `drop` 和 `dragover` 事件都调用了 `e.preventDefault()` 阻止默认事件. 这非常重要, 可以用来阻止浏览器的一些默认行为, 比如将放置文件显示在浏览器窗口中.

<br><br>

# 实际应用场景

## 1. 文件上传

```js
// 使用 FormData 上传文件
function uploadFile(file) {
    const formData = new FormData();
    formData.append("file", file);

    fetch("/upload", { method: "POST", body: formData })
        .then((response) => response.json())
        .then((data) => {
            console.log("上传成功:", data);
        })
        .catch((error) => {
            console.error("上传失败:", error);
        });
}

// 使用示例
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
        uploadFile(file);
    }
});
```

<br>

## 2. 文件预览

```js
// 图片预览 (使用 Blob URL)
function previewImage(file) {
    if (file && file.type.startsWith("image/")) {
        const url = URL.createObjectURL(file);
        const img = document.createElement("img");
        img.src = url;
        img.style.maxWidth = "300px";
        document.body.appendChild(img);

        // 图片加载完成后释放 URL
        img.onload = () => {
            URL.revokeObjectURL(url);
        };
    }
}

// 文本预览 (使用 Blob 方法)
async function previewText(file) {
    if (file && file.type.startsWith("text/")) {
        const text = await file.text();
        const pre = document.createElement("pre");
        pre.textContent = text;
        document.body.appendChild(pre);
    }
}
```

<br>

## 3. 文件验证

```js
// 文件类型验证
function validateFileType(file, allowedTypes) {
    return allowedTypes.includes(file.type);
}

// 文件大小验证
function validateFileSize(file, maxSize) {
    return file.size <= maxSize;
}

// 综合验证
function validateFile(file) {
    const allowedTypes = ["image/jpeg", "image/png", "image/gif"];
    const maxSize = 5 * 1024 * 1024; // 5MB

    if (!validateFileType(file, allowedTypes)) {
        alert("不支持的文件类型");
        return false;
    }

    if (!validateFileSize(file, maxSize)) {
        alert("文件大小超出限制");
        return false;
    }

    return true;
}
```

<br>

## 4. 大文件分片上传

```js
// 分片上传大文件
async function uploadLargeFile(file, chunkSize = 1024 * 1024) {
    const totalChunks = Math.ceil(file.size / chunkSize);

    for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);

        const formData = new FormData();
        formData.append("chunk", chunk);
        formData.append("index", i);
        formData.append("total", totalChunks);
        formData.append("filename", file.name);

        await fetch("/upload-chunk", {
            method: "POST",
            body: formData,
        });

        console.log(`上传进度: ${((i + 1) / totalChunks) * 100}%`);
    }

    console.log("文件上传完成");
}
```

<br><br>

# 与 Blob 的关系

## File 继承自 Blob

`File` 对象是 `Blob` 对象的子类, 继承了 `Blob` 的所有属性和方法, 并添加了额外的文件相关属性:

```js
// File 对象可以使用 Blob 的所有方法
const file = new File(["Hello World"], "hello.txt", { type: "text/plain" });

console.log(file.size); // 11 (继承自 Blob)
console.log(file.type); // "text/plain" (继承自 Blob)
console.log(file.name); // "hello.txt" (File 特有)
console.log(file.lastModified); // 时间戳 (File 特有)

// File 对象可以使用 Blob 的所有方法
const text = await file.text();
const buffer = await file.arrayBuffer();
const stream = file.stream();
```

<br>

## 类型检查

```js
// 检查对象是否为 File
function isFile(obj) {
    return obj instanceof File;
}

// 检查对象是否为 Blob
function isBlob(obj) {
    return obj instanceof Blob;
}

// 使用示例
const file = new File(["data"], "test.txt");
const blob = new Blob(["data"]);

console.log(isFile(file)); // true
console.log(isFile(blob)); // false
console.log(isBlob(file)); // true (File 是 Blob 的子类)
console.log(isBlob(blob)); // true
```

<br><br>

# 注意事项

## 1. 安全性

-   File 对象只能通过用户交互 (文件选择、拖放) 获取, 无法通过代码直接访问用户的文件系统
-   出于安全考虑, 浏览器限制了对本地文件系统的直接访问

## 2. 性能优化

-   处理大文件时, 应考虑分块处理, 避免一次性加载到内存
-   使用 `URL.createObjectURL()` 创建的 URL 会占用内存, 使用完毕后应调用 `URL.revokeObjectURL()` 释放

## 3. 错误处理

-   File 的 `text()` 和 `arrayBuffer()` 方法返回 Promise, 需要使用 `await` 或 `.then()` 处理
-   错误处理应包含在 Promise 的 `.catch()` 中

## 4. 文件验证

-   在处理用户上传的文件时, 应验证文件类型和大小
-   确保文件的 MIME 类型正确设置, 以便浏览器正确处理

通过 File 对象, 开发者可以方便地处理用户选择的文件, 实现文件上传、预览、验证等功能, 为 Web 应用提供强大的文件处理能力.

<br>
