# 自增自减

`++` `--`

-   `++num`、`num++` 的区别：
    `++` 在前，先 + 1，再参与运算
    `++` 在后，先参与运算，再 + 1
-   `--num`、`num--` 同理 - 1

```js
let num1 = 1,
    num2 = 1;
let number1 = num1++, // 先运算，再自增
    number2 = ++num2; // 先自增，再运算
console.log('number1', number1, 'num1', num1); // number1 1 num1 2
console.log('number2', number2, 'num2', num2); // number2 2 num2 2
```

不论 `++` 在前在后，对变量自身都不会有影响，只会影响参与运算的式子。

<br>

-   对于非数值的变量，会将变量隐式转换成 number 类型。

```js
let numStr = '2'; // Number("2") → 2
let bool = false; // Number(false) → 0
let str = 'z'; // Number("a") → NaN
console.log(++numStr); // 3
console.log(++bool); // 1
console.log(++str); // NaN
```

<br><br>

# 算术运算符

`+` `-` `*` `/` `%`

-   小数运算返回的数值可能不太准确。（因为计算机底层使用的是二进制数字，转换时会有误差）

```js
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(5 / 3); // 1.6666666666666667
```

<br>

注意：取模运算的第二个数，不能为 `0`，否则返回 `NaN`。

```js
console.log(1 % 0); // NaN
```

<br>

-   如果有其它类型的数据参与数学运算，**会被隐式转换为 number 类型**。
-   `Number()` 转换不了会返回 `NaN`，**`NaN` 参与任何数学运算都返回 `NaN`**。

```js
console.log(1 + true); // 2
console.log(1 + undefined); // NaN
console.log(1 + null); // 1
console.log(2 * '2'); // 4
console.log(2 * '2天'); // NaN
```

<br>

-   **注意**：string 与任意类型的数据进行 **`+` 运算** 都是拼接操作。

```javascript
console.log(2 + '2'); // 22
```

<br><br>

# 比较运算符

`<` `>` `<=` `>=` `==` `!=` `===` `!==`

-   如果比较运算成立，则返回 `true`；不成立 / 比较不了，则返回 `false`。

```javascript
10 > NaN; // false
10 > 2; // true
```

<br>

## 全等运算

相等运算符 `==`：比较**值**是否相等，数据会发生隐式类型转换。
全等运算符 `===`：比较**值** & **数据类型**是否相等。

```js
6 == '6'; // true
6 === '6'; // false
```

<br>

## 原始类型数据

-   原始类型数据之间进行比较运算时，非 number 类型的数据会被隐式转换为 number 类型。
-   如果 `Number()` 转换不了 就会返回 `NaN`，`NaN` 不等于任何值，比较不了，最终返回 `false`。

```js
10 > '015'; // false
10 > '2'; // true
```

```js
'' == true; // false
'1' == true; // true
'2' == true; // false
```

<br>

-   **string 与 string** 进行比较：比较第一个字符的 ASCII 码；如果第一个字符一样，就比较第二个字符；以此类推...

```javascript
console.log('10' > '20'); // false
```

<br>

## 引用类型数据

-   对于引用类型数据，操作的是数据存储的地址。

```js
const obj1 = {};
const obj2 = obj1;
obj1 == obj2; // true
```

```js
const obj1 = {};
const obj2 = {};
obj1 == obj2; // false
```

<br>

## 引用类型 & 原始类型

如果有一边是 string、number 或 symbol，则另一边的引用类型数据也会隐式地转为 string、number 或 symbol

```js
'[object Object]' == {}; // true
[1, 2] == '1,2'; // true
0 == []; // true
1 == [1]; // true
```

<br>

## 注意事项

-   比较运算符不要连续使用。因为比较运算返回的是 boolean 值，可能会影响实际的比较结果

```javascript
console.log(3 > 2 > 1); // 3 > 2 返回 true， Number(true) 为 1， 所以最终返回 false
```

-   **特别的 1** ：`null` 转换为数字是 `0`，但是 `null != 0`

```javascript
console.log(Number(null)); // 0
console.log(null == 0); // false
```

-   **特别的 2** ：`null` 与 `undefined` 相等，但不全等（`null === null`；`undefined === undefined`）

```javascript
console.log(null == undefined); // true → 因为 undefined 继承自 Null
console.log(null === undefined); // false → null 是 Null 类型，undefined 是 underfined 类型
```

-   **特别的 3** ：`NaN != 任何值` ( 连自己都不等于 )

```javascript
console.log(NaN == NaN); // false
```

<br><br>

# 逻辑运算符

`!` (非)、`&&` (与)、`||` (或)

-   对于非布尔值，JS 会将其隐式转换为 `boolean` 类型。

<br>

## 基础用法

-   `&&`：只有两边都是 `true` 才返回 `true`，否则返回 `false`。

-   `||`：只有两边都是 `false` 才返回 `false`，否则返回 `true`。

-   `!`：取反；**无论作用于什么类型的值，都会返回一个布尔值**。
    `!` 会把操作的数据转换为布尔类型，然后再取反。

    6 个负性值：`0`、 `NaN`、 `""`、`null`、 `undefined`、 `false`； 其余值转布尔类型都为 `true`，取反则为 `false`。

```js
console.log(true && true); // true
console.log(false || false); // false
console.log(!true); // false
console.log(!''); // true
```

<br>

## 短路算法

> #### （1）&&

-   两边都为 true 才为 true
-   判断的逻辑：先将第一个值转为 boolean 类型进行判断：
    ① 如果是 false，则直接返回第一个值，**第二个值不执行**
    ② 如果为 true，则执行并返回第二个值

```js
console.log(false && 5); // false
console.log(null && 哈哈); // null - 因为第二个值不执行，所以出错了也不会抛出
console.log(3 && 5); // 5
console.log(true && 'a'); // a
```

<br>

> #### （2）||

-   两边都为 false 才为 false
-   判断的逻辑：先将第一个值转为 boolean 类型进行判断：
    ① 如果为 true，则直接返回第一个值，**第二个值不执行**
    ② 如果为 false，则执行并返回第二个值

```js
console.log(false || 5); // 5
console.log(null || 'a'); // a
console.log(true || 'a'); // true
console.log(3 || 哈哈); // 3  - 因为第二个值不执行，所以出错了也不会抛出
```

<br><br>

# 赋值运算符

`=` `+=` `-=` `*=` `/=` `%=`

-   将右边的值赋予给左边的变量，所以执行顺序为：**左 ← 右**

```js
num += n; // 等价于 num = num + n;
num += n + 1; // 等价于 num = num + n + 1;
```

<br><br>

# 按位运算符

按位运算符是一类用于操作二进制数据的运算符。它们对操作数中的每个位进行操作，并生成新的二进制结果。

1. 按位与（`&`）：当两个位都为 1 时，结果位为 1；否则为 0。

```javascript
const a = 5; // 二进制表示为 0101
const b = 3; // 二进制表示为 0011
const result = a & b; // 二进制 0001，结果为 1
console.log(result); // 1
```

2.  按位或（`|`）：当两个位中至少有一个位为 1 时，结果位为 1；否则为 0。

```javascript
const a = 5; // 二进制表示为 0101
const b = 3; // 二进制表示为 0011
const result = a | b; // 二进制 0111，结果为 7
console.log(result); // 7
```

3.  按位异或（`^`）：当两个位不相同时，结果位为 1；否则为 0。

```javascript
const a = 5; // 二进制表示为 0101
const b = 3; // 二进制表示为 0011
const result = a ^ b; // 二进制 0110，结果为 6
console.log(result); // 6
```

4.  按位非（`~`）：将每个位取反。对于有符号整数，按位非运算将其转换为补码形式。

```javascript
const a = 5; // 二进制表示为 0000 0000 0000 0101
const result = ~a; // 二进制 1111 1111 1111 1010，结果为 -6
console.log(result); // -6
```

5.  左移（`<<`）：将操作数的二进制表示向左移动指定的位数。左移时，右侧空出的位用 0 填充。

```javascript
const a = 5; // 二进制表示为 0000 0000 0000 0101
const result = a << 2; // 二进制 0000 0000 0001 0100，结果为 20
console.log(result); // 20
```

6.  右移（`>>`）：将操作数的二进制表示向右移动指定的位数。右移时，左侧空出的位根据操作数的符号进行填充。

```javascript
const a = -10; // 二进制表示为 1111 1111 1111 0110
const result = a >> 2; // 二进制 1111 1111 1111 1101，结果为 -3
console.log(result); // -3
```

7.  无符号右移（`>>>`）：将操作数的二进制表示向右移动指定的位数。右移时，左侧空出的位用 0 填充。

```javascript
const a = -10; // 二进制表示为 1111 1111 1111 0110
const result = a >>> 2; // 二进制 0011 1111 1111 1101，结果为 1073741821
console.log(result); // 1073741821
```

按位运算符通常用于处理二进制数据、位操作、掩码操作等场景，而不是常规的数学运算。它们在处理位级别的操作时非常有用。

<br><br>

# 条件运算符

格式：`variable = boolean_expression ? true_value : false_value;`

```js
let max = num1 > num2 ? num1 : num2;
```

如果 `num1` 大于 `num2` (条件表达式为 `true`)，则将 `num1` 赋给 `max`；否则，将 `num2` 赋给 `max`。

<br><br>

# 指数运算符

ES7 新增的指数运算符 `**`：`数值 ** 次方数`，相当于 `Math.pow(数值, 次方数)`。

```js
2 ** 2; // 2 的 2 次方 = 4
2 ** 3; // 2 的 3 次方 = 4
```

指数运算符可以与赋值运算符 `=` 结合，形成一个新的赋值运算符 `**=`：

```js
a **= 2; // 等同于 a = a ** 2;
b **= 3; // 等同于 b = b ** 3;
```

<br><br>

# 运算符优先级

以下是一些常见运算符按照优先级从高到低的顺序：

1. 小括号 `()`：括号用于分组运算，具有最高的优先级。
2. 指数运算符 `**`：指数运算符用于进行指数运算。
3. 一元运算符：包括逻辑非 `!`、正号 `+`、负号 `-`、位非 `~` 等。
4. 乘法、除法和取模运算符：`*`、`/` 和 `%`。
5. 加法和减法运算符：`+` 和 `-`。
6. 位移运算符：左移 `<<`、右移 `>>` 和无符号右移 `>>>`。
7. 关系运算符：大于 `>`、小于 `<`、大于等于 `>=`、小于等于 `<=`、`instanceof`、`in` 等。
8. 相等性运算符：严格相等 `===`、严格不等 `!==`、抽象相等 `==`、抽象不等 `!=`。
9. 位运算符：按位与 `&`、按位或 `|`、按位异或 `^`。
10. 逻辑运算符：逻辑与 `&&` 和逻辑或 `||`。
11. 条件运算符：条件运算符 `condition ? valueIfTrue : valueIfFalse`。
12. 赋值运算符：赋值 `=`、加等于 `+=`、减等于 `-=`、乘等于 `*=` 等。

<br>
