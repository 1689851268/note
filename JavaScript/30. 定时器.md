# 使用定时器

1. [window.]setTimeout - 延迟定时器
2. [window.]setInterval - 循环定时器（间隔器）

<br>

定时器一般接收 2 个参数：

1.  回调函数 / 能被当成 JS 语句执行的字符串
2.  间隔时间；默认为 `0`，即 “立即” 执行

```js
setTimeout('console.log("superman")', 2000);
```

```js
setTimeout(() => {
    console.log('superman');
}, 2000);
```

-   根据 W3C 的标准，当嵌套层级 >= 5 层时，计时器的最小时间会被设置为 4ms。

<br>

定时器可以接收 2 个以上的参数，第 2 个之后的参数都会作为实参被传入回调函数中：

```js
const fun = (a, b) => {
    console.log(a, b);
};
setTimeout(fun, 2000, 10, 20);
```

<br><br>

# 清除定时器

使用定时器时，会返回该定时器的标识：

```js
const timer1 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer1); // 1

const timer2 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer2); // 2

const timer3 = setTimeout(() => {
    console.log('00');
}, 2000);
console.log(timer3); // 3
```

<br>

可以通过定时器的标识清除定时器：

1. `clearTimeout(timer)` → 清除 setTimeout
2. `clearInterval(timer)` → 清除 setInterval

```js
const timer1 = setTimeout(() => {
    console.log('00');
}, 2000);
clearTimeout(timer1);

const timer2 = setTimeout(() => {
    console.log('00');
}, 2000);
clearTimeout(timer2);
```

<br><br>

# 练一练

问：计时器是否能精确计时？为什么？

答：不能。原因如下：

1.  根据 W3C 的标准，当嵌套层级 >= 5 层时，计时器的最小时间会被设置为 4ms。
2.  由于事件循环机制，可能计时器的事件到了，其回调函数还需要经过排队才会被执行。

<br>

demo - 日常开发中的定时器：

```js
let timer = null;

const start = () => {
    if (timer) {
        return;
    }
    timer = setInterval(() => {
        console.clear();
        console.log(Date.now());
    }, 1000);
};

const stop = () => {
    clearInterval(timer);
    timer = null;
};
```

上例避免了重复开启定时器的情况。

<br>
