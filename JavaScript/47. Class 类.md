# Class

Class 是一种用于创建对象的语法糖，它是一种基于原型继承的面向对象编程（OOP）的概念。

Class 提供了一种更简洁的方式来定义对象的结构和行为，并且使得创建和管理对象变得更加方便。

-   使用 ES5 的方法创建对象：

```js
// 通过构造函数设置实例属性
function Person(name) {
    this.name = name;
}

// 为原型 Person.prototype 添加方法, 使得所有实例共享此方法
Person.prototype.showName = function () {
    return `名字: ${this.name}`;
};

const person = new Person('superman');
console.log(person.showName());
```

-   使用 ES6 的方法创建对象：

```js
class Person {
    // 构造方法 constructor, 只要执行 new Person(), 构造方法就会被调用
    constructor(name) {
        console.log(`执行构造函数`);
        this.name = name; // 可以在 constructor 里面设置实例属性
    }

    // 可以在 class 里面直接编写方法, 相当于为原型 Person.prototype 添加方法, 使得所有实例共享此方法
    // 注意: 类中定义的方法遵守 [严格模式]
    showName() {
        return `名字: ${this.name}`;
    }
}

const person = new Person(`superman`, 18);
console.log(person.showName());
```

在严格模式下，函数中的 `this` 默认值不再指向全局对象（如浏览器环境下的 `window`），而是为 `undefined`

<br><br>

# constructor

-   通过 `new` 创建实例时，会自动调用类的构造方法 `constructor`
-   类必须有构造方法 `constructor`，如果没有显式定义，JS 会默认添加一个空的构造方法

```js
class Fn {}

// 等同于
class Fn {
    constructor() {}
}
```

-   构造方法 `constructor` 默认返回当前实例 `this`
-   开发者也可以手动 `return` 值：
    如果返回 [引用类型数据]，会覆盖默认返回值
    如果返回 [基本类型数据]，则仍然返回当前实例 `this`

```js
class Foo {
    constructor() {
        return { name: 'superman' }; // 返回一个对象
    }
}

const foo = new Foo();
console.log(foo); // { name: 'superman' }
console.log(foo instanceof Foo); // false
```

<br><br>

# getter & setter

-   `get xxx()`：获取指定值时 自动调用
-   `set xxx(xx)`：修改指定值时 自动调用

```js
class Person {
    constructor(age) {
        this._age = age; // 下划线开头的属性, 为私有属性, 不能直接获取 (这是一个约定)
    }
    // getter;  getter 里面不要写其他语句, 会报错
    get age() {
        console.log('getter 已被调用');
        return this._age;
    }
    // setter
    set age(value) {
        console.log('setter 已被调用');
        this._age = value;
    }
}

const person = new Person(18);
console.log(person.age); // getter 已被调用    18
person.age = 21; // setter 已被调用
console.log(person.age); // getter 已被调用    21
```

<br><br>

# 静态属性(方法)

-   用关键字 `static` 修饰的属性(方法)为静态属性(方法)
-   静态属性(方法)需要通过类名调用

```js
class Person {
    // 静态属性
    static name = 'Lee';
    // 静态方法
    static sayHello() {
        // 通过 Person 类使用静态属性
        console.log(`Hello, my name is ${Person.name}`);
        console.log(this); // this 指向 Person 类
    }
}

const person = new Person();
Person.sayHello(); // 通过 Person 类调用静态方法
```

<br><br>

# 类的继承

```js
// 编写父类
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    showName() {
        console.log('父类的 showName 方法');
        return `名字: ${this.name}`;
    }
    showAge() {
        console.log('父类的 showAge 方法');
        return `年龄: ${this.age}`;
    }
}

// 编写子类
class Student extends Person {
    // 如果子类实例中没有独有的属性, 可以不用编写构造方法
    constructor(name, skill, age) {
        // 在子类的构造方法中, 必须先通过 super 调用父类的构造方法
        super(name, age);
        // 设置子类实例独有的属性
        this.skill = skill;
    }

    // 重写父类的方法
    showName() {
        // 在子类的普通方法中, 可以通过 super 调用父类的方法
        super.showName();
        // 编写其他逻辑代码
        console.log('子类的 showName 方法');
        return `名字: ${this.name}`;
    }

    // 编写子类的方法
    showSkill() {
        return `技能: ${this.skill}`;
    }
}

const stu = new Student('superman', '逃课', 18);

console.log(stu.name, stu.skill); // superman 逃课
console.log(stu.showSkill()); // 技能: 逃课
console.log(stu.showAge()); // 父类的 showAge 方法    年龄: 18
console.log(stu.showName()); // 父类的 showName 方法    子类的 showName 方法    名字: superman
```

<br><br>
