JS 代码的执行，主要分为 2 个阶段：编译阶段、执行阶段

# 编译阶段

## 词法分析 Scanner

将语句分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/zewrLkrYfsOKp8lrAKmZtiaV5IyWTG5qP5pWEg7BXaoiaprKhNFT2ZPpekOxZM6rM5N7CrOvUSjRKkibIxSGicMCKw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 33%;" />

```js
[
    {
        type: 'Keyword',
        value: 'var',
    },
    {
        type: 'Identifier',
        value: 'myName',
    },
    {
        type: 'Punctuator',
        value: '=',
    },
    {
        type: 'String',
        value: "'FinGet'",
    },
    {
        type: 'Punctuator',
        value: ';',
    },
];
```

<br>

## 语法分析 Parser

将词法单元流 即上述的数组，转换成一个由元素逐级嵌套组成的、代表了程序语法结构的树；
这个树被称为 “抽象语法树” (Abstract Syntax Tree，AST)

```json
{
    "type": "Program",
    "body": [
        {
            "type": "VariableDeclaration",
            "declarations": [
                {
                    "type": "VariableDeclarator",
                    "id": {
                        "type": "Identifier",
                        "name": "myName"
                    },
                    "init": {
                        "type": "Literal",
                        "value": "FinGet",
                        "raw": "'FinGet'"
                    }
                }
            ],
            "kind": "var"
        }
    ],
    "sourceType": "script"
}
```

在此过程中，如果源代码不符合语法规则，则会终止，并抛出 “语法错误”

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/zewrLkrYfsOKp8lrAKmZtiaV5IyWTG5qPPiaPcoaE88vb8CGCjQicFVVxUDZpvdtC62lfOibOu87x3AOSHtfbfffpQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />

可以使用 [esprima](https://esprima.org/demo/parse.html#) 实时生成语法树~

<br>

## 字节码生成

可以用 `node --print-bytecode` 查看字节码：

```js
// test.js
function getMyName() {
    var myName = 'superman';
    console.log(myName);
}
getMyName();
```

```bash
$ node --print-bytecode test.js
...
[generated bytecode for function: getMyname (0x10ca700104e9 <SharedFunctionInfo getMyname>)]
Parameter count 1
Register count 3
Frame size 24
   18 E> 0x10ca70010e86 @    0 : a7                StackCheck
   37 S> 0x10ca70010e87 @    1 : 12 00             LdaConstant [0]
         0x10ca70010e89 @    3 : 26 fb             Star r0
   48 S> 0x10ca70010e8b @    5 : 13 01 00          LdaGlobal [1], [0]
         0x10ca70010e8e @    8 : 26 f9             Star r2
   56 E> 0x10ca70010e90 @   10 : 28 f9 02 02       LdaNamedProperty r2, [2], [2]
         0x10ca70010e94 @   14 : 26 fa             Star r1
   56 E> 0x10ca70010e96 @   16 : 59 fa f9 fb 04    CallProperty1 r1, r2, r0, [4]
         0x10ca70010e9b @   21 : 0d                LdaUndefined
   69 S> 0x10ca70010e9c @   22 : ab                Return
Constant pool (size = 3)
Handler Table (size = 0)
...
```

这里涉及到一个很重要的概念：JIT (Just-in-time) - 一边解释，一边执行

> #### JIT (Just-in-time)

1. 在 JS 引擎中增加一个监视器 (分析器)。监视器监控着代码的运行情况。
   如果同一行代码运行了几次，这个代码段就被标记成了 “warm”；如果运行了很多次，则被标记成 “hot”
2. 如果一段代码变成了 “warm”，JIT 就会把它送到**基线编译器**去编译，并且把编译结果存储起来。
   如果监视器监视到了某行/变量执行了同样的代码、使用了同样的变量类型，就会用编译后的结果替换掉这一行代码的执行、并存储
3. 如果一段代码变成了 “hot”，监视器就会把它发送到**优化编译器**中。生成一个更快速、高效的代码、并存储。
   例如：循环给一个对象添加属性时，假设属性是 INT 类型，则优先做 INT 类型的判断
4. 可是对于 JS 从来就没有确定这么一说，前 99 个对象属性保持着 INT 类型，可能第 100 个就没有这个属性了，那么这时候 JIT 会认为做了一个错误的假设，并把优化代码丢掉，执行过程将会回到解释器/基线编译器，这一过程叫做**反优化**。

<br>

## 作用域

作用域是一套规则，用来管理引擎如何查找变量。
ES6 之前，JS 只有 [全局作用域] & [函数作用域]；
ES6 引入了块级作用域；但这个块级别作用域需要注意的是：不是 `{}` 的作用域，而是 `let`、`const` 关键字的块级作用域

```js
var name = 'FinGet';

function fn() {
    var age = 18;
    console.log(name);
}
```

在解析时就会确定作用域：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/zewrLkrYfsOKp8lrAKmZtiaV5IyWTG5qPMCwA8nJ0ebVOcIic7lg95hofiaT76EWKDqVy6y573Qceys6Xu6UNksPw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:40%;" />

> #### 词法作用域

-   词法作用域就是指作用域是由代码中函数**声明**的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符
-   注意：是函数**声明**的位置决定作用域，不是函数调用的位置决定作用域

```js
function fn() {
    console.log(myName);
}
function fn1() {
    var myName = 'inner';
    fn();
}
var myName = 'outer';
fn1();
```

上面代码打印的结果是：`outer`，这是因为在编译阶段就已经确定了作用域，`fn` 是定义在全局作用域中的，它在自己内部找不到`myName` 就会去全局作用域中找，不会在 `fn1` 中查找

<br><br>

# 执行阶段

## 执行上下文

-   [执行上下文] 是当前 JS 代码被解析和执行时所在环境的抽象概念
-   遇到函数执行的时候，就会创建一个 [执行上下文]
-   JS 中有 3 种执行上下文类型：
    ① 全局执行上下文 (只有一个)
    ② 函数执行上下文
    ③ eval
-   执行上下文的创建分为 2 个阶段创建：
    ① 创建阶段
    ② 执行阶段

<br>

## 创建阶段

-   在任意的 JS 代码被执行时，执行上下文处于创建阶段
-   在创建阶段中总共发生了 3 件事情：
    ① 确定 this 值，也被称为 This Binding
    ② LexicalEnvironment (词法环境)，组件被创建
    ③ VariableEnvironment (变量环境)，组件被创建

```js
ExecutionContext = {
    ThisBinding = <this value>, // 确定this
    LexicalEnvironment = { ... }, // 词法环境
    VariableEnvironment = { ... }, // 变量环境
}
```

<br>

## This Binding

在全局执行上下文中，this 指向全局对象。在浏览器中，this 指向 window 对象。
在函数执行上下文中，this 的值取决于函数的调用方式。如果它被一个对象引用调用，那么 this 的值被设置为该对象，否则 this 的值被设置为全局对象或 `undefined`（严格模式下）

<br>

## 词法环境 Lexical Environment

-   词法环境是一个包含 [标识符-变量] 映射的结构
-   在词法环境中，有 2 个组成部分：
    ① 环境记录 (environment record)：存储变量和函数声明的实际位置
    ② 对外部环境的引用：意味着它可以访问其外部词法环境 (实现作用域链的重要部分)
-   词法环境有 2 种类型：
    ① 全局环境：是一个没有外部环境的词法环境。全局环境的外部环境引用为 `null`。
    它拥有一个全局对象 (window) 及其关联的方法和属性 & 用户自定义的全局变量
    ② 函数环境：用户在函数中定义的变量被存储在环境记录中。
    对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境
-   注意：对于函数环境而言，[环境记录] 还包含 arguments 对象，包含了 [索引-传递给函数的参数] 映射 & 传递给函数的参数的数量

<br>

## 变量环境 Variable Environment

-   变量环境也是一个词法环境，具有上面定义的词法环境的所有属性
-   其 EnvironmentRecord 包含了由 VariableStatements 在此 [执行上下文] 创建的绑定

```js
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
    var g = 20;
    return e * f * g;
}

c = multiply(20, 30);
```

```js
/* 全局执行上下文 */
GlobalExecutionContext = {
    ThisBinding: <Global Object>,

    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Object",
            // 标识符绑定在这里
            a: <uninitialized>,
            b: <uninitialized>,
            multiply: <func>,
        },
        outer: <null>,
    },

    VariableEnvironment: {
        EnvironmentRecord: {
            Type: "Object",
            // 标识符绑定在这里
            c: undefined,
        },
        outer: <null>,
    },
};

/* 函数执行上下文 */
FunctionExecutionContext = {
    ThisBinding: <Global Object>,

    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Declarative",
            // 标识符绑定在这里
            Arguments: { 0: 20, 1: 30, length: 2 },
        },
        outer: <GlobalLexicalEnvironment>, // 指定全局环境
    },

    VariableEnvironment: {
        EnvironmentRecord: {
            Type: "Declarative",
            // 标识符绑定在这里
            g: undefined,
        },
        outer: <GlobalLexicalEnvironment>,
    },
};
```

仔细看上面：`a: <uninitialized>`、`c: undefined`。
可知：`let a` 之前 `console.log(a)` 会得到 Uncaught ReferenceError: Cannot access 'a' before initialization

<br>

## 为什么要有两个词法环境

变量环境组件 (VariableEnvironment) 用来登记 `var` `function` 的声明；
词法环境组件 (LexicalEnvironment) 用来登记 `let` `const` `class` ... 的声明。

在 ES6 之前都没有块级作用域，ES6 之后我们可以用 `let` `const` 来声明块级作用域。
有这两个词法环境是为了实现块级作用域的同时不影响 `var` 变量声明和函数声明

1. 首先在一个正在运行的执行上下文内，词法环境由 LexicalEnvironment 和 VariableEnvironment 构成，用来登记所有的变量声明
2. 当执行到块级代码时候，LexicalEnvironment 会先记录下来，记录为 oldEnv
3. 创建一个新的 LexicalEnvironment ( outer 指向 oldEnv )，记录为 newEnv，并将 newEnv 设置为正在执行上下文的 LexicalEnvironment
4. 块级代码内的 `let` `const` 会登记在 newEnv 里面，但是 `var` 声明和函数声明还是登记在原来的 VariableEnvironment 里
5. 块级代码执行结束后，将 oldEnv 还原为正在执行上下文的 LexicalEnvironment

```js
function foo() {
    var a = 1;
    let b = 2;
    {
        let b = 3;
        var c = 4;
        let d = 5;
        console.log(a); // 1
        console.log(b); // 3
    }
    console.log(b); // 2
    console.log(c); // 4
    console.log(d); // ReferenceError: d is not defined
}
foo();
```

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/zewrLkrYfsOKp8lrAKmZtiaV5IyWTG5qPibicPvd5coUBYiaiakrcbDB7wjv2E7nrYkc9AgbBQlbxOXEgaibiadicyJSCw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:33%;" />

可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在

其实，在词法环境内部，维护了一个小型**栈**结构。栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let / const 声明的变量

再接下来，当执行到作用域块中的 console.log(a) 这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：
沿着词法环境的栈顶向下查询：
① 如果在词法环境中的某个块中查找到了，就直接返回给 JS 引擎；
② 如果没有查找到，则继续在变量环境中查找

<br>

## 执行栈 Execution Context Stack

每个函数都会有自己的执行上下文，多个执行上下文就会以栈 (调用栈) 的方式来管理

```js
function a() {
    console.log('In fn a');
    function b() {
        console.log('In fn b');
        function c() {
            console.log('In fn c');
        }
        c();
    }
    b();
}
a();
```

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/zewrLkrYfsOKp8lrAKmZtiaV5IyWTG5qP5AOic5zfh6WHOa93DQwUCZya0RhvvDlj7JBpLSmsJoM5pzoj3wzLrbQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

可以用 javascript visualizer 更直观地观察进栈、出栈

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/zewrLkrYfsOKp8lrAKmZtiaV5IyWTG5qPRIWe8Y1paDbKSnABVicich3kL8DuuzQTDGrquMUd4G6tiaz3u4IXQSyPg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

作用域链就是在执行上下文创建阶段确定的。有了执行的环境，才能确定它应该和谁构成作用域链

<br><br>

# 页面加载的流程

1. **创建** document 对象。解析 HTML 及其文本内容后，添加 Element 对象和 Text 节点到文档中
   这个阶段的 **`document.readyState = 'loading'`**

2. 如果遇到 `link` 标签引入外部 CSS 文件，浏览器会创建新线程加载 CSS 文件，同时继续解析文档（异步）

3. ① 如果引入外部 JS 文件，且没有设置 `async`、`defer` 等操作，浏览器会加载 JS 文件，阻塞主线程，等 JS 文件加载、并执行完，再继续解析文档（同步）

    ② 如果引入外部 JS 文件，且设置了 `async`、`defer` 等操作，浏览器会创建新线程加载 JS 文件，同时继续解析文档（异步）

4. 如果遇到 `img`、`iframe` 等标签，浏览器会异步加载 `src`，同时继续解析文档（异步）

5. 文档**解析**完成后，设置有 `defer` 的脚本会按顺序执行（同步）、此时的 **`document.readyState = 'interactive'`**

    <u>document 对象触发 `DOMContentLoaded` 事件</u>，这标志着程序从 [同步脚本执行阶段] → [事件驱动阶段]

6. 等所有异步的数据资源**加载**完后，**`document.readyState = 'complete'`**，<u>window 对象触发 `load` 事件</u>

    从此，以异步响应方式处理用户输入、网络事件...

简单来说：
① **创建** document 对象，此时 `document.readyState = 'loading'`
② 文档**解析**完成：此时 `document.readyState = 'interactive'`，document 对象触发 `DOMContentLoaded` 事件
③ 文档**加载**完成：此时 `document.readyState = 'complete'`，window 对象触发 `load` 事件

```js
console.log('create', document.readyState); // create loading

// DOM 解析完成
document.addEventListener(
    'DOMContentLoaded',
    () => console.log('DOMContentLoaded', document.readyState) // DOMContentLoaded interactive
);

// 资源加载完
window.onload = function () {
    console.log('onload', document.readyState); // onload complete
};

// document.readyState 更新
document.onreadystatechange = function () {
    console.log('onreadystatechange', document.readyState);
    // onreadystatechange interactive
    // onreadystatechange complete
};
```

<br>

## 同步加载 JS

-   浏览器会同步加载 JS 代码，以防 JS 操作 DOM 时出错

-   浏览器加载 .html 时，如果遇到了 script 标签，会停下来 先把 script 标签里的 JS 执行完
    如果 script 标签里 有外部文件，那就必须等待其下载、执行，然后浏览器才会继续往下执行

    如果网速较慢，JS 文件的下载就会阻止后面代码的执行

<br>

## 重构 & 重绘

DOM 树生成后，会等待 CSS 树生成，之后再等 Render 树生成，最后才绘制页面

我们可以简单地理解为：
reflow 重构是结构发生了变化，进而影响页面布局。eg：元素的宽高...（效率较低，需要生成新的 DOM 树，再生成新的 Render 树）
repaint 重绘是样式发生了变化，不会影响页面布局。eg：元素的颜色...（效率较搞）
