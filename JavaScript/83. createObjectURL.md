# createObjectURL

`URL.createObjectURL()` 是 JavaScript 中的一个静态方法, 用于为指定的 `File`、`Blob` 或 `MediaSource` 对象创建一个临时的、唯一的 URL. 这个 URL 可用于在浏览器中引用这些对象的内容, 例如在 `<img>`、`<video>` 或 `<audio>` 元素中显示或播放.

<br><br>

# 基本语法

```js
const objectURL = URL.createObjectURL(object);
```

**参数:**

-   `object`: 一个 `File`、`Blob` 或 `MediaSource` 对象

**返回值:**

-   一个字符串, 表示为指定对象生成的唯一 URL

<br><br>

# 基本使用

## 图片预览

以下示例展示了如何使用 `URL.createObjectURL()` 方法在网页中预览用户选择的本地图片文件:

```html
<input type="file" id="fileInput" accept="image/*" /> <img id="preview" style="max-width: 100%; height: auto;" />
```

```js
const fileInput = document.getElementById("fileInput");
const preview = document.getElementById("preview");

fileInput.addEventListener("change", function () {
    const file = fileInput.files[0];
    if (file) {
        const objectURL = URL.createObjectURL(file);
        console.log("objectURL", objectURL);
        preview.src = objectURL;

        // 当图片加载完成后, 释放对象URL
        preview.onload = function () {
            URL.revokeObjectURL(objectURL);
        };
    }
});
```

在此示例中, 用户选择图片文件后, `createObjectURL()` 方法生成一个临时 URL, 并将其赋值给 `<img>` 元素的 `src` 属性, 从而实现图片预览.

<br>

## 视频播放

以下示例展示了如何使用 `URL.createObjectURL()` 方法播放用户选择的本地视频文件:

```html
<input type="file" id="videoInput" accept="video/*" />
<video id="videoPlayer" controls style="max-width: 100%; height: auto;"></video>
```

```js
const videoInput = document.getElementById("videoInput");
const videoPlayer = document.getElementById("videoPlayer");

videoInput.addEventListener("change", function () {
    const file = videoInput.files[0];
    if (file) {
        const objectURL = URL.createObjectURL(file);
        videoPlayer.src = objectURL;

        // 当视频加载完成后, 释放对象URL
        videoPlayer.onloadeddata = function () {
            URL.revokeObjectURL(objectURL);
        };
    }
});
```

在此示例中, 用户选择视频文件后, `createObjectURL()` 方法生成一个临时 URL, 并将其赋值给 `<video>` 元素的 `src` 属性, 从而实现视频播放.

<br>

## 文件下载

以下示例展示了如何使用 `URL.createObjectURL()` 方法创建并下载一个文本文件:

```html
<button id="downloadBtn">下载文件</button>
```

```js
document.getElementById("downloadBtn").addEventListener("click", function () {
    const content = "这是一个示例文本文件的内容.";
    const blob = new Blob([content], { type: "text/plain" });
    const objectURL = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = objectURL;
    link.download = "示例文件.txt";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // 释放对象 URL
    URL.revokeObjectURL(objectURL);
});
```

在此示例中, 点击按钮时创建包含文本内容的 `Blob` 对象, 使用 `URL.createObjectURL(blob)` 方法生成临时 URL, 创建一个隐藏的链接元素触发文件下载.

<br><br>

# 内存管理

## revokeObjectURL

`URL.revokeObjectURL()` 方法用于释放之前通过 `URL.createObjectURL()` 创建的对象 URL.

```js
URL.revokeObjectURL(objectURL);
```

**参数:**

-   `objectURL`: 通过 `URL.createObjectURL()` 创建的对象 URL

<br>

## 内存管理最佳实践

每次调用 `URL.createObjectURL()` 都会创建一个新的对象 URL, 即使传入的是同一个对象. 为了避免内存泄漏, 应在不再需要该 URL 时调用 `URL.revokeObjectURL()` 释放资源.

```js
const file = fileInput.files[0];
const objectURL = URL.createObjectURL(file);

// 使用对象 URL
preview.src = objectURL;

// 在适当的时机释放资源
preview.onload = function () {
    URL.revokeObjectURL(objectURL);
};
```

**注意事项:**

-   对象 URL 的生命周期与创建它们的文档绑定
-   当文档被卸载时, 浏览器会自动释放这些 URL
-   为了优化性能和内存使用, 建议在适当的时候手动释放它们

<br><br>

# 与 FileReader 的对比

## createObjectURL vs FileReader

| 特性     | createObjectURL      | FileReader               |
| -------- | -------------------- | ------------------------ |
| 性能     | 更高效, 直接创建 URL | 需要读取整个文件内容     |
| 内存使用 | 较低, 按需加载       | 较高, 一次性加载全部内容 |
| 适用场景 | 预览、播放媒体文件   | 需要访问文件内容时       |
| 异步性   | 同步创建 URL         | 异步读取文件内容         |

<br>

## 使用场景选择

**使用 createObjectURL 的场景:**

-   图片预览
-   视频/音频播放
-   文件下载
-   不需要访问文件具体内容的场景

**使用 FileReader 的场景:**

-   需要读取文件内容进行分析
-   文件内容验证
-   文本文件处理
-   需要将文件转换为其他格式

<br><br>

# 浏览器兼容性

`URL.createObjectURL()` 方法在大多数现代浏览器中都受支持:

-   Chrome: 8+
-   Firefox: 4+
-   Safari: 6+
-   Edge: 12+

但在某些旧版浏览器中可能不受支持, 使用前应检查浏览器兼容性.

<br><br>

# 注意事项

1. **安全性**: 对象 URL 仅在当前文档的生命周期内有效, 不能跨域使用.

2. **性能**: 对于大文件, `createObjectURL()` 比 `FileReader` 更高效, 因为它不需要将整个文件内容加载到内存中.

3. **内存管理**: 确保在不再需要对象 URL 时调用 `URL.revokeObjectURL()` 释放资源.

4. **错误处理**: 如果传入无效的对象类型, 会抛出 `TypeError` 错误.

```js
try {
    const objectURL = URL.createObjectURL(invalidObject);
} catch (error) {
    console.error("创建对象 URL 失败:", error);
    // 创建对象 URL 失败: TypeError: Failed to execute 'createObjectURL' on 'URL': Overload resolution failed.
}
```

<br><br>

# 实际应用示例

## 多文件预览

```html
<input type="file" id="fileInput" multiple accept="image/*" />
<div id="previewContainer"></div>
```

```js
const fileInput = document.getElementById("fileInput");
const previewContainer = document.getElementById("previewContainer");

fileInput.addEventListener("change", function () {
    // 清空之前的预览
    previewContainer.innerHTML = "";

    Array.from(fileInput.files).forEach((file) => {
        if (file.type.startsWith("image/")) {
            const objectURL = URL.createObjectURL(file);

            const img = document.createElement("img");
            img.src = objectURL;
            img.style.maxWidth = "200px";
            img.style.margin = "5px";

            // 图片加载完成后释放 URL
            img.onload = function () {
                URL.revokeObjectURL(objectURL);
            };

            previewContainer.appendChild(img);
        }
    });
});
```

<br>

## 拖拽文件预览

```html
<div id="dropZone" style="border: 2px dashed #ccc; padding: 20px; text-align: center;">拖拽文件到这里</div>
<div id="previewContainer"></div>
```

```js
const dropZone = document.getElementById("dropZone");
const previewContainer = document.getElementById("previewContainer");

dropZone.addEventListener("dragover", function (e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "#f0f0f0";
});

dropZone.addEventListener("dragleave", function (e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "";
});

dropZone.addEventListener("drop", function (e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "";

    const files = Array.from(e.dataTransfer.files);

    files.forEach((file) => {
        if (file.type.startsWith("image/")) {
            const objectURL = URL.createObjectURL(file);

            const img = document.createElement("img");
            img.src = objectURL;
            img.style.maxWidth = "200px";
            img.style.margin = "5px";

            img.onload = function () {
                URL.revokeObjectURL(objectURL);
            };

            previewContainer.appendChild(img);
        }
    });
});
```

通过 `URL.createObjectURL()` 方法, 开发者可以方便地在前端处理和展示用户选择的本地文件, 如图片、视频和音频等, 而无需将文件上传到服务器, 提升了用户体验和应用性能.

<br>
