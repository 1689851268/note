<br>

与大部分现代编程语言（包括几乎所有的脚本语言）一样, JS 中的数字类型是基于 IEEE 754 标准来实现的, 该标准通常也被称为 "浮点数". JS 使用的是 "双精度" 格式（即 64 位二进制）.

<br>

# 整数

JS 没有真正意义上的整数, JS 中的 "整数" 其实就是没有小数的十进制数. 所以 `42.0` 等同于 "整数" `42`.

<br>

**2 进制数**: 以 `0b`、`0B` 开头

```js
console.log(0b1010); // 10
```

-   2 进制数只能出现 `0`、`1` . 如果不符合规范, 则会抛出错误.

```js
const a = 0b12; // 报错
```

<br>

**8 进制数**: 以 `0`、`0o`、`0O` 开头:

```JS
console.log(017); // 15
```

-   8 进制数只能出现 `0` ~ `7` .
-   严格模式下, 不支持 `0` 开头的 8 进制数.

对于以 `0` 开头的 8 进制数: 如果不合法, JS 会当成 10 进制数处理:

```js
console.log(080); // 80
```

对于以 `0O`、`0o` 开头的 8 进制数: 如果不合法, 则会抛出错误:

```js
console.log(0o80); // SyntaxError: Invalid or unexpected token
```

<br>

**16 进制数**: 以 `0x`、`0X` 开头

```JS
console.log(0xff); // 255
```

-   16 进制数可以出现 `0` ~ `9`、`a` ~ `f` . 如果不合法, 则会抛出错误.

```JS
console.log(0x2g); // SyntaxError: Invalid or unexpected token
```

<br><br>

# 浮点数

-   浮点数只能是 10 进制的
-   如果整数部分为 `0`, 可以省略. demo: `.1` → `0.1`
-   在 JS 中, 形如 `1.`、`1.0` 的数值会被当成整数 `1` 处理

<br><br>

# Infinity

由于内存的限制, JS 能表示的数值范围: 最小数值保存在 `Number.MIN_VALUE` 中, 这个值在多数浏览器中是 `5e-324`, 它不是负数, 但无限接近于 0 ！最大数值保存在 `Number.MAX_VALUE` 中, 这个值在多数浏览器中是 `1.7976931348623157e+308`.

如果数值超出了 JS 可以表示的范围, 就会被自动转换为一个特殊的值: `Infinity` / `-Infinity`. 计算结果一旦溢出为无穷数（infinity）就无法再得到有穷数. 换句话说, 就是你可以从有穷走向无穷, 但无法从无穷回到有穷.

在 JS 中, 如果分子为 `非 0 值`, 分母为 `+0` / `-0` / `0`, 则会返回 `± Infinity`.

```js
console.log(1 / 0); // Infinity
```

如果计算返回 `Infinity` 或 `-Infinity`, 则该值将不能再进一步用于任何计算. 这是因为 Infinity 没有可用于计算的数值表示形式.

> 使用 `Number.NEGATIVE_INFINITY` 和 `Number.POSITIVE_INFINITY` 也可以获取正、负 Infinity.

<br><br>

# NaN

`NaN` → (not a number) 无法用数字表示的结果.

在 JS 中, `0`、`+0`、`-0` 相除会返回 `NaN`.

```js
console.log(0 / 0); // NaN
```

<br>

NaN 有几个特性. 首先, 任何涉及 NaN 的操作都会返回 NaN（如 `NaN / 10`）, 在连续多步计算时这可能是个问题. 其次, NaN 不等于包括 NaN 在内的任何值.

```js
console.log(NaN == NaN); // false
```

<br><br>

# 科学记数法

对于非常大或非常小的数值, 可以用科学记数法来表示.

ECMAScript 中, 科学记数法的格式要求是一个数值（整数/浮点数）后跟一个大写或小写的字母 `e`, 再加上一个要乘的 10 的多少次幂:

```js
2.5e3 / 2.5E3  →  2.5 * 10**3  →  2500
```

`0.00000000000000003` 用科学记数法可以表示为 `3e-17`. 默认情况下, ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法. demo: `0.0000003` → `3e-7`

<br><br>

# 安全整数

数字的呈现方式决定了 "整数" 的安全值范围远小于 `Number.MAX_VALUE`. 能够被 "安全" 呈现的最大整数是 `2^53-1`, 即 `9007199254740991`, 在 ES6 中被定义为 `Number.MAX_SAFE_INTEGER`. 最小整数是 `-9007199254740991`, 在 ES6 中被定义为 `Number.MIN_SAFE_INTEGER`.

有时 JS 程序需要处理一些比较大的数字, 如数据库中的 64 位 ID 等. 由于 JS 的数字类型无法精确呈现 64 位数值, 所以必须将它们保存（转换）为字符串.

<br><br>

# 32 位有符号整数

虽然整数最大能够达到 53 位, 但是有些数字操作（如数位操作）只适用于 32 位数字, 所以这些操作中数字的安全范围就要小很多, 变成 `Math.pow(-2, 31)` ~ `Math.pow(2, 31) - 1`（`-2147483648` ~ `2147483647`）.

`a | 0` 可以将变量 `a` 中的数值转换为 32 位有符号整数, 因为数位运算符 `|` 只适用于 32 位整数（它只关心 32 位以内的值, 其他的数位将被忽略）. 因此与 0 进行 OR 操作本质上没有意义.

某些特殊的值并不是 32 位安全范围的, 如 `NaN` 和 `Infinity`, 此时会对它们执行虚拟操作（abstract operation）ToInt32, 以便转换为符合数位运算符要求的 `+0` 值.

<br><br>

# 零值

JS 有一个常规的 `0`（也叫作 `+0`）和一个 `-0`

`-0` 除了可以用作常量以外, 也可以是某些数学运算的返回值:

```js
const a = 0 / -3; // -0
const b = 0 * -3; // -0
```

> 加法和减法运算不会得到负零（negative zero）.

<br>

根据规范, 对负零进行字符串化会返回 `"0"`:

```js
var a = 0 / -3;
a; // -0

// 但是规范定义的返回结果是这样！
a.toString(); // "0"
a + ""; // "0"
String(a); // "0"

// JSON 也如此, 很奇怪
JSON.stringify(a); // "0"
```

有意思的是, 如果反过来将其从字符串转换为数字, 得到的结果是准确的:

```js
+"-0"; // -0
Number("-0"); // -0
JSON.parse("-0"); // -0
```

负零转换为字符串的结果令人费解, 它的比较操作也是如此:

```js
+0 === -0; // true
```

<br>

我们为什么需要负零呢？

有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度）, 数字的符号位（sign）用来代表其他信息（比如移动的方向）. 此时如果一个值为 0 的变量失去了它的符号位, 它的方向信息就会丢失. 所以保留 0 值的符号位可以防止这类情况发生.

<br><br>

# 机器精度

`0.1`+`0.2` 不等于 `0.3`

<br>

**为什么 `0.1 + 0.2` 不等于 `0.3`？**

因为 JS 代码会被转成机器码执行, 数值以二进制形式存储, 0.1 和 0.2 在二进制中是无限循环小数. 又因为 JS 中的 Number 类型遵循 IEEE 754 标准, 以双精度浮点数形式存储, 每个数值占用 64 位.

所以, 0.1 + 0.2 不等于 0.3 的原因如下:

-   0.1 和 0.2 在存储时有精度损失

-   二进制的 0.1 加上二进制的 0.2 会产生溢出, 再次导致精度丢失

最终的二进制结果转换回十进制后, 不等于 0.3

<br>

**怎么解决这个问题呢？**

1. 转换为整数运算: 将小数转换为整数进行运算, 然后再转换回小数.

```js
let result = (0.1 * 10 + 0.2 * 10) / 10;
console.log(result); // 输出: 0.3
```

2. 使用 toFixed 方法: 将结果四舍五入到指定的小数位数.

```js
let sum = 0.1 + 0.2;
console.log(sum.toFixed(2)); // 输出: 0.30
```

3. 使用高精度数学库: 如 decimal.js, 处理任意精度的十进制运算.

```js
const Decimal = require("decimal.js");
let a = new Decimal(0.1);
let b = new Decimal(0.2);
let sum = a.plus(b);
console.log(sum.toString()); // 输出: 0.3
```

<br>

**怎样判断 0.1 + 0.2 和 0.3 是否相等呢？**

可以引入一个很小的误差值 `Number.EPSILON`（约为 2^-52）, 来判断两个数是否足够接近.

```js
function equal(a, b) {
    return Math.abs(a - b) < Number.EPSILON;
}
```

<br>
