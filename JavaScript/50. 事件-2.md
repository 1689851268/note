# 事件类型

## 鼠标事件

### 点击事件

| 事件          | 触发时机                      | 说明                                  |
| ------------- | ----------------------------- | ------------------------------------- |
| `click`       | 点击左键 / 聚焦元素上按回车键 | 等同于 `mousedown` + `mouseup`        |
| `dblclick`    | 左键双击                      | 双击 = 2 次 `click` + 1 次 `dblclick` |
| `contextmenu` | 点击右键                      | 通常用于自定义右键菜单                |
| `mousedown`   | 按下鼠标任意键                | 可通过 `event.button` 区分按键        |
| `mouseup`     | 抬起鼠标任意键                | -                                     |

```js
// 区分鼠标按键
element.addEventListener("mousedown", (e) => {
    console.log(e.button); // 0: 左键, 1: 中键, 2: 右键
});
```

<br>

### 移动事件

| 事件         | 触发时机         | 冒泡          |
| ------------ | ---------------- | ------------- |
| `mouseenter` | 鼠标进入元素     | ❌            |
| `mouseleave` | 鼠标离开元素     | ❌            |
| `mouseover`  | 鼠标进入元素     | ✅            |
| `mouseout`   | 鼠标离开元素     | ✅            |
| `mousemove`  | 鼠标在元素上移动 | ✅ (持续触发) |

**`mouseenter` vs `mouseover`:**

-   `mouseenter/mouseleave` 不冒泡, 移到子元素上不会再次触发
-   `mouseover/mouseout` 会冒泡, 移到子元素上会再次触发

```js
// 推荐在需要处理子元素时使用 mouseenter / mouseleave
nav.addEventListener("mouseenter", () => {
    // 鼠标进入导航栏, 不会被子元素干扰
});
```

<br>

### 滚轮事件

**标准事件:** `wheel`

```js
element.addEventListener("wheel", (event) => {
    console.log(event.deltaY); // 正数: 向下滚, 负数: 向上滚
    console.log(event.deltaX); // 横向滚动
    console.log(event.deltaMode); // 0: 像素, 1: 行, 2: 页
});
```

**已废弃的属性 (仅供参考):**

-   `event.wheelDelta` (Chrome/IE): `120` 向上, `-120` 向下
-   `event.detail` (Firefox): `-3` 向上, `3` 向下
-   Firefox 旧版本使用 `DOMMouseScroll` 事件

**现代代码应使用 `wheel` 事件和 `deltaY` 属性.**

<br>

## 键盘事件

| 事件       | 触发时机            | 是否重复触发 | 字符键 | 功能键 |
| ---------- | ------------------- | ------------ | ------ | ------ |
| `keydown`  | 按下任意键          | ✅ (长按)    | ✅     | ✅     |
| `keyup`    | 释放任意键          | ❌           | ✅     | ✅     |
| `keypress` | 按下字符键 (已废弃) | ✅           | ✅     | ❌     |

<br>

### 键盘属性

**推荐使用 (现代):**

```js
element.addEventListener("keydown", (e) => {
    console.log(e.key); // 按键名称: "Enter", "a", "ArrowUp", "Shift"
    console.log(e.code); // 物理按键: "Enter", "KeyA", "ArrowUp", "ShiftLeft"

    // 修饰键状态
    console.log(e.ctrlKey); // 是否按下 Ctrl
    console.log(e.shiftKey); // 是否按下 Shift
    console.log(e.altKey); // 是否按下 Alt
    console.log(e.metaKey); // 是否按下 Meta (Windows 键 / Command 键)
});
```

**已废弃 (仅供理解旧代码):**

-   `e.keyCode`: 数字编码, 如 `13` (Enter),`37` (ArrowLeft),`16` (Shift)

<br>

### 实战案例

**案例 1: Ctrl + Enter 提交留言**

```js
const input = document.getElementById("messageInput");
const list = document.getElementById("messageList");

input.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && e.ctrlKey) {
        const content = input.value.trim();
        if (!content) return;

        const li = document.createElement("li");
        li.textContent = content;
        list.prepend(li);

        input.value = "";
    }
});
```

<br>

**案例 2: 方向键移动元素**

```js
const box = document.getElementById("box");
const step = 10;

document.addEventListener("keydown", (e) => {
    const current = {
        left: box.offsetLeft,
        top: box.offsetTop,
    };

    switch (e.key) {
        case "ArrowLeft":
            box.style.left = current.left - step + "px";
            break;
        case "ArrowUp":
            box.style.top = current.top - step + "px";
            break;
        case "ArrowRight":
            box.style.left = current.left + step + "px";
            break;
        case "ArrowDown":
            box.style.top = current.top + step + "px";
            break;
    }
});
```

<br>

## 焦点事件

| 事件       | 触发时机     | 冒泡 |
| ---------- | ------------ | ---- |
| `focus`    | 元素获得焦点 | ❌   |
| `blur`     | 元素失去焦点 | ❌   |
| `focusin`  | 元素获得焦点 | ✅   |
| `focusout` | 元素失去焦点 | ✅   |

```js
// 场景: 表单验证
input.addEventListener("blur", (e) => {
    if (!e.target.value) {
        showError("此字段不能为空");
    }
});

// 场景: 事件委托 (需要冒泡)
form.addEventListener("focusin", (e) => {
    e.target.parentElement.classList.add("focused");
});
```

<br>

## 表单事件

| 事件     | 触发时机         | 适用元素                            |
| -------- | ---------------- | ----------------------------------- |
| `input`  | 值改变时 (实时)  | `<input>`, `<textarea>`, `<select>` |
| `change` | 值改变且失去焦点 | 同上                                |
| `submit` | 表单提交         | `<form>`                            |
| `reset`  | 表单重置         | `<form>`                            |
| `select` | 文本被选中       | `<input>`, `<textarea>`             |

```js
// input: 实时搜索
searchInput.addEventListener("input", (e) => {
    search(e.target.value);
});

// change: 下拉框选择
select.addEventListener("change", (e) => {
    console.log("选中的值:", e.target.value);
});

// submit: 表单验证
form.addEventListener("submit", (e) => {
    e.preventDefault(); // 阻止默认提交行为
    // 自定义提交逻辑
});
```

<br>

## 文档/窗口事件

| 事件               | 触发时机          | 目标                             |
| ------------------ | ----------------- | -------------------------------- |
| `DOMContentLoaded` | HTML 解析完成     | `document`                       |
| `load`             | 资源完全加载      | `window`, `<img>`, `<iframe>` 等 |
| `beforeunload`     | 页面即将卸载      | `window`                         |
| `unload`           | 页面已卸载        | `window`                         |
| `resize`           | 窗口/元素尺寸改变 | `window`, 元素                   |
| `scroll`           | 滚动发生          | `window`, 元素                   |

```js
// DOMContentLoaded: HTML 解析完成 (不等待图片/样式)
document.addEventListener("DOMContentLoaded", () => {
    console.log("HTML 解析完成");
});

// load: 资源完全加载
window.addEventListener("load", () => {
    console.log("资源完全加载");
});

// beforeunload: 页面即将卸载
window.addEventListener("beforeunload", (e) => {
    console.log("页面即将卸载");
});
```

<br>

当用户关闭/刷新/跳转页面时, 可以弹出确认框提示:

```js
window.addEventListener("beforeunload", (e) => {
    if (hasUnsavedChanges) {
        e.preventDefault(); // 触发确认框
    }
});
```

**注意事项:**

-   对话框内容由浏览器控制, 不能自定义
-   只能弹出确认框, 无法强制阻止用户离开
-   需要用户有过页面交互 (点击/输入) 才会触发

<br><br>

# 事件对象

当事件触发时, 浏览器会自动创建一个 **事件对象 (Event Object)** 并传递给事件处理函数, 该对象包含了本次事件的详细信息.

```js
element.addEventListener("click", (event) => {
    console.log(event); // MouseEvent { type: "click", target: ..., ... }
});
```

<br>

## 核心属性

### 事件基本信息

| 属性            | 说明                          | 示例                          |
| --------------- | ----------------------------- | ----------------------------- |
| `type`          | 事件类型                      | `"click"`, `"keydown"`        |
| `target`        | 触发事件的元素 (事件源)       | 被点击的具体元素              |
| `currentTarget` | 绑定监听器的元素 (=== `this`) | 监听器所在的元素              |
| `eventPhase`    | 当前事件流阶段                | `1`: 捕获,`2`: 目标,`3`: 冒泡 |
| `isTrusted`     | 是否为用户操作触发            | `true` / `false`              |
| `timeStamp`     | 事件发生的时间戳 (ms)         | `12345.67`                    |

**`target` vs `currentTarget`:**

```html
<div id="parent">
    <button id="child">点击</button>
</div>

<script>
    parent.addEventListener("click", (e) => {
        console.log(e.target); // <button> (实际点击的元素)
        console.log(e.currentTarget); // <div> (监听器所在的元素)
        console.log(e.currentTarget === parent); // true
    });
</script>
```

<br>

### 鼠标位置信息

| 属性                 | 参照物                     | 说明               |
| -------------------- | -------------------------- | ------------------ |
| `offsetX`, `offsetY` | 触发事件的元素左上角       | 相对于事件源的坐标 |
| `clientX`, `clientY` | 浏览器可视区域左上角       | 不受页面滚动影响   |
| `pageX`, `pageY`     | 文档左上角                 | 包含滚动距离       |
| `screenX`, `screenY` | 屏幕左上角                 | 多屏时会跨越屏幕   |
| `x`,`y`              | `clientX`,`clientY` 的别名 | -                  |

```js
document.addEventListener("click", (e) => {
    console.log(`可视区域坐标: (${e.clientX}, ${e.clientY})`);
    console.log(`页面坐标: (${e.pageX}, ${e.pageY})`);
    console.log(`屏幕坐标: (${e.screenX}, ${e.screenY})`);
});
```

<br>

### 修饰键状态

| 属性       | 对应按键                                  |
| ---------- | ----------------------------------------- |
| `ctrlKey`  | Ctrl 键                                   |
| `shiftKey` | Shift 键                                  |
| `altKey`   | Alt 键                                    |
| `metaKey`  | Meta 键 (Windows 徽标键 / Mac Command 键) |

```js
element.addEventListener("click", (e) => {
    if (e.ctrlKey) {
        console.log("Ctrl + 点击");
    }
});
```

<br>

### 鼠标按键信息

| 属性      | 说明                                       |
| --------- | ------------------------------------------ |
| `button`  | 按下的鼠标按键: `0` 左键,`1` 中键,`2` 右键 |
| `buttons` | 当前按下的所有按键 (位掩码)                |

<br>

## 核心方法

### preventDefault

阻止浏览器的默认行为.

**常见默认行为:**

-   `<a>` 的 `click`: 跳转链接
-   `<form>` 的 `submit`: 提交表单并刷新页面
-   `document` 的 `contextmenu`: 显示上下文菜单

```js
// 阻止链接跳转
link.addEventListener("click", (e) => {
    e.preventDefault();
    console.log("链接被点击, 但不跳转");
});

// 阻止表单提交
form.addEventListener("submit", (e) => {
    e.preventDefault();
    // 进行自定义验证和 AJAX 提交
});

// 自定义右键菜单
document.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    showCustomMenu(e.clientX, e.clientY);
});
```

<br>

### stopPropagation

阻止事件在 DOM 树中继续传播 (不影响同一元素上的其他监听器).

```js
parent.addEventListener("click", () => console.log("父级捕获"), true);
child.addEventListener("click", (e) => {
    console.log("子级-1");
    e.stopPropagation(); // ⛔ 阻止事件继续传播
});
child.addEventListener("click", () => {
    console.log("子级-2"); // ✅ 同元素的其他监听器仍会执行
});
parent.addEventListener("click", () => console.log("父级冒泡")); // ❌ 不会执行

// 点击 child, 输出: 父级捕获 → 子级-1 → 子级-2
```

<br>

### stopImmediatePropagation

立即阻止事件传播, **同时阻止当前元素上的其他监听器**.

```js
child.addEventListener("click", (e) => {
    console.log("监听器 1");
    e.stopImmediatePropagation(); // 🛑 立即阻止所有后续操作
});

child.addEventListener("click", () => {
    console.log("监听器 2"); // ❌ 不会执行
});

parent.addEventListener("click", () => {
    console.log("父级冒泡"); // ❌ 不会执行
});

// 点击 element, 仅输出: 监听器 1
```

**功能对比表:**

| 方法                         | 阻止事件传播 | 阻止同元素其他监听器 | 使用场景                    |
| ---------------------------- | ------------ | -------------------- | --------------------------- |
| `stopPropagation()`          | ✅           | ❌                   | 阻止冒泡/捕获, 但不影响同级 |
| `stopImmediatePropagation()` | ✅           | ✅                   | 完全阻止事件的后续处理      |

<br><br>
