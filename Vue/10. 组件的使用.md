# 模块 & 组件

1. 模块：向外提供特定功能的 JS 程序，一般就是一个 JS 文件
2. 组件：用来实现局部功能效果的代码集合 ( HTML / CSS / JS / images... )，一般就是一个 Vue 文件

<br><br>

# 组件的使用

一个 .vue 文件就是一个组件：

```html
<template>
    <div>
        <h1>This is an about page</h1>
    </div>
</template>

<script>
    export default {
        name: 'About', // 设置组件名称; 可用于在开发者工具中标识该组件 & 可用于设置路由缓存
    };
</script>
```

> #### 注册组件：局部注册 & 全局注册

-   局部注册：① 在 .vue 文件中引入该组件、 ② 在 `components` 配置项中注册该组件
-   局部注册的组件只能在当前注册的组件内使用

```html
<template>
    <div>
        <Son />
    </div>
</template>

<script>
    import Son from '@/pages/Home/Son'; // 引入组件

    export default {
        name: 'Home',
        components: { Son }, // 注册组件 - components: { 自定义组件名称: 组件实例 }
    };
</script>
```

-   全局注册：① 在项目的入口文件中引入该组件、 ② 使用 `Vue.component()` 注册该组件
-   全局注册的组件可以在任意组件内使用

```js
import Vue from 'vue';
import App from './App.vue';

Vue.config.productionTip = false;

import Son from '@/pages/Home/Son'; // 引入组件
Vue.component(Son.name, Son); // 注册组件 - Vue.component(自定义组件名称, 组件实例)

new Vue({ render: h => h(App) }).$mount('#app');
```

<br>

## 组件名称

1. kebab-case 命名法 ( 短横线命名法 ) ：必须严格按照短横线名称使用组件
2. PascalCase 命名法 ( 大驼峰命名法 ) ：既可以按照大驼峰名称使用组件，也可以按照短横线名称使用组件

<br>

## 组件的封装

为了提高组件的复用性，在封装组件时需遵守如下原则：
① 组件的 DOM 结构、Style 样式要尽量复用
② 组件中要展示的数据，尽量由组件的使用者提供

<br>

## 关于 VueComponent

1. 组件本质是一个名为 VueComponent 的**构造函数**，且不是程序员定义的，是 `Vue.extend(option)` 生成的
2. 使用组件时，我们只需写 `<组件名></组件名>`，Vue 解析时就会帮我们创建组件实例
   即：Vue 帮我们执行的 `new VueComponent(option)` 即 `Vue.extend(option)`
3. 特别注意：每次调用 `Vue.extend(option)` 都会返回一个全新的 VueComponent ！！！
4. 关于 `this` 指向：
    1. `Vue.extend(options)` 配置中：`methods` 中的函数、`watch` 中的函数、`computed` 中的函数
       它们的 `this` 均是 [ VueComponent 实例对象 ]
    2. `new Vue(options)` 配置中：`methods` 中的函数、`watch` 中的函数、`computed` 中的函数
       它们的 `this` 均是 [ Vue 实例对象 ]
5. VueComponent 的实例对象 (vc)，就是组件实例对象
   Vue 的实例对象 (vm)，管理着组件实例对象 vc

> #### `VueComponent.prototype.__proto__ == Vue.prototype`

```js
// 定义组件 school，返回 VueComponent 构造函数
const school = Vue.extend({
    template: `<p> school </p>`,
});

console.log('验证一下: ', school.prototype.__proto__ === Vue.prototype); // 验证一下: true
```

<img src="picture/10.%20%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220328143641573.png" alt="image-20220328143641573" style="zoom:30%;" />

-   #### 所以，组件实例对象 (vc) 可以访问到 Vue 原型上的属性、方法

```html
<div id="app">
    <school></school>
</div>
```

```js
Vue.prototype.num = 10;

const school = Vue.extend({
    template: `<button @click="showNum"> 点击获取 num </button>`,
    methods: {
        showNum() {
            console.log(this.num);
        },
    },
});

const vm = new Vue({
    el: '#app',
    components: { school },
});
```

<br><br>

# $nextTick

-   `this.$nextTick(callback)`：下一次 DOM 更新结束后，执行回调函数 `callback`
-   Vue 在执行函数时，会将函数执行完 再更新 DOM。有时我们需要更新完数据后，立即操作更新后的 DOM，就需要使用 $nextTick

```html
<template>
    <div>
        <button
            ref="btn"
            @click="changeAndShow"
        >
            {{ name }}
        </button>
    </div>
</template>

<script>
    export default {
        name: 'App',
        data() {
            return { name: 'superman' };
        },
        methods: {
            changeAndShow() {
                this.name = 'super'; // 修改数据，DOM 会被重新渲染

                // 直接获取，只能获取到旧的 innerHTML
                console.log('innerHTML', this.$refs.btn.innerHTML); // innerHTML superman

                // 通过 $nextTick 获取，才能获取到新的 innerHTML
                this.$nextTick(() => {
                    console.log('nextTick', this.$refs.btn.innerHTML); // nt innerHTML super
                });
            },
        },
    };
</script>
```

> #### demo 2

-   全局属性 contenteditable 用于设置元素是否可被用户编辑；`true`-可编辑、`false`-不可编辑。

```html
<template>
    <div>
        <button @click="inFocus">点击聚焦</button>
        <input
            type="text"
            ref="input"
        />
        <hr />
        <button @click="spFocus">点击聚焦</button>
        <span
            :contenteditable="bol"
            ref="span"
        ></span>
    </div>
</template>

<script>
    export default {
        name: 'App',
        data() {
            return { bol: false };
        },
        methods: {
            inFocus() {
                this.$refs.input.focus();
            },
            spFocus() {
                this.bol = true;

                // 错误示范：直接调用 focus()
                // this.$refs.span.focus();
                // 在第一次点击 span 对应的聚焦时，不会有聚焦效果。因为虚拟 DOM 尚未渲染到页面上

                // 方法1：使用定时器
                // setTimeout(() => { // 要用 [箭头函数]，否则 this 指向 Window
                //     this.$refs.span.focus();
                // }, 200);

                // 方法2：使用 nextTick
                this.$nextTick(() => {
                    // 不论用 [箭头函数] 还是 [普通函数]，this 都指向当前 Vue 实例
                    console.log(this);
                    this.$refs.span.focus();
                });
            },
        },
    };
</script>

<style>
    * {
        margin: 2px;
    }
</style>
```

> #### demo3

情景假设：页面一开始需要发送 Ajax 获取数据，等数据请求被成功响应、且 HTML 结构渲染完成之后，创建 Swiper 实例
（Swiper 是制作轮播图的插件）

```js
watch: {
    // 监听 bannerList 的数据变化，数据发生变化，就说明请求被成功响应了
    bannerList: {
        handler() {
            // HTML 渲染完成之后
            this.$nextTick(() => {
                // 创建 swiper 实例
                new Swiper(".swiper-container", {
                    loop: true,
                    pagination: {
                        el: ".swiper-pagination",
                        clickable: true,
                    },
                    navigation: {
                        nextEl: ".swiper-button-next",
                        prevEl: ".swiper-button-prev",
                    },
                });
            });
        },
    },
},
```

-   **在 Vue 中，可以通过 watch + $nextTick 保证请求被成功响应、且 HTML 结构渲染完成之后，再创建 Swiper 实例**
