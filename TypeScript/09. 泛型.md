# 配合函数使用

配置普通函数：

```ts
function fun<T>(val: T): T {
    return val;
}

fun(1); // 不指定泛型, TS 能自动推导; 这里 val 的类型为字面量类型 1
fun<string>("superman"); // 指定泛型
```

配置箭头函数：

```ts
const createArray = <T>(length: number, value: T): T[] => {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
};

createArray(3, "x"); // ['x', 'x', 'x']
```

配合函数表达式：

```ts
const createArray = function <T>(length: number, value: T): Array<T> {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
};
```

<br>

泛型可以同时指定多个：

```ts
function fun<T, K>(val1: T, val2: K): T {
    console.log("val1", val1);
    console.log("val2", val2);
    return val1;
}

fun<string, number>("superman", 21);
```

注意~ 使用泛型时，需要注意兼容性：

```ts
function fun<T>(arg: T): T {
    console.log(arg.length); // 直接飘红, 因为 T 这个类型不一定有 length 属性
    return arg;
}
```

我们可以使用特定的写法，以保证传进来的类型一定有 `length` 属性，比如：

```ts
function fun<T>(arg: T[]): T[] {
    console.log(arg.length);
    return arg;
}
```

<br><br>

# 配合 class 使用

```ts
class Person<T> {
    constructor(public name: T) {}
}

const per1 = new Person("superman"); // 不指定泛型, TS 会自动识别
const per2 = new Person<string>("superwoman"); // 指定泛型
```

注意：[静态属性] & [静态方法] 不能使用泛型

<br><br>

# 配合 interface 使用

```ts
interface Person<T> {
    feature: T;
}

const person1: Person<string> = { feature: "handsome" };
const person2: Person<string[]> = { feature: ["handsome", "responsible"] };
```

<br><br>

# 配合 type 使用

```ts
type Person<T> = { feature: T };
type OrNull<T> = T | null;
type OneOrMany<T> = T | T[];
type OneOrManyOrNull<T> = OrNull<OneOrMany<T>>; // 使用泛型 type 创建新的 type

const person: Person<string> = { feature: "handsome" };
const orNull: OrNull<string> = "value";
const oneOrMany: OneOrMany<string> = ["value1", "value2"];
const oneOrManyOrNull: OneOrManyOrNull<string> = null;
```

<br><br>

# 泛型 & 签名 & 接口

[泛型签名] ：

```ts
function show<T>(arg: T): T {
    return arg;
}
const myShow: <T>(arg: T) => T = show;
const myShow: { <T>(arg: T): T } = show;
```

[接口] & [泛型签名] ：

```ts
interface ShowType {
    <T>(arg: T): T;
}
const myShow: ShowType = (arg) => arg;

console.log(myShow(1000)); // T → 1000
console.log(myShow("superman")); // T → superman
```

[泛型接口] & [签名] ：

```ts
interface ShowType<T> {
    (arg: T): T;
}
const myShowStr: ShowType<string> = show;
// 这种写法更为严谨, 需要使用者自己传入泛型值

console.log(myShowStr("superman"));
// console.log(myShowStr(1000)); // 直接飘红
```

<br><br>

# 泛型中的 extends

extends & interface ：

```ts
interface Inter {
    length: number;
}

// T extends Inter 表示泛型 T 必须是 Inter 的实现类
function fun<T extends Inter>(val: T): T {
    console.log(val.length);
    return val;
}

// 参数必须是含有 length 属性的对象
fun({ length: 10 }); // T → { length: number }
fun([1, 2, 3, 4, 5]); // T → number[]
fun("superman"); // T → "superman"
fun<string>("superman"); // T → string
```

extends & 联合类型：

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    // `keyof` 能获取该 [对象类型] 的所有属性, 组成一个联合类型
    return obj[key];
}

const person = { name: "superman", age: 21 };
console.log(getProperty(person, "name")); // superman
```

extends & class ：

```ts
class BeeKeeper {
    mask = true;
}

class Animal {
    public legsNum = 4;
}

class Bee extends Animal {
    keeper = new BeeKeeper();
}

// 使用工厂函数
// 约束 [函数参数] 的类型为 "构造函数"
// 约束 [类] 必须继承自 Animal
function createAnimal<T extends Animal>(ctor: new () => T): T {
    return new ctor();
}

console.log(createAnimal(Bee)); // Bee { legsNum: 4, keeper: BeeKeeper { mask: true } }
// console.log(createAnimal(BeeKeeper)); // 直接飘红
```

<br>
