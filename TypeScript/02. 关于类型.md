# TS 中的类型

① boolean、 ② number、 ③ string、 ④ enum、 ⑤ array、⑥ tuple、 ⑦ any、 ⑧ unknown、 ⑨ void、 ⑩ never

**关于 "空值"**：

默认情况下，`undefined` 和 `null` 可以赋值给任意类型的值。当 tsconfig.json 的 `"compilerOptions"` 设置了 `"strictNullChecks": true` 时，必须严格对待，`undefined` 和 `null` 将只能赋值给它们自身和 `void` 类

TS 对可选属性和对可选参数的处理一样，会被自动加上 `XXX | undefined`

<br>

## enum

```ts
enum Gender {
    female,
    male,
}
console.log(Gender.male); // 1
console.log(Gender[1]); // male
```

此时，数据库中存储的是数值 0 1，但使用时 需通过 `Gender.male` 的方式使用，既节省了存储空间，又使代码语义化

可以给枚举类型设置默认值：

```ts
enum Gender {
    female = 1,
    male,
}
console.log(Gender.male); // 2
console.log(Gender[1]); // female
```

<br>

## array

`array` 类型有两种写法：① `XXX[]` (字面量写法)、 ② `Array<XXX>` (构造函数的泛型写法)

```ts
let array1: number[]; // 元素为 number 类型
let array2: Array<string>; // 元素为 string 类型
```

<br>

## tuple

`tuple` 类型的写法：`[XXX, XXX]` (其实就是固定长度的数组)

```ts
let tuple1: [string, number]; // 表示第 1 元素为 string 类型、 第 2 元素为 number 类型的数组
```

<br>

## any

-   `any` 表示任意类型
-   `any` 类型的变量可以赋值给任意其他类型的变量，任意其他类型的变量也可以赋值给 `any` 类型的变量
-   在 `any` 类型的变量上访问任何属性都是合法的

<br>

## unknown

-   `unknown` 表示未知的类型
-   `unknown` 类型的变量可以被赋值为任意值
-   在对 `unknown` 类型的变量做任意操作之前，都需要确认 `unknown` 变量的准确类型

```typescript
let unknownVal: unknown = "superman"; // 将字符串赋值给 unknown 类型的变量
let numberVal: number = 0;

if (typeof unknownVal === "number") {
    // 将 unknown 类型的变量赋值给其他变量;  需要先判断该 unknown 类型的变量是否为 number;  如果不判断, 会直接飘红
    numberVal = unknownVal;
}
```

这里可以使用 [**类型断言**]，表示你确定当前变量一定会是指定类型
语法：写法 1 - `变量 as 类型`、 写法 2 - `<类型>变量`

```typescript
let unknownVal: unknown = 100;
let numberVal: number = 0;
numberVal = unknownVal as number; // 此时, 你得确保当前变量 unknownVal 一定会是 number 类型
numberVal = <number>unknownVal; // 因为, 使用类型断言后 TS 不
再判断, 会直接将 unknownVal 赋值给 numberVal
```

<br>

## void

-   `void` 表示没有类型
-   `void` 类型的变量只能被赋值为 `undefined` / `null`
-   一般使用 `void` 表示函数的返回值类型，表示当前函数没有返回值（但其实 `void` 修饰的函数还可以返回 `undefined` / `null`）

```ts
function fun1(): void {} // 没有返回值

function fun2(): void {
    return; // 隐式返回 `undefined`
}

function fun3(): void {
    return undefined; // 显式返回 `undefined`
}

function fun4(): void {
    return null; // 返回 null
}
```

<br>

## never

-   `never` 表示不存在的类型
-   任何类型都不可以分配给 `never`，除了 `never` 本身
-   一般使用 `never` 修饰会抛出错误的函数

```ts
function fun(): never {
    throw new Error("error");
}
```

<br><br>

# 联合类型

```ts
let gender: "male" | "famale"; // 约束 gender 只能为 "male" 或 "famale"
let account: (string | number)[]; // 约束 account 为数组, 数组元素的类型只能为 string / number
```

**注意 ①**：使用联合类型时，需要注意接收的数据具体是什么类型的，才能执行具体的操作

```ts
function showName(name: string | number) {
    if (typeof name === "number") console.log(name);
    else console.log(name.toLocaleUpperCase());
}
showName("superman");
```

**注意 ②**："大" 类型的变量不能直接赋值给 "小" 类型的变量

```ts
let identity = "user"; // 此时 identity 的类型被约束为 string
function showIdentity(id: "user" | "root" | "superRoot"): void {
    console.log("id", id);
}

// showIdentity(identity);
// 直接飘红，因为类型 `string` 比 `"user" | "root" | "superRoot"` "大"
// 需要约束其类型比 `"user" | "root" | "superRoot"` "小"，才能正常使用
```

此时可以使用 **[类型断言]**

```ts
let identity = "user";
function showIdentity(id: "user" | "root" | "superRoot"): void {
    console.log("id", id);
}

showIdentity(<"user" | "root">identity); // 表示你确保 identity 只会是 "user" / "root"
showIdentity(identity as "user" | "root");
```

此外，还能在定义变量时使用 **`as const`** 约束变量类型为当前 **[字面量]**

```ts
let identity = "user" as const; // 此时 identity 的类型被约束为 "user"
function showName(id: "user" | "root" | "superRoot"): void {
    console.log("id", id);
}

showName(identity); // 可以直接使用，因为类型 `"user"` 比 `"user" | "root" | "superRoot"` "小"
```

**注意 ③**：与 [联合类型 `|`] 相对的，还有 [交叉类型 `&`]

```ts
let obj1: { name: string; age: number }; // 与 obj2 等效
let obj2: { name: string } & { age: number }; // 与 obj1 等效
```

<br><br>

# 类型的别名

如果类型很长，可以给类型起别名：`type XX = XXX`

**对于 [联合类型]**：

```ts
const num1: 1 | 2 | 3 | 4 | 5 = 1;
const num2: 1 | 2 | 3 | 4 | 5 = 2;
```

```ts
type MyType = 1 | 2 | 3 | 4 | 5;
const num1: MyType = 1;
const num2: MyType = 2;
```

**对于 [对象] 类型**：

```ts
const obj1: { name: string; age: number } = { name: "superman", age: 21 };
const obj2: { name: string; age: number } = { name: "monster", age: 20 };
```

```ts
type ObjType = { name: string; age: number };
const obj1: ObjType = { name: "superman", age: 21 };
const obj2: ObjType = { name: "monster", age: 20 };
```

**对于 [函数] 类型**：

```ts
const sum: (num1: number, num2: number) => number = (num1, num2) => num1 + num2;
const sub: (num1: number, num2: number) => number = (num1, num2) => num1 - num2;
```

```ts
type FunType = (num1: number, num2: number) => number;
const sum: FunType = (num1, num2) => num1 + num2;
const sub: FunType = (num1, num2) => num1 - num2;
```

<br>