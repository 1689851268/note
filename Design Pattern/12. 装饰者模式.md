<br>

装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。

<br><br>

# 模拟传统面向对象语言的装饰者模式

给 JS 中象语言中的装饰者模式在 JS 中适用的场景并不多，如上面代码所示，通常我们并不太介意改动对象自身。尽管如此，本节我们还是稍微模拟一下传统面向对象语言中的装饰者模式。

假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。

下面来看代码实现，首先是原始的飞机类：

```js
var Plane = function () {};

Plane.prototype.fire = function () {
    console.log("发射普通子弹");
};
```

接下来增加两个装饰类，分别是导弹和原子弹：

```js
var MissileDecorator = function (plane) {
    this.plane = plane;
};
MissileDecorator.prototype.fire = function () {
    this.plane.fire();
    console.log("发射导弹");
};

var AtomDecorator = function (plane) {
    this.plane = plane;
};
AtomDecorator.prototype.fire = function () {
    this.plane.fire();
    console.log("发射原子弹");
};
```

导弹类和原子弹类的构造函数都接受参数 plane 对象，并且保存好这个参数，在它们的 fire 方法中，除了执行自身的操作之外，还调用 plane 对象的 fire 方法。

这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（fire 方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。

因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。

最后看看测试结果：

```js
var plane = new Plane();
plane = new MissileDecorator(plane);
plane = new AtomDecorator(plane);

plane.fire(); // 分别输出：发射普通子弹、发射导弹、发射原子弹
```

从功能上而言，decorator 能很好地描述这个模式，但从结构上看，wrapper 的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递到所有的对象，每个对象都有处理这条请求的机会。

<br><br>

# 回到 JS 的装饰者

JS 语言动态改变对象相当容易，我们可以直接改写对象或者对象的某个方法，并不需要使用 "类" 来实现装饰者模式。

```js
var plane = {
    fire: function () {
        console.log("发射普通子弹");
    },
};

var missileDecorator = function () {
    console.log("发射导弹");
};

var atomDecorator = function () {
    console.log("发射原子弹");
};

var fire1 = plane.fire;
plane.fire = function () {
    fire1();
    missileDecorator();
};

var fire2 = plane.fire;
plane.fire = function () {
    fire2();
    atomDecorator();
};

plane.fire(); // 分别输出：发射普通子弹、发射导弹、发射原子弹
```

<br><br>

# 装饰函数

在 JS 中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能。

要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放封闭原则：

```js
var a = function () {
    alert(1);
};

// 改成：
var a = function () {
    alert(1);
    alert(2);
};
```

很多时候我们不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。甚至在一个古老的项目中，这个函数的源代码被隐藏在一个我们不愿碰触的阴暗角落里。现在需要一个办法，在不改变函数源代码的情况下，能给函数增加功能，这正是开放封闭原则给我们指出的光明道路。

通过保存原引用的方式就可以改写某个函数：

```js
var a = function () {
    alert(1);
};

var _a = a;

a = function () {
    _a();
    alert(2);
};

a();
```

这是实际开发中很常见的一种做法，比如我们想给 window 绑定 onload 事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的 window.onload 函数中的行为，我们一般都会先保存好原先的 window.onload，把它放入新的 window.onload 里执行：

```js
window.onload = function () {
    alert(1);
};

var _onload = window.onload || function () {};

window.onload = function () {
    _onload();
    alert(2);
};
```

这样的代码当然是符合开放封闭原则的，我们在增加新功能的时候，确实没有修改原来的 window.onload 代码，但是这种方式存在以下两个问题：

1.  必须维护 `_onload` 这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多。
2.  其实还遇到了 this 被劫持的问题，在 window.onload 的例子中没有这个烦恼，是因为调用普通函数 `_onload` 时，this 也指向 window，跟调用 window.onload 时一样（函数作为对象的方法被调用时，this 指向该对象，所以此处 this 也只指向 window）。现在把 window.onload 换成 document.getElementById，代码如下：

```js
var _getElementById = document.getElementById;

document.getElementById = function (id) {
    alert(1);
    return _getElementById(id); // (1)
};

var button = document.getElementById("button");
```

执行这段代码，我们看到在弹出 `alert(1)` 之后，紧接着控制台抛出了异常：`Uncaught TypeError: Illegal invocation`。

异常发生在 (1) 处的 `_getElementById(id)` 这句代码上，此时 `_getElementById` 是一个全局函数，当调用一个全局函数时，this 是指向 window 的，而 document.getElementById 方法的内部实现需要使用 this 引用，this 在这个方法内预期是指向 document，而不是 window，这是错误发生的原因，所以使用现在的方式给函数增加功能并不保险。

改进后的代码可以满足需求，我们要手动把 document 当作上下文 this 传入 `_getElementById`：

```js
var _getElementById = document.getElementById;

document.getElementById = function () {
    alert(1);
    return _getElementById.apply(document, arguments);
};

var button = document.getElementById("button");
```

但这样做显然很不方便，下面我们引入 AOP，来提供一种完美的方法给函数动态增加功能。

<br><br>

# 用 AOP 装饰函数

首先给出 Function.prototype.before 方法和 Function.prototype.after 方法：

```js
Function.prototype.before = function (beforeFn) {
    var __self = this; // 保存原函数的引用
    // 返回包含了原函数和新函数的 "代理" 函数
    return function () {
        beforeFn.apply(this, arguments); // 执行新函数 (新函数在原函数之前执行)
        var ret = __self.apply(this, arguments); // 执行原函数并获取原函数的执行结果
        return ret; // 返回原函数的执行结果
    };
};

Function.prototype.after = function (afterFn) {
    var __self = this; // 保存原函数的引用
    // 返回包含了原函数和新函数的 "代理" 函数
    return function () {
        var ret = __self.apply(this, arguments); // 执行原函数并获取原函数的执行结果
        afterFn.apply(this, arguments); // 执行新函数 (新函数在原函数之后执行)
        return ret; // 返回原函数的执行结果
    };
};
```

Function.prototype.before 接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。

接下来把当前的 this 保存起来，这个 this 指向原函数，然后返回一个 "代理" 函数，这个 "代理" 函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。

我们注意到，通过 Function.prototype.apply 来动态传入正确的 this，保证了函数在被装饰之后，this 不会被劫持。

Function.prototype.after 的原理跟 Function.prototype.before 一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行。

下面来试试用 Function.prototype.before 的威力：

```js
Function.prototype.before = function (beforeFn) {
    var __self = this;
    return function () {
        beforeFn.apply(this, arguments);
        var ret = __self.apply(this, arguments);
        return ret;
    };
};

document.getElementById = document.getElementById.before(function () {
    alert(1);
});

var button = document.getElementById("button");
console.log("button", button);
```

再回到 window.onload 的例子，看看用 Function.prototype.after 来增加新的 window.onload 事件是多么简单：

```js
window.onload = function () {
    alert(1);
};

window.onload = (window.onload || function () {})
    .after(function () {
        alert(2);
    })
    .after(function () {
        alert(3);
    })
    .after(function () {
        alert(4);
    });
```

值得提到的是，上面的 AOP 实现是在 Function.prototype 上添加 before 和 after 方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传入 before 或者 after 方法：

```js
var before = function (fn, beforeFn) {
    return function () {
        beforeFn.apply(this, arguments);
        return fn.apply(this, arguments);
    };
};

var a = before(
    function () {
        alert(3);
    },
    function () {
        alert(2);
    }
);

a = before(a, function () {
    alert(1);
});

a();
```

<br><br>

# AOP 的应用实例

用 AOP 装饰函数的技巧在实际开发中非常有用。不论是业务代码的编写，还是在框架层面，我们都可以把行为依照职责分成粒度更细的函数，随后通过装饰把它们合并到一起，这有助于我们编写一个松耦合和高复用性的系统。

<br>

## 数据统计上报

分离业务代码和数据统计代码，无论在什么语言中，都是 AOP 的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。

比如页面中有一个登录 button，点击这个 button 会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录 button：

```html
<button tag="login" id="button">点击打开登录浮层</button>

<script>
    var showLogin = function () {
        console.log("打开登录浮层");
        log(this.getAttribute("tag"));
    };
    var log = function (tag) {
        console.log("上报标签为：" + tag);
        // new Image().src = 'http://xxx.com/report? tag=' + tag; // 真正的上报代码略
    };
    document.getElementById("button").onclick = showLogin;
</script>
```

我们看到在 showLogin 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用 AOP 分离之后，代码如下：

```html
<button tag="login" id="button">点击打开登录浮层</button>

<script>
    Function.prototype.after = function (afterFn) {
        var __self = this;
        return function () {
            var ret = __self.apply(this, arguments);
            afterFn.apply(this, arguments);
            return ret;
        };
    };
    var showLogin = function () {
        console.log("打开登录浮层");
    };
    var log = function () {
        console.log("上报标签为： " + this.getAttribute("tag"));
    };
    showLogin = showLogin.after(log); // 打开登录浮层之后上报数据
    document.getElementById("button").onclick = showLogin;
</script>
```

<br>

## 用 AOP 动态改变函数的参数

观察 Function.prototype.before 方法：

```js
Function.prototype.before = function (beforeFn) {
    var __self = this;
    return function () {
        beforeFn.apply(this, arguments);
        var ret = __self.apply(this, arguments);
        return ret;
    };
};
```

从这段代码可以看到，`beforeFn` 和原函数 `__self` 共用一组参数列表 arguments，当我们在 `beforeFn` 的函数体内改变 arguments 的时候，原函数`__self` 接收的参数列表自然也会变化。

<br>

下面的例子展示了如何通过 Function.prototype.before 方法给函数 func 的参数 param 动态地添加属性 b：

```js
var func = function (param) {
    console.log(param); // {a: "a", b: "b"}
};

func = func.before(function (param) {
    param.b = "b";
});

func({ a: "a" });
```

<br>

现在有一个用于发起 ajax 请求的函数，这个函数负责项目中所有的 ajax 异步请求：

```js
var ajax = function (type, url, param) {
    console.log(type, url, param);
};

ajax("get", "http://xxx.com/userinfo", { name: "sven" });
```

ajax 函数在项目中一直运转良好，跟 cgi 的合作也很愉快。直到有一天，我们的网站遭受了 CSRF 攻击。解决 CSRF 攻击最简单的一个办法就是在 HTTP 请求中带上一个 Token 参数。

假设我们已经有一个用于生成 Token 的函数：

```js
var getToken = function () {
    return "Token";
};
```

现在的任务是给每个 ajax 请求都加上 Token 参数：

```js
var ajax = function (type, url, param) {
    param = param || {};
    param.token = getToken();
    // 发送 ajax 请求的代码略
};
```

虽然已经解决了问题，但我们的 ajax 函数相对变得僵硬了，每个从 ajax 函数里发出的请求都自动带上了 token 参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其他项目上，或者把它放到一个开源库中供其他人使用，token 参数都将是多余的。

也许另一个项目不需要验证 token，或者是 token 的生成方式不同，无论是哪种情况，都必须重新修改 ajax 函数。

为了解决这个问题，先把 ajax 函数还原成一个干净的函数：

```js
var ajax = function (type, url, param) {
    console.log(type, url, param);
};
```

然后把 token 参数通过 Function.prototype.before 装饰到 ajax 函数的参数 param 对象中：

```js
var getToken = function () {
    return "Token";
};

ajax = ajax.before(function (type, url, param) {
    param = param || {};
    param.token = getToken();
});

ajax("get", "http://xxx.com/userinfo", { name: "sven" });
```

从 ajax 函数打印的 log 可以看到，Token 参数已经被附加到了 ajax 请求的参数中：

```bash
get http://xxx.com/userinfo { name: 'sven', token: 'Token' }
```

明显可以看到，用 AOP 的方式给 ajax 函数动态装饰上 Token 参数，保证了 ajax 函数是一个相对纯净的函数，提高了 ajax 函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。

<br>

## 插件式的表单验证

在一个 Web 项目中，可能存在非常多的表单，如注册、登录、修改用户信息等。在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：

```html
用户名：<input id="username" type="text" /> <br />
密码：<input id="password" type="password" /> <br />
<input id="submitBtn" type="button" value="提交" />

<script>
    var username = document.getElementById('username'),
        password = document.getElementById('password'),
        submitBtn = document.getElementById('submitBtn');

    var formSubmit = function () {
        if (username.value === '') {
            return alert('用户名不能为空');
        }
        if (password.value === '') {
            return alert('密码不能为空');
        }
        var param = {
            username: username.value,
            password: password.value,
        };
        ajax('http://xxx.com/login', param); // ajax具体实现略
    };

    submitBtn.onclick = function () {
        ();formSubmit
    };
</script>
```

formSubmit 函数在此处承担了两个职责，除了提交 ajax 请求之外，还要验证用户输入的合法性。这种代码一来会造成函数臃肿，职责混乱，二来谈不上任何可复用性。

本节的目的是分离校验输入和提交 ajax 请求的代码，我们把校验输入的逻辑放到 validate 函数中，并且约定当 validate 函数返回 false 的时候，表示校验未通过，代码如下：

```js
var validate = function () {
    if (username.value === "") {
        alert("用户名不能为空");
        return false;
    }
    if (password.value === "") {
        alert("密码不能为空");
        return false;
    }
};

var formSubmit = function () {
    // 校验未通过
    if (validate() === false) {
        return;
    }
    var param = {
        username: username.value,
        password: password.value,
    };
    ajax("http://xxx.com/login", param);
};

submitBtn.onclick = function () {
    formSubmit();
};
```

现在的代码已经有了一些改进，我们把校验的逻辑都放到了 validate 函数中，但 formSubmit 函数的内部还要计算 validate 函数的返回值，因为返回值的结果表明了是否通过校验。

接下来进一步优化这段代码，使 validate 和 formSubmit 完全分离开来。首先要改写 Function.prototype.before，如果 beforeFn 的执行结果返回 false，表示不再执行后面的原函数，代码如下：

```js
Function.prototype.before = function (beforeFn) {
    var __self = this;
    return function () {
        if (beforeFn.apply(this, arguments) === false) {
            return;
        }
        return __self.apply(this, arguments);
    };
};

var validate = function () {
    if (username.value === "") {
        alert("用户名不能为空");
        return false;
    }
    if (password.value === "") {
        alert("密码不能为空");
        return false;
    }
};

var formSubmit = function () {
    var param = {
        username: username.value,
        password: password.value,
    };
    ajax("http://xxx.com/login", param);
};

formSubmit = formSubmit.before(validate);

submitBtn.onclick = function () {
    formSubmit();
};
```

在这段代码中，校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系，formSubmit=formSubmit.before(validate) 这句代码，如同把校验规则动态接在 formSubmit 函数之前，validate 成为一个即插即用的函数，它甚至可以被写成配置文件的形式，这有利于我们分开维护这两个函数。再利用策略模式稍加改造，我们就可以把这些校验规则都写成插件的形式，用在不同的项目当中。

值得注意的是，因为函数通过 Function.prototype.before 或者 Function.prototype.after 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：

```js
var func = function () {
    alert(1);
};

func.a = "a";

func = func.after(function () {
    alert(2);
});

alert(func.a); // undefined
```

另外，这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些影响。

<br><br>

# 装饰者模式和代理模式

装饰者模式和代理模式的结构看起来非常相像，这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。

代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy 与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能的情况。代理模式通常只有一层代理 - 本体的引用，而装饰者模式经常会形成一条长长的装饰链。

在虚拟代理实现图片预加载的例子中，本体负责设置 img 节点的 src，代理则提供了预加载的功能，这看起来也是“加入行为”的一种方式，但这种加入行为的方式和装饰者模式的偏重点是不一样的。装饰者模式是实实在在的为对象增加新的职责和行为，而代理做的事情还是跟本体一样，最终都是设置 src。但代理可以加入一些 "聪明" 的功能，比如在图片真正加载好之前，先使用一张占位的 loading 图片反馈给客户。

<br>
